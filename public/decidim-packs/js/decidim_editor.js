/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/a11y-dialog-component/dist/a11y-dialog-component.esm.js":
/*!******************************************************************************!*\
  !*** ./node_modules/a11y-dialog-component/dist/a11y-dialog-component.esm.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   setDefaults: function() { return /* binding */ setDefaults; }
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/* defaults.js
 ========================================================================== */

// Global configuration
var config = {
  documentSelector: '.js-document',
  documentDisabledClass: 'is-disabled',
  openingTriggerActiveClass: 'is-active',
  delay: 200
};

/* focusableElements.js
 ========================================================================== */

// Keyboard focusable elements
var focusableElements = ['[href]:not([tabindex^="-"])', 'input:not([disabled]):not([type="hidden"]):not([tabindex^="-"]):not([type="radio"])', 'input[type="radio"]:checked', 'select:not([disabled]):not([tabindex^="-"])', 'textarea:not([disabled]):not([tabindex^="-"])', 'button:not([disabled]):not([tabindex^="-"])', '[tabindex]:not([tabindex^="-"])', '[contenteditable="true"]:not([tabindex^="-"])'];

/* keyCodes.js
 ========================================================================== */

// Keyboard codes
var keyCodes = {
  escape: 'Escape',
  tab: 'Tab',
  f6: 'F6'
};

/* utils.js
 ========================================================================== */

// Only get visible elements
function getVisibleElements(elements) {
  var visibleElements = [];
  elements.forEach(function (element) {
    var bounding = element.getBoundingClientRect();
    var isVisible = bounding.width > 0 || bounding.height > 0;
    if (isVisible) visibleElements.push(element);
  });
  return visibleElements;
}

// Only get no nested elements
function getNoNestedElements(context, selector, elements) {
  var nestedComponents = context.querySelectorAll(selector);
  var noNestedElements = [];
  var isNested = false;
  if (nestedComponents.length === 0) return elements;
  elements.forEach(function (element) {
    nestedComponents.forEach(function (nestedComponent) {
      if (nestedComponent.contains(element)) isNested = true;
    });
    if (!isNested) noNestedElements.push(element);
    isNested = false;
  });
  return noNestedElements;
}

// Check if the parent elements match the target
function closest(element, target) {
  var currentElement = element;
  while (currentElement !== target && currentElement) {
    currentElement = currentElement.parentNode;
  }
  return !!currentElement;
}

/* a11y-dialog-component
 ========================================================================== */

// Use Symbols to create private methods
var onClick = Symbol('onClick');
var onKeydown = Symbol('onKeydown');
var addEventDelegation = Symbol('addEventDelegation');
var addEventListeners = Symbol('addEventListeners');
var removeEventListeners = Symbol('removeEventListeners');
var addAttributes = Symbol('addAttributes');
var removeAttributes = Symbol('removeAttributes');
var setAttributes = Symbol('setAttributes');
var setFocusableElements = Symbol('setFocusableElements');
var setFocus = Symbol('setFocus');
var restoreFocus = Symbol('restoreFocus');
var switchFocus = Symbol('switchFocus');
var maintainFocus = Symbol('maintainFocus');
var addObserver = Symbol('addObserver');
var removeObserver = Symbol('removeObserver');
var customConfig = config;

// Update the global configuration if needed
function setDefaults() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref$documentSelector = _ref.documentSelector,
    documentSelector = _ref$documentSelector === void 0 ? customConfig.documentSelector : _ref$documentSelector,
    _ref$documentDisabled = _ref.documentDisabledClass,
    documentDisabledClass = _ref$documentDisabled === void 0 ? customConfig.documentDisabledClass : _ref$documentDisabled,
    _ref$openingTriggerAc = _ref.openingTriggerActiveClass,
    openingTriggerActiveClass = _ref$openingTriggerAc === void 0 ? customConfig.openingTriggerActiveClass : _ref$openingTriggerAc,
    _ref$delay = _ref.delay,
    delay = _ref$delay === void 0 ? customConfig.delay : _ref$delay;
  customConfig = _objectSpread(_objectSpread({}, config), {
    documentSelector: documentSelector,
    documentDisabledClass: documentDisabledClass,
    openingTriggerActiveClass: openingTriggerActiveClass,
    delay: delay
  });
}

// Export the default Dialog() class
var Dialog = /*#__PURE__*/function () {
  function Dialog(dialogSelector) {
    var _this = this;
    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$onOpen = _ref2.onOpen,
      onOpen = _ref2$onOpen === void 0 ? function () {} : _ref2$onOpen,
      _ref2$onClose = _ref2.onClose,
      onClose = _ref2$onClose === void 0 ? function () {} : _ref2$onClose,
      openingSelector = _ref2.openingSelector,
      closingSelector = _ref2.closingSelector,
      backdropSelector = _ref2.backdropSelector,
      helperSelector = _ref2.helperSelector,
      labelledby = _ref2.labelledby,
      describedby = _ref2.describedby,
      _ref2$isModal = _ref2.isModal,
      isModal = _ref2$isModal === void 0 ? true : _ref2$isModal,
      _ref2$isTooltip = _ref2.isTooltip,
      isTooltip = _ref2$isTooltip === void 0 ? false : _ref2$isTooltip,
      _ref2$isOpen = _ref2.isOpen,
      isOpen = _ref2$isOpen === void 0 ? false : _ref2$isOpen,
      _ref2$isCreated = _ref2.isCreated,
      isCreated = _ref2$isCreated === void 0 ? true : _ref2$isCreated,
      _ref2$disableScroll = _ref2.disableScroll,
      disableScroll = _ref2$disableScroll === void 0 ? true : _ref2$disableScroll,
      _ref2$enableAutoFocus = _ref2.enableAutoFocus,
      enableAutoFocus = _ref2$enableAutoFocus === void 0 ? true : _ref2$enableAutoFocus,
      _ref2$openingTriggerA = _ref2.openingTriggerActiveClass,
      openingTriggerActiveClass = _ref2$openingTriggerA === void 0 ? customConfig.openingTriggerActiveClass : _ref2$openingTriggerA,
      _ref2$delay = _ref2.delay,
      delay = _ref2$delay === void 0 ? customConfig.delay : _ref2$delay;
    _classCallCheck(this, Dialog);
    // Check if the dialog exists, if not, set `isInitialized` to false
    if (!document.querySelector(dialogSelector)) {
      this.isInitialized = false;
      return;
    }

    // Save the initial configuration
    this.config = {
      dialogSelector: dialogSelector,
      onOpen: onOpen,
      onClose: onClose,
      openingSelector: openingSelector,
      closingSelector: closingSelector,
      backdropSelector: backdropSelector,
      helperSelector: helperSelector,
      labelledby: labelledby,
      describedby: describedby,
      isModal: isModal,
      isTooltip: isTooltip,
      isCreated: isCreated,
      isOpen: isOpen,
      disableScroll: disableScroll,
      enableAutoFocus: enableAutoFocus,
      documentSelector: customConfig.documentSelector,
      documentDisabledClass: customConfig.documentDisabledClass,
      openingTriggerActiveClass: openingTriggerActiveClass,
      delay: delay
    };
    this.dialog = document.querySelector(dialogSelector);
    this.dialogArea = "".concat(dialogSelector, ", ").concat(openingSelector);
    this.openingTriggers = document.querySelectorAll(openingSelector);
    this.backdropTrigger = document.querySelector(backdropSelector);
    this.helpers = document.querySelectorAll(helperSelector);
    this.document = document.querySelector(this.config.documentSelector) || document.querySelector('html');
    this.documentIsAlreadyDisabled = false;
    this.focusableElements = [];
    this.firstFocusableElement = null;
    this.lastFocusableElement = null;
    this.openingTrigger = null;
    this.closingTrigger = null;
    this.isCreated = false;
    this.isOpen = false;
    this.close = this.close.bind(this);
    this.toggle = this.toggle.bind(this);
    this[onClick] = this[onClick].bind(this);
    this[onKeydown] = this[onKeydown].bind(this);
    this[addEventDelegation] = this[addEventDelegation].bind(this);
    this[switchFocus] = this[switchFocus].bind(this);

    // Add mutation observer to update focusable elements
    this.observer = new MutationObserver(function (mutations) {
      return mutations.forEach(function () {
        return _this[setFocusableElements]();
      });
    });

    // initialize the dialog
    this.isInitialized = true;

    // Create the dialog
    if (isCreated) this.create();
  }
  _createClass(Dialog, [{
    key: onClick,
    value: function value(event) {
      if (this.config.isTooltip && !event.target.closest(this.dialogArea)) {
        this.close(event);
      }
      if (event.target === this.backdropTrigger) this.close(event);
    }
  }, {
    key: onKeydown,
    value: function value(event) {
      switch (event.key) {
        case keyCodes.escape:
          event.stopPropagation();
          this.close(event);
          break;
        case keyCodes.f6:
          if (!this.config.isModal) !this.config.isTooltip ? this[restoreFocus]() : this.close(event);
          break;
        case keyCodes.tab:
          this[maintainFocus](event);
          break;
      }
    }
  }, {
    key: addEventDelegation,
    value: function value(event) {
      var _this2 = this;
      document.querySelectorAll(this.config.openingSelector).forEach(function (openingTrigger) {
        if (closest(event.target, openingTrigger)) {
          _this2.openingTrigger = openingTrigger;
          _this2.toggle(event);
        }
      });
      document.querySelectorAll(this.config.closingSelector).forEach(function (closingTrigger) {
        if (closest(event.target, closingTrigger)) {
          _this2.closingTrigger = closingTrigger;
          _this2.close();
        }
      });
    }
  }, {
    key: addEventListeners,
    value: function value() {
      document.addEventListener('click', this[onClick], {
        capture: true
      });
      this.dialog.addEventListener('keydown', this[onKeydown]);
    }
  }, {
    key: removeEventListeners,
    value: function value() {
      document.removeEventListener('click', this[onClick], {
        capture: true
      });
      this.dialog.removeEventListener('keydown', this[onKeydown]);
      if (this.openingTrigger) this.openingTrigger.removeEventListener('keydown', this[switchFocus]);
    }
  }, {
    key: addAttributes,
    value: function value() {
      this.dialog.setAttribute('role', 'dialog');
      this.dialog.setAttribute('tabindex', -1);
      this.dialog.setAttribute('aria-hidden', true);
      if (this.config.labelledby) this.dialog.setAttribute('aria-labelledby', this.config.labelledby);
      if (this.config.describedby) this.dialog.setAttribute('aria-describedby', this.config.describedby);
      if (this.config.isModal) this.dialog.setAttribute('aria-modal', true);
      this.openingTriggers.forEach(function (openingTrigger) {
        return openingTrigger.setAttribute('aria-haspopup', 'dialog');
      });
    }
  }, {
    key: removeAttributes,
    value: function value() {
      var _this3 = this;
      this.dialog.removeAttribute('role');
      this.dialog.removeAttribute('tabindex');
      this.dialog.removeAttribute('aria-hidden');
      this.dialog.removeAttribute('aria-labelledby');
      this.dialog.removeAttribute('aria-describedby');
      this.dialog.removeAttribute('aria-modal');
      if (this.config.disableScroll && this.isOpen && !this.documentIsAlreadyDisabled) {
        this.document.classList.remove(this.config.documentDisabledClass);
      }
      this.openingTriggers.forEach(function (openingTrigger) {
        return openingTrigger.removeAttribute('aria-haspopup');
      });
      if (this.openingTrigger) this.openingTrigger.classList.remove(this.config.openingTriggerActiveClass);
      this.helpers.forEach(function (helper) {
        return helper.classList.remove(_this3.config.openingTriggerActiveClass);
      });
    }
  }, {
    key: setAttributes,
    value: function value() {
      var _this4 = this;
      this.dialog.setAttribute('aria-hidden', !this.isOpen);
      if (this.config.disableScroll && !this.documentIsAlreadyDisabled) {
        if (this.isOpen) {
          this.document.classList.add(this.config.documentDisabledClass);
        } else {
          this.document.classList.remove(this.config.documentDisabledClass);
        }
      }
      if (this.openingTrigger) {
        if (this.isOpen) {
          this.openingTrigger.classList.add(this.config.openingTriggerActiveClass);
        } else {
          this.openingTrigger.classList.remove(this.config.openingTriggerActiveClass);
        }
      }
      this.helpers.forEach(function (helper) {
        if (_this4.isOpen) {
          helper.classList.add(_this4.config.openingTriggerActiveClass);
        } else {
          helper.classList.remove(_this4.config.openingTriggerActiveClass);
        }
      });
    }
  }, {
    key: setFocusableElements,
    value: function value() {
      var visibleFocusableElements = getVisibleElements(this.dialog.querySelectorAll(focusableElements));
      var filteredFocusableElements = getNoNestedElements(this.dialog, '[role="dialog"]', visibleFocusableElements);
      this.focusableElements = filteredFocusableElements.length > 0 ? filteredFocusableElements : [this.dialog];
      var _this$focusableElemen = _slicedToArray(this.focusableElements, 1);
      this.firstFocusableElement = _this$focusableElemen[0];
      this.lastFocusableElement = this.focusableElements[this.focusableElements.length - 1];
    }
  }, {
    key: setFocus,
    value: function value() {
      var _this5 = this;
      if (this.config.enableAutoFocus) window.setTimeout(function () {
        return _this5.firstFocusableElement.focus();
      }, this.config.delay);
    }
  }, {
    key: restoreFocus,
    value: function value() {
      var _this6 = this;
      if (this.config.enableAutoFocus) window.setTimeout(function () {
        return _this6.openingTrigger.focus();
      }, this.config.delay);

      // Switch focus between the current opening trigger and the non-modal dialog
      if (this.isOpen) this.openingTrigger.addEventListener('keydown', this[switchFocus]);
    }
  }, {
    key: switchFocus,
    value: function value(event) {
      if (event.key === keyCodes.f6) {
        this.openingTrigger.removeEventListener('keydown', this[switchFocus]);
        this[setFocus]();
      }
    }
  }, {
    key: maintainFocus,
    value: function value(event) {
      if (event.shiftKey && event.target === this.firstFocusableElement) {
        event.preventDefault();
        this.lastFocusableElement.focus();
      }
      if (!event.shiftKey && event.target === this.lastFocusableElement) {
        event.preventDefault();
        this.firstFocusableElement.focus();
      }
    }
  }, {
    key: addObserver,
    value: function value() {
      this.observer.observe(this.dialog, {
        childList: true,
        attributes: true,
        subtree: true
      });
    }
  }, {
    key: removeObserver,
    value: function value() {
      this.observer.disconnect();
    }
  }, {
    key: "open",
    value: function open() {
      if (!this.isInitialized || !this.isCreated || this.isOpen) return;
      this.isOpen = true;
      this.documentIsAlreadyDisabled = this.document.classList.contains(this.config.documentDisabledClass);
      this[setAttributes]();
      this[addEventListeners]();
      this[setFocus]();
      this.config.onOpen(this.dialog, this.openingTrigger);
    }
  }, {
    key: "close",
    value: function close(event) {
      if (!this.isInitialized || !this.isCreated || !this.isOpen) return;
      this.isOpen = false;
      if (event) event.preventDefault();
      this[setAttributes]();
      this[removeEventListeners]();

      // Restore focus except for tooltip click events
      if (this.openingTrigger && (!this.config.isTooltip || this.config.isTooltip && event && event.type !== 'click')) {
        this[restoreFocus]();
      }
      this.config.onClose(this.dialog, this.closingTrigger);
    }
  }, {
    key: "toggle",
    value: function toggle(event) {
      if (!this.isInitialized || !this.isCreated) return;
      if (event) event.preventDefault();
      this.isOpen ? this.close() : this.open();
    }
  }, {
    key: "create",
    value: function create() {
      if (!this.isInitialized || this.isCreated) return;
      this.isCreated = true;
      this[addAttributes]();
      this[setFocusableElements]();
      this[addObserver]();
      if (this.config.isOpen) this.open();
      document.addEventListener('click', this[addEventDelegation], {
        capture: true
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (!this.isInitialized || !this.isCreated) return;
      this.close();
      this.isCreated = false;
      this[removeAttributes]();
      this[removeEventListeners]();
      this[removeObserver]();
      document.removeEventListener('click', this[addEventDelegation], {
        capture: true
      });
    }
  }]);
  return Dialog;
}();
/* harmony default export */ __webpack_exports__["default"] = (Dialog);


/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/common/bubble_menu.js":
/*!*************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/common/bubble_menu.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ BubbleMenu; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}


var createBubbleRoot = function createBubbleRoot(content) {
  var root = document.createElement("div");
  root.style.cssText = "\n    z-index: 9999;\n    position: absolute;\n    visibility: hidden;\n    inset: 0 auto auto 0;\n    margin: 0;\n  ";
  root.dataset.bubbleMenu = "";
  root.append(content);
  return root;
};
var createProseMirrorPlugin = function createProseMirrorPlugin(pluginKey, bubbleMenu) {
  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({
    key: pluginKey,
    view: function view() {
      return {
        update: function update(view, prevState) {
          var state = view.state;
          if (prevState && prevState.doc.eq(state.doc) && prevState.selection.eq(state.selection)) {
            return;
          }
          bubbleMenu.handleSelectionChange(view);
        }
      };
    }
  });
};

/**
 * A custom bubble menu based on `@tiptap/extension-bubble-menu`.
 *
 * This has been customized for this purpose in order to support the use case
 * better and due to some weird behavior in the original extension. This allows
 * us to control also externally when to show and hide the bubble menu instead
 * of leaving it up to the Tiptap extension which does not recognize all the
 * events, such as opening or closing a dialog.
 *
 * The actual bubble menu implementations can implement the following methods by
 * extending this class:
 * - `shouldDisplay()` - defines when the bubble menu is displayed by returning
 *   a boolean indicating the display status, returns `false` by default
 * - `display()` - called when the bubble menu is displayed allowing any updates
 *   to the bubble element by the implementation
 * - `handleAction()` - called when any button within the bubble menu is clicked
 */
var BubbleMenu = /*#__PURE__*/function () {
  function BubbleMenu(_ref) {
    var _this = this;
    var editor = _ref.editor,
      element = _ref.element,
      pluginKey = _ref.pluginKey;
    _classCallCheck(this, BubbleMenu);
    this.editor = editor;
    this.element = element;
    this.element.querySelectorAll("button").forEach(function (el) {
      var action = el.dataset.action;
      el.addEventListener("click", function (ev) {
        ev.preventDefault();
        _this.handleAction(action);
      });
    });
    this.bubble = createBubbleRoot(this.element);
    this.bubbleShown = false;
    this.plugin = createProseMirrorPlugin(pluginKey, this);
    this.editor.registerPlugin(this.plugin);
  }
  _createClass(BubbleMenu, [{
    key: "show",
    value: function show() {
      if (this.bubbleShown) {
        return;
      }
      this.editor.view.dom.parentElement.append(this.bubble);
      this.bubble.style.visibility = "visible";
      this.bubbleShown = true;
    }
  }, {
    key: "hide",
    value: function hide() {
      if (!this.bubbleShown) {
        return;
      }
      this.bubble.style.visibility = "hidden";
      this.bubble.remove();
      this.bubbleShown = false;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.hide();
      this.bubble = null;
      this.editor.unregisterPlugin(this.plugin.key);
    }
  }, {
    key: "handleSelectionChange",
    value: function handleSelectionChange(view) {
      if (this.editor.commands.isDialogOpen()) {
        this.hide();
        return;
      }
      if (this.shouldDisplay(view)) {
        this.display(view);
        this.show();
        this.updatePosition(view);
        return;
      }
      this.hide();
    }
  }, {
    key: "getReferenceRect",
    value: function getReferenceRect(view) {
      var state = view.state;
      var ranges = state.selection.ranges;
      var from = Math.min.apply(Math, _toConsumableArray(ranges.map(function (range) {
        return range.$from.pos;
      })));
      var to = Math.max.apply(Math, _toConsumableArray(ranges.map(function (range) {
        return range.$to.pos;
      })));
      if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeSelection)(state.selection)) {
        var node = view.nodeDOM(from);
        if (node) {
          return node.getBoundingClientRect();
        }
      }
      return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.posToDOMRect)(view, from, to);
    }
  }, {
    key: "updatePosition",
    value: function updatePosition(view) {
      var editorRect = view.dom.getBoundingClientRect();
      var referenceRect = this.getReferenceRect(view);
      var xDiff = referenceRect.left - editorRect.left;
      var yDiff = referenceRect.top - editorRect.top;
      var width = this.bubble.clientWidth;
      var height = this.bubble.clientHeight;
      var xPos = Math.round(xDiff - width / 2);
      if (xPos < 5) {
        xPos = 5;
      }
      var yPos = Math.round(yDiff + height - 5);
      if (yPos < 5) {
        yPos = 5;
      }
      this.bubble.style.transform = "translate(".concat(xPos, "px, ").concat(yPos, "px)");
    }
  }, {
    key: "shouldDisplay",
    value: function shouldDisplay() {
      // This can be overridden by the implementation
      return false;
    }
  }, {
    key: "display",
    value: function display() {
      // This can be overridden by the implementation
    }
  }, {
    key: "handleAction",
    value: function handleAction() {
      // This can be overridden by the implementation
    }
  }]);
  return BubbleMenu;
}();


/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/common/helpers.js":
/*!*********************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/common/helpers.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   uniqueId: function() { return /* binding */ uniqueId; }
/* harmony export */ });
var uniqueId = function uniqueId(prefix) {
  return "".concat(prefix, "-").concat(new Date().getTime(), "-").concat(Math.random().toString(16).slice(2));
};

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/common/input_dialog.js":
/*!**************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/common/input_dialog.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ InputDialog; }
/* harmony export */ });
/* harmony import */ var a11y_dialog_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! a11y-dialog-component */ "./node_modules/a11y-dialog-component/dist/a11y-dialog-component.esm.js");
/* harmony import */ var src_decidim_i18n__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/decidim/i18n */ "./gems/decidim-module-core/app/packs/src/decidim/i18n.js");
/* harmony import */ var src_decidim_editor_common_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! src/decidim/editor/common/helpers */ "./gems/decidim-module-core/app/packs/src/decidim/editor/common/helpers.js");
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}



var InputDialog = /*#__PURE__*/function () {
  function InputDialog(editor, _ref) {
    var _this = this;
    var inputs = _ref.inputs;
    _classCallCheck(this, InputDialog);
    this.editor = editor;
    var inputId = (0,src_decidim_editor_common_helpers__WEBPACK_IMPORTED_MODULE_2__.uniqueId)("inputdialog");
    this.element = document.createElement("div");
    this.element.dataset.dialog = "".concat(Math.random().toString(36).slice(2));
    var inputsHTML = "";
    Object.keys(inputs).forEach(function (name) {
      var input = inputs[name];
      var inputHTML = "";
      if (input.type === "select") {
        var optionsHTML = input.options.map(function (opt) {
          return "<option value=\"".concat(opt.value, "\">").concat(opt.label, "</option>");
        });
        inputHTML = "<select id=\"".concat(inputId, "-").concat(name, "\">").concat(optionsHTML, "</select>");
      } else {
        inputHTML = "<input id=\"".concat(inputId, "-").concat(name, "\" type=\"").concat(input.type || "text", "\">");
      }
      inputsHTML += "\n        <div data-input=\"".concat(name, "\">\n          <label>\n            ").concat(input.label, "\n            ").concat(inputHTML, "\n          </label>\n        </div>\n      ");
    });
    var i18n = (0,src_decidim_i18n__WEBPACK_IMPORTED_MODULE_1__.getDictionary)("editor.inputDialog");
    var uniq = this.element.dataset.dialog;
    this.element.innerHTML = "\n      <div id=\"".concat(uniq, "-content\">\n        <button type=\"button\" data-dialog-close=\"").concat(uniq, "\" data-dialog-closable=\"\" aria-label=\"").concat(i18n.close, "\">&times</button>\n        <div data-dialog-container>\n          <form class=\"form-defaults form\">\n            <div class=\"form__wrapper\">\n              ").concat(inputsHTML, "\n            </div>\n            <input type=\"submit\" hidden>\n          </form>\n        </div>\n        <div data-dialog-actions>\n          <button type=\"button\" class=\"button button__sm md:button__lg button__transparent-secondary\" data-action=\"cancel\">").concat(i18n["buttons.cancel"], "</button>\n          <button type=\"button\" class=\"button button__sm md:button__lg button__secondary\" data-action=\"save\">").concat(i18n["buttons.save"], "</button>\n        </div>\n      </div>\n    ");
    document.body.appendChild(this.element);
    this.dialog = new a11y_dialog_component__WEBPACK_IMPORTED_MODULE_0__["default"]("[data-dialog=\"".concat(uniq, "\"]"), {
      // openingSelector: `[data-dialog-open="${uniq}"]`,
      closingSelector: "[data-dialog-close=\"".concat(uniq, "\"]"),
      backdropSelector: "[data-dialog=\"".concat(uniq, "\"]"),
      enableAutoFocus: false,
      onOpen: function onOpen() {
        setTimeout(function () {
          return _this.focusFirstInput();
        }, 0);
      },
      onClose: function onClose() {
        setTimeout(function () {
          return _this.handleClose();
        }, 0);
      }
    });
    this.element.querySelector("form").addEventListener("submit", function (ev) {
      ev.preventDefault();
      var btn = _this.element.querySelector("button[data-action='save']");
      btn.dispatchEvent(new Event("click"));
    });
    this.element.querySelectorAll("button[data-action]").forEach(function (button) {
      button.addEventListener("click", function (ev) {
        ev.preventDefault();
        _this.action = button.dataset.action;
        _this.close();
      });
    });
  }
  _createClass(InputDialog, [{
    key: "toggle",
    value: function toggle() {
      var _this2 = this;
      var currentValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new Promise(function (resolve) {
        _this2.element.querySelectorAll("[data-input]").forEach(function (wrapper) {
          var input = wrapper.querySelector("input, select");
          var currentValue = currentValues[wrapper.dataset.input];
          if (currentValue) {
            input.value = currentValue;
          } else {
            input.value = "";
          }
        });
        _this2.callback = resolve;
        _this2.action = null;
        _this2.editor.commands.toggleDialog(true);
        _this2.dialog.open();
      });
    }
  }, {
    key: "close",
    value: function close() {
      this.dialog.close();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.dialog.destroy();
      this.element.remove();
      Reflect.deleteProperty(this, "dialog");
    }

    /**
     * This is fired when the dialog is actually closed. The `close()` method only
     * initiates the closing of the dialog.
     *
     * @returns {void}
     */
  }, {
    key: "handleClose",
    value: function handleClose() {
      this.editor.chain().toggleDialog(false).focus(null, {
        scrollIntoView: false
      }).run();
      if (this.callback) {
        this.callback(this.action);
        this.callback = null;
      }
      if (this.action) {
        this.action = null;
      }
      this.destroy();
    }
  }, {
    key: "focusFirstInput",
    value: function focusFirstInput() {
      var firstInput = this.element.querySelector("input, select");
      if (firstInput) {
        firstInput.focus();
      }
    }
  }, {
    key: "getValue",
    value: function getValue() {
      var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "default";
      var wrapper = this.element.querySelector("[data-input=\"".concat(key, "\"]"));
      if (!wrapper) {
        return null;
      }
      var input = wrapper.querySelector("input, select");
      if (input) {
        return input.value;
      }
      return null;
    }
  }]);
  return InputDialog;
}();


/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/common/suggestion.js":
/*!************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/common/suggestion.js ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createNodeView: function() { return /* binding */ createNodeView; },
/* harmony export */   createSuggestionRenderer: function() { return /* binding */ createSuggestionRenderer; }
/* harmony export */ });
/* global jest */

var createSuggestionRenderer = function createSuggestionRenderer(node) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    itemConverter = _ref.itemConverter;
  return function () {
    var suggestion = null;
    var suggestionItems = null;
    var selectCommand = null;
    var selectedIndex = -1;
    var currentEditor = null;
    var currentRange = null;
    var convertItem = function convertItem(item) {
      var finalItem = item;
      if (itemConverter) {
        finalItem = itemConverter(item);
      }
      if (finalItem instanceof Object) {
        return finalItem;
      }
      return {
        label: finalItem
      };
    };
    var updateSelectedItem = function updateSelectedItem(direction) {
      var count = 0;
      suggestion.querySelectorAll(".editor-suggestions-item").forEach(function (item, idx) {
        if (item.dataset.selected === "true") {
          selectedIndex = idx;
        }
        item.removeAttribute("data-selected");
        count += 1;
      });
      if (direction === "up") {
        selectedIndex -= 1;
      } else {
        selectedIndex += 1;
      }
      if (selectedIndex < 0) {
        selectedIndex = 0;
      } else if (selectedIndex === count) {
        selectedIndex -= 1;
      }
      if (selectedIndex > -1) {
        var item = suggestion.querySelector(".editor-suggestions-item[data-index=\"".concat(selectedIndex, "\"]"));
        if (item) {
          item.dataset.selected = "true";
        }
      }
    };
    var selectItem = function selectItem(idx) {
      var items = suggestionItems;
      var command = selectCommand;
      if (currentRange && typeof jest === "undefined") {
        // Fixes an issue that after selecting the item, the written text will be
        // placed after the newly added suggestion.
        //
        // NOTE: With JSDom/Jest this does not work even if we add a delay after
        // changing the text in the selection. This is because the range remains
        // the same for the `command` below which is why the underlying code is
        // trying to do an insertion at a position that is out of range after we
        // have already deleted the content.
        currentEditor.chain().focus().setTextSelection(currentRange).command(function (_ref2) {
          var tr = _ref2.tr,
            dispatch = _ref2.dispatch;
          if (dispatch) {
            tr.replaceSelectionWith(currentEditor.schema.text("  "));
          }
          return true;
        }).setTextSelection({
          from: currentRange.from,
          to: currentRange.from
        }).run();
      }
      command(convertItem(items[idx]));
    };
    var showSuggestions = function showSuggestions(_ref3) {
      var items = _ref3.items,
        clientRect = _ref3.clientRect;
      var rect = clientRect();
      Object.assign(suggestion.style, {
        position: "absolute",
        top: "".concat(document.documentElement.scrollTop + rect.top + rect.height, "px"),
        left: "".concat(rect.left, "px")
      });
      suggestion.classList.remove("hidden", "hide");
      suggestion.innerHTML = "";
      items.forEach(function (rawItem, idx) {
        var _convertItem = convertItem(rawItem),
          label = _convertItem.label,
          id = _convertItem.id;
        var suggestionItem = document.createElement("button");
        suggestionItem.type = "button";
        suggestionItem.classList.add("editor-suggestions-item");
        if (id) {
          suggestionItem.dataset.id = id;
        }
        suggestionItem.dataset.index = idx;
        suggestionItem.dataset.value = label;
        if (idx === 0) {
          selectedIndex = idx;
          suggestionItem.dataset.selected = "true";
        }
        suggestionItem.textContent = label;
        suggestion.append(suggestionItem);
        suggestionItem.addEventListener("click", function () {
          return selectItem(idx);
        });
      });
    };
    return {
      onStart: function onStart(_ref4) {
        var editor = _ref4.editor,
          items = _ref4.items,
          clientRect = _ref4.clientRect,
          command = _ref4.command;
        currentEditor = editor;
        suggestionItems = items;
        selectCommand = command;
        suggestion = document.createElement("div");
        document.body.append(suggestion);
        suggestion.classList.add("editor-suggestions", "hidden", "hide");
        if (items.length > 0) {
          showSuggestions({
            clientRect: clientRect,
            items: items
          });
        }
      },
      onUpdate: function onUpdate(_ref5) {
        var clientRect = _ref5.clientRect,
          items = _ref5.items;
        if (!clientRect || !suggestion) {
          return;
        }
        suggestionItems = items;
        if (items.length > 0) {
          showSuggestions({
            clientRect: clientRect,
            items: items
          });
        } else {
          suggestion.classList.add("editor-suggestions", "hidden", "hide");
        }
      },
      onKeyDown: function onKeyDown(_ref6) {
        var event = _ref6.event,
          range = _ref6.range;
        currentRange = range;
        if (event.key === "Escape") {
          suggestion.classList.add("hidden", "hide");
          return true;
        } else if (event.key === "ArrowUp") {
          updateSelectedItem("up");
          return true;
        } else if (event.key === "ArrowDown") {
          updateSelectedItem("down");
          return true;
        } else if (event.key === "Enter") {
          if (selectedIndex > -1) {
            selectItem(selectedIndex);
          }
          selectedIndex = -1;
          return true;
        }
        return false;
      },
      onExit: function onExit() {
        suggestion.remove();
        suggestion = suggestionItems = selectCommand = currentEditor = currentRange = null;
        selectedIndex = -1;
      }
    };
  };
};
var createNodeView = function createNodeView(self) {
  return function (_ref7) {
    var node = _ref7.node;
    var dom = document.createElement("span");
    dom.textContent = self.options.renderLabel({
      options: self.options,
      node: node
    });
    var _node$attrs = node.attrs,
      id = _node$attrs.id,
      label = _node$attrs.label;
    dom.dataset.suggestion = node.type.name;
    if (id) {
      dom.dataset.id = id;
    }
    dom.dataset.label = label;
    return {
      dom: dom
    };
  };
};

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/common/upload_dialog.js":
/*!***************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/common/upload_dialog.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ UploadDialog; }
/* harmony export */ });
/* harmony import */ var src_decidim_icon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! src/decidim/icon */ "./gems/decidim-module-core/app/packs/src/decidim/icon.js");
/* harmony import */ var src_decidim_editor_utilities_file__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/decidim/editor/utilities/file */ "./gems/decidim-module-core/app/packs/src/decidim/editor/utilities/file.js");
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}


var createElement = function createElement(template) {
  var el = document.createElement("div");
  el.innerHTML = template;
  return el.firstElementChild;
};

/**
 * This is a simplified version of the normal upload dialog, uses the same
 * markup as the normal upload dialog to maintain consistency.
 *
 * The functionality differs from the original dialog as this only handles the
 * file uploads for the editor and the purpose is to simply provide the same
 * upload functionality and ability to update the alternative texts for the
 * images within the editor.
 *
 * This works only for the editor and does not store the files in the view
 * inputs as they are only used.
 */
var UploadDialog = /*#__PURE__*/function () {
  function UploadDialog(element, _ref) {
    var _this = this;
    var i18n = _ref.i18n,
      onOpen = _ref.onOpen,
      onClose = _ref.onClose;
    _classCallCheck(this, UploadDialog);
    this.element = element;
    this.i18n = i18n;
    this.onOpen = onOpen;
    this.onClose = onClose;
    this.values = {
      src: null,
      alt: null
    };
    this.dropZoneEnabled = true;
    this.exitMode = "cancel";
    var extra = null;
    this.messageSection = document.createElement("div");
    this.currentFileSection = document.createElement("div");
    this.inputSection = document.createElement("div");
    this.saveButton = this.element.querySelector("button[data-dropzone-save]");
    this.cancelButton = this.element.querySelector("button[data-dropzone-cancel]");
    this.dropZone = this.element.querySelector("[data-dropzone]");
    extra = document.createElement("div");
    this.dropZone.parentNode.insertBefore(extra, this.dropZone.nextSibling);
    extra.append(this.messageSection);
    extra.append(this.currentFileSection);
    this.dropZone.parentNode.querySelector(".upload-modal__text").classList.add("mb-0");
    this.dropZone.parentNode.append(this.inputSection);
    this.saveButton.addEventListener("click", function () {
      _this.exitMode = "save";
    });
    this.cancelButton.addEventListener("click", function () {
      _this.exitMode = "cancel";
    });
    this.dropZone.addEventListener("change", function (event) {
      event.preventDefault();
      var files = event.target.files;
      if (files.length < 1) {
        return;
      }
      _this.uploadFile(files[0]);
    });
    var toggleDragover = function toggleDragover(active) {
      if (active) {
        _this.dropZone.classList.add("is-dragover");
        _this.dropZone.querySelectorAll(".upload-modal__dropzone").forEach(function (el) {
          return el.classList.add("is-dragover");
        });
      } else {
        _this.dropZone.classList.remove("is-dragover");
        _this.dropZone.querySelectorAll(".upload-modal__dropzone").forEach(function (el) {
          return el.classList.remove("is-dragover");
        });
      }
    };
    var dropEvents = {
      dragenter: function dragenter(event) {
        return event.preventDefault();
      },
      dragleave: function dragleave() {
        return toggleDragover(false);
      },
      dragover: function dragover(event) {
        event.preventDefault();
        toggleDragover(true);
      },
      drop: function drop(event) {
        event.preventDefault();
        toggleDragover(false);
        _this.messageSection.innerHTML = "";
        var files = event.dataTransfer.files;
        if (files.length < 1) {
          return;
        }
        _this.uploadFile(files[0]);
      }
    };
    Object.keys(dropEvents).forEach(function (key) {
      _this.dropZone.addEventListener(key, dropEvents[key]);
    });
    var handleClose = function handleClose() {
      var titleInput = _this.inputSection.querySelector(".attachment-title");
      if (titleInput) {
        _this.values.alt = titleInput.value;
      }
      if (_this.onClose) {
        _this.onClose(_this);
      }
      if (_this.callback) {
        _this.callback(_this.exitMode);
        _this.callback = null;
      }
    };
    this.element.addEventListener("close.dialog", function () {
      return setTimeout(handleClose, 0);
    });
  }
  _createClass(UploadDialog, [{
    key: "getValue",
    value: function getValue(key) {
      return this.values[key];
    }
  }, {
    key: "toggle",
    value: function toggle() {
      var _this2 = this;
      var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.exitMode = "cancel";
      return new Promise(function (resolve) {
        _this2.saveButton.disabled = true;
        _this2.values = {
          src: values.src,
          alt: values.alt
        };
        _this2.updateCurrentFile();
        var titleEl = _this2.element.querySelector("[data-dialog-title]");
        if (values.src && values.src.length > 0) {
          titleEl.textContent = titleEl.dataset.editlabel;
        } else {
          titleEl.textContent = titleEl.dataset.addlabel;
        }
        var titleInputHtml = "\n        <form class=\"form-defaults form\">\n          <label>\n            ".concat(options.inputLabel, "\n            <input class=\"attachment-title\" type=\"text\" name=\"alt\">\n          </label>\n        </form>\n      ");
        var titleSection = null;
        titleSection = createElement("<div class=\"form__wrapper\">".concat(titleInputHtml, "</div>"));
        titleSection.querySelector(".attachment-title").value = values.alt || "";
        _this2.inputSection.innerHTML = "";
        _this2.inputSection.append(titleSection);
        _this2.uploadHandler = options.uploadHandler;
        var dialogId = _this2.element.dataset.dialog;
        var dialog = window.Decidim.currentDialogs[dialogId];
        if (dialog) {
          dialog.open();
        } else {
          console.error("Upload dialog not initialized for: ".concat(dialogId));
        }
        _this2.callback = resolve;
        if (_this2.onOpen) {
          _this2.onOpen(_this2);
        }
      });
    }
  }, {
    key: "updateCurrentFile",
    value: function updateCurrentFile(file) {
      var items = this.dropZone.querySelector("[data-dropzone-items]");
      if (!this.values.src || this.values.src.length < 1) {
        items.setAttribute("hidden", "hidden");
        items.innerHTML = "";
        return;
      }
      this.saveButton.disabled = false;
      if (file) {
        items.removeAttribute("hidden");
        items.innerHTML = "\n        <li data-filename=\"".concat(file.name, "\" data-state=\"validated\">\n          <div data-template=\"ok\">\n            <div><img src=\"").concat(this.values.src, "\" alt=\"").concat(this.i18n.uploadedFile, "\"></div>\n            <span>").concat(file.name, "</span>\n          </div>\n        </li>\n      ");
      }
    }
  }, {
    key: "uploadFile",
    value: function () {
      var _uploadFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(file) {
        var response, items, locales, titleInput;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (this.uploadHandler) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return");
            case 2:
              _context.next = 4;
              return this.uploadHandler(file);
            case 4:
              response = _context.sent;
              if (response.url) {
                _context.next = 11;
                break;
              }
              items = this.dropZone.querySelector("[data-dropzone-items]");
              locales = JSON.parse(items.dataset.locales);
              items.removeAttribute("hidden");
              items.innerHTML = "\n        <li data-filename=\"".concat(file.name, "\" data-state=\"validated\">\n          <div data-template=\"error\">\n            <div>").concat((0,src_decidim_icon__WEBPACK_IMPORTED_MODULE_0__["default"])("error-warning-line"), "</div>\n            <div>\n              <span>").concat(file.name, "</span>\n              <span>").concat(locales.validation_error, "</span>\n              <ul><li>").concat(response.message, "</li></ul>\n            </div>\n          </div>\n        </li>\n      ");
              return _context.abrupt("return");
            case 11:
              this.values.src = response.url;
              titleInput = this.inputSection.querySelector(".attachment-title");
              if (titleInput && (!titleInput.value || titleInput.value.length < 1)) {
                titleInput.value = (0,src_decidim_editor_utilities_file__WEBPACK_IMPORTED_MODULE_1__.fileNameToTitle)(file.name);
              }
              this.updateCurrentFile(file);
            case 15:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function uploadFile(_x) {
        return _uploadFile.apply(this, arguments);
      }
      return uploadFile;
    }()
  }]);
  return UploadDialog;
}();


/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/bold/index.js":
/*!****************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/bold/index.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-bold */ "./node_modules/@tiptap/extension-bold/dist/index.js");


/**
 * Extends the bold extension to fix a bug with pasting the following kind of
 * content from Google docs (this is about how Google docs formats the content):
 *
 * <b style="font-weight:normal;">
 *   <ol>
 *      <li><p><span style="font-weight:700;">Item 1</span></p></li>
 *      <ol>
 *        <li><p><span style="font-weight:400;">Item 1</span></p></li>
 *      </ol>
 *   </ol>
 * </b>
 *
 * See: https://github.com/ueberdosis/tiptap/issues/3735
 */
/* harmony default export */ __webpack_exports__["default"] = (_tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
  parseHTML: function parseHTML() {
    return [{
      tag: "strong"
    }, {
      tag: "b",
      getAttrs: function getAttrs(node) {
        return node.style.fontWeight !== "normal" && node.style.fontWeight !== "400" && null;
      }
    }, {
      tag: "span",
      getAttrs: function getAttrs(node) {
        return /^(bold(er)?|[5-9]\d{2,})$/.test(node.style.fontWeight) && null;
      }
    }];
  }
}));

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/character_count/index.js":
/*!***************************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/character_count/index.js ***!
  \***************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");
/* harmony import */ var _tiptap_extension_character_count__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-character-count */ "./node_modules/@tiptap/extension-character-count/dist/index.js");
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}



/**
 * Extends the character counter to prevent adding new paragraphs after the
 * character limit is reached. The original character counter allows that.
 *
 * See: https://github.com/ueberdosis/tiptap/issues/3721
 */
/* harmony default export */ __webpack_exports__["default"] = (_tiptap_extension_character_count__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
  addProseMirrorPlugins: function addProseMirrorPlugins() {
    var _this$parent;
    var limit = this.options.limit;
    var plugins = (_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.call(this);
    if (limit === 0 || limit === null || !limit) {
      return plugins;
    }
    var storage = this.editor.storage;
    return [].concat(_toConsumableArray(plugins), [new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({
      props: {
        handleKeyDown: function handleKeyDown(view, event) {
          if (event.key === "Enter") {
            return storage.characterCount.characters() >= limit;
          }
          return false;
        }
      }
    })]);
  }
}));

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/decidim_kit/index.js":
/*!***********************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/decidim_kit/index.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
/* harmony import */ var _tiptap_starter_kit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/starter-kit */ "./node_modules/@tiptap/starter-kit/dist/index.js");
/* harmony import */ var _tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/extension-code-block */ "./node_modules/@tiptap/extension-code-block/dist/index.js");
/* harmony import */ var _tiptap_extension_underline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/extension-underline */ "./node_modules/@tiptap/extension-underline/dist/index.js");
/* harmony import */ var src_decidim_editor_extensions_character_count__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! src/decidim/editor/extensions/character_count */ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/character_count/index.js");
/* harmony import */ var src_decidim_editor_extensions_bold__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! src/decidim/editor/extensions/bold */ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/bold/index.js");
/* harmony import */ var src_decidim_editor_extensions_dialog__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! src/decidim/editor/extensions/dialog */ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/dialog/index.js");
/* harmony import */ var src_decidim_editor_extensions_hashtag__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! src/decidim/editor/extensions/hashtag */ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/hashtag/index.js");
/* harmony import */ var src_decidim_editor_extensions_heading__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! src/decidim/editor/extensions/heading */ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/heading/index.js");
/* harmony import */ var src_decidim_editor_extensions_ordered_list__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! src/decidim/editor/extensions/ordered_list */ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/ordered_list/index.js");
/* harmony import */ var src_decidim_editor_extensions_image__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! src/decidim/editor/extensions/image */ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/image/index.js");
/* harmony import */ var src_decidim_editor_extensions_indent__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! src/decidim/editor/extensions/indent */ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/indent/index.js");
/* harmony import */ var src_decidim_editor_extensions_link__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! src/decidim/editor/extensions/link */ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/link/index.js");
/* harmony import */ var src_decidim_editor_extensions_mention__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! src/decidim/editor/extensions/mention */ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/mention/index.js");
/* harmony import */ var src_decidim_editor_extensions_video_embed__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! src/decidim/editor/extensions/video_embed */ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/video_embed/index.js");
/* harmony import */ var src_decidim_editor_extensions_emoji__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! src/decidim/editor/extensions/emoji */ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/emoji/index.js");
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
















/* harmony default export */ __webpack_exports__["default"] = (_tiptap_core__WEBPACK_IMPORTED_MODULE_15__.Extension.create({
  name: "decidimKit",
  addOptions: function addOptions() {
    return {
      characterCount: {
        limit: null
      },
      heading: {
        levels: [2, 3, 4, 5, 6]
      },
      link: {
        allowTargetControl: false
      },
      videoEmbed: false,
      image: {
        uploadDialogSelector: null,
        uploadImagesPath: null,
        contentTypes: /^image\/(jpe?g|png|svg|webp)$/i
      },
      hashtag: false,
      mention: false,
      emoji: false
    };
  },
  addExtensions: function addExtensions() {
    var extensions = [_tiptap_starter_kit__WEBPACK_IMPORTED_MODULE_0__["default"].configure({
      heading: false,
      bold: false,
      orderedList: false,
      codeBlock: false
    }), src_decidim_editor_extensions_character_count__WEBPACK_IMPORTED_MODULE_3__["default"].configure(this.options.characterCount), src_decidim_editor_extensions_link__WEBPACK_IMPORTED_MODULE_11__["default"].configure(_objectSpread({
      openOnClick: false
    }, this.options.link)), src_decidim_editor_extensions_bold__WEBPACK_IMPORTED_MODULE_4__["default"], src_decidim_editor_extensions_dialog__WEBPACK_IMPORTED_MODULE_5__["default"], src_decidim_editor_extensions_indent__WEBPACK_IMPORTED_MODULE_10__["default"], src_decidim_editor_extensions_ordered_list__WEBPACK_IMPORTED_MODULE_8__["default"], _tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_1__["default"], _tiptap_extension_underline__WEBPACK_IMPORTED_MODULE_2__["default"]];
    if (this.options.heading !== false) {
      extensions.push(src_decidim_editor_extensions_heading__WEBPACK_IMPORTED_MODULE_7__["default"].configure(this.options.heading));
    }
    if (this.options.videoEmbed !== false) {
      extensions.push(src_decidim_editor_extensions_video_embed__WEBPACK_IMPORTED_MODULE_13__["default"].configure(this.options.videoEmbed));
    }
    if (this.options.image !== false && this.options.image.uploadDialogSelector) {
      extensions.push(src_decidim_editor_extensions_image__WEBPACK_IMPORTED_MODULE_9__["default"].configure(this.options.image));
    }
    if (this.options.hashtag !== false) {
      extensions.push(src_decidim_editor_extensions_hashtag__WEBPACK_IMPORTED_MODULE_6__["default"].configure(this.options.hashtag));
    }
    if (this.options.mention !== false) {
      extensions.push(src_decidim_editor_extensions_mention__WEBPACK_IMPORTED_MODULE_12__["default"].configure(this.options.mention));
    }
    if (this.options.emoji !== false) {
      extensions.push(src_decidim_editor_extensions_emoji__WEBPACK_IMPORTED_MODULE_14__["default"].configure(this.options.emoji));
    }
    return extensions;
  }
}));

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/dialog/index.js":
/*!******************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/dialog/index.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");


/* harmony default export */ __webpack_exports__["default"] = (_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({
  name: "dialog",
  addStorage: function addStorage() {
    return {
      open: false
    };
  },
  addCommands: function addCommands() {
    var _this = this;
    return {
      isDialogOpen: function isDialogOpen() {
        return function () {
          return _this.storage.open;
        };
      },
      toggleDialog: function toggleDialog(open) {
        return function () {
          return _this.storage.open = open;
        };
      }
    };
  },
  addProseMirrorPlugins: function addProseMirrorPlugins() {
    var _this2 = this;
    return [new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({
      key: new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey("editable"),
      props: {
        attributes: function attributes() {
          if (_this2.storage.open) {
            return {
              "class": "dialog-open"
            };
          }
          return {};
        }
      }
    })];
  }
}));

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/emoji/index.js":
/*!*****************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/emoji/index.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
/* harmony import */ var src_decidim_input_emoji__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! src/decidim/input_emoji */ "./gems/decidim-module-core/app/packs/src/decidim/input_emoji.js");


var createEmojiButton = function createEmojiButton(editor) {
  var dom = editor.view.dom;
  return new src_decidim_input_emoji__WEBPACK_IMPORTED_MODULE_0__.EmojiButton(dom);
};
/* harmony default export */ __webpack_exports__["default"] = (_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({
  name: "emoji",
  onCreate: function onCreate(_ref) {
    var editor = _ref.editor;
    createEmojiButton(editor);
  }
}));

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/hashtag/index.js":
/*!*******************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/hashtag/index.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HashtagPluginKey: function() { return /* binding */ HashtagPluginKey; }
/* harmony export */ });
/* harmony import */ var _tiptap_extension_mention__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-mention */ "./node_modules/@tiptap/extension-mention/dist/index.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");
/* harmony import */ var src_decidim_editor_common_suggestion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/decidim/editor/common/suggestion */ "./gems/decidim-module-core/app/packs/src/decidim/editor/common/suggestion.js");
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}



var HashtagPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey("hashtag");
var searchHashtags = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(queryText) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          return _context.abrupt("return", fetch("/api", {
            method: "POST",
            cache: "no-cache",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              query: "{ hashtags(name:\"".concat(queryText, "\") {name} }")
            })
          }).then(function (response) {
            if (response.ok) {
              return response.json();
            }
            throw new Error("Could not retrieve data");
          }).then(function (json) {
            return json.data.hashtags || [];
          }));
        case 1:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function searchHashtags(_x) {
    return _ref.apply(this, arguments);
  };
}();

/**
 * The hashtag extension does not yet exist in the TipTap public repository and
 * also the documentation page shows it as
 * https://tiptap.dev/api/nodes/hashtag
 */
/* harmony default export */ __webpack_exports__["default"] = (_tiptap_extension_mention__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
  name: "hashtag",
  addOptions: function addOptions() {
    var _this$parent;
    var options = (_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.call(this);
    var suggestion = options === null || options === void 0 ? void 0 : options.suggestion;
    return _objectSpread(_objectSpread({}, options), {}, {
      renderLabel: function renderLabel(_ref2) {
        var _node$attrs$label;
        var node = _ref2.node;
        // The labels already have the suggestion character in front of them
        // which is why we do not want to add it twice.
        return "".concat((_node$attrs$label = node.attrs.label) !== null && _node$attrs$label !== void 0 ? _node$attrs$label : node.attrs.id);
      },
      suggestion: _objectSpread(_objectSpread({}, suggestion), {}, {
        "char": "#",
        pluginKey: HashtagPluginKey,
        items: function () {
          var _items = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref3) {
            var query, data, sorted;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  query = _ref3.query;
                  if (!(query.length < 2)) {
                    _context2.next = 3;
                    break;
                  }
                  return _context2.abrupt("return", []);
                case 3:
                  _context2.next = 5;
                  return searchHashtags(query);
                case 5:
                  data = _context2.sent;
                  sorted = data.sort(function (tag) {
                    return tag.name;
                  });
                  return _context2.abrupt("return", sorted.slice(0, 5));
                case 8:
                case "end":
                  return _context2.stop();
              }
            }, _callee2);
          }));
          function items(_x2) {
            return _items.apply(this, arguments);
          }
          return items;
        }(),
        render: (0,src_decidim_editor_common_suggestion__WEBPACK_IMPORTED_MODULE_1__.createSuggestionRenderer)(this, {
          itemConverter: function itemConverter(tag) {
            return {
              label: "#".concat(tag.name)
            };
          }
        })
      })
    });
  },
  addNodeView: function addNodeView() {
    return (0,src_decidim_editor_common_suggestion__WEBPACK_IMPORTED_MODULE_1__.createNodeView)(this);
  }
}));

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/heading/index.js":
/*!*******************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/heading/index.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
/* harmony import */ var _tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-heading */ "./node_modules/@tiptap/extension-heading/dist/index.js");



/**
 * Customized version of the Heading extension in order to fix compatibility
 * issue with the Hashtag extension. The default input rule of the Heading
 * extension would also match any paragraphs that have only one hashtag in them
 * and nothing else because that indicates the first level of heading.
 *
 * E.g.
 * - If you have the following paragraph: `<p>#apples</p>`
 * - This would be converted to a paragraph containing the hashtag node markup
 *   in the editor.
 * - If you come back to edit this content and try to enter a space right after
 *   the hashtag, the hashtag would disappear and the active text block would
 *   get the second heading level applied to it
 *
 * Since we do not allow the user to enter the first level of headings through
 * the editor, we can fix this by limiting the markdown shortcut to the second
 * level headings and above.
 */
/* harmony default export */ __webpack_exports__["default"] = (_tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
  addInputRules: function addInputRules() {
    var _this = this;
    return this.options.levels.map(function (level) {
      return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({
        find: new RegExp("^(#{2,".concat(level, "})\\s$")),
        type: _this.type,
        getAttributes: {
          level: level
        }
      });
    });
  }
}));

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/image/index.js":
/*!*****************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/image/index.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
/* harmony import */ var _tiptap_extension_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-image */ "./node_modules/@tiptap/extension-image/dist/index.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");
/* harmony import */ var src_decidim_i18n__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/decidim/i18n */ "./gems/decidim-module-core/app/packs/src/decidim/i18n.js");
/* harmony import */ var src_decidim_editor_utilities_file__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! src/decidim/editor/utilities/file */ "./gems/decidim-module-core/app/packs/src/decidim/editor/utilities/file.js");
/* harmony import */ var src_decidim_editor_extensions_image_node_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! src/decidim/editor/extensions/image/node_view */ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/image/node_view.js");
/* harmony import */ var src_decidim_editor_common_upload_dialog__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! src/decidim/editor/common/upload_dialog */ "./gems/decidim-module-core/app/packs/src/decidim/editor/common/upload_dialog.js");
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}







var createImageUploadDialog = function createImageUploadDialog(editor, _ref) {
  var uploadDialogSelector = _ref.uploadDialogSelector;
  var i18nUpload = (0,src_decidim_i18n__WEBPACK_IMPORTED_MODULE_1__.getDictionary)("editor.upload");
  return new src_decidim_editor_common_upload_dialog__WEBPACK_IMPORTED_MODULE_4__["default"](document.querySelector(uploadDialogSelector), {
    i18n: i18nUpload,
    onOpen: function onOpen() {
      return editor.commands.toggleDialog(true);
    },
    onClose: function onClose() {
      return editor.chain().toggleDialog(false).focus(null, {
        scrollIntoView: false
      }).run();
    }
  });
};
var uploadImage = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(image, uploadUrl) {
    var token, data, i18n;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          token = document.querySelector("meta[name='csrf-token']").getAttribute("content");
          data = new FormData();
          data.append("image", image);
          i18n = (0,src_decidim_i18n__WEBPACK_IMPORTED_MODULE_1__.getDictionary)("editor.extensions.image");
          return _context.abrupt("return", new Promise(function (resolve, reject) {
            fetch(uploadUrl, {
              method: "POST",
              mode: "cors",
              cache: "no-cache",
              headers: {
                "X-CSRF-Token": token
              },
              body: data
            }).then(function (response) {
              if (response.ok) {
                return response.json();
              }
              return new Promise(function (responseResolve) {
                return responseResolve({
                  message: i18n.uploadError
                });
              });
            }).then(function (json) {
              return resolve(_objectSpread({
                title: (0,src_decidim_editor_utilities_file__WEBPACK_IMPORTED_MODULE_2__.fileNameToTitle)(image.name)
              }, json));
            })["catch"](reject);
          }));
        case 5:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function uploadImage(_x, _x2) {
    return _ref2.apply(this, arguments);
  };
}();
var filterImages = function filterImages(files, contentTypes) {
  return Array.from(files).filter(function (file) {
    if (contentTypes instanceof RegExp) {
      return contentTypes.test(file.type);
    } else if (contentTypes instanceof Array) {
      return contentTypes.includes(file.type);
    }
    // string
    return contentTypes === file.type;
  });
};

/**
 * Handles the image uploads through ActiveStorage when they are dropped or
 * pasted to the editor.
 *
 * Paste and drop handling based on:
 * https://gist.github.com/slava-vishnyakov/16076dff1a77ddaca93c4bccd4ec4521
 */
/* harmony default export */ __webpack_exports__["default"] = (_tiptap_extension_image__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
  addOptions: function addOptions() {
    var _this$parent;
    return _objectSpread(_objectSpread({}, (_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.call(this)), {}, {
      contentTypes: /^image\/(jpe?g|png|svg|webp)$/i,
      uploadImagesPath: null,
      uploadDialogSelector: null
    });
  },
  addAttributes: function addAttributes() {
    var _this$parent2;
    return _objectSpread(_objectSpread({}, (_this$parent2 = this.parent) === null || _this$parent2 === void 0 ? void 0 : _this$parent2.call(this)), {}, {
      width: {
        "default": null
      }
    });
  },
  addCommands: function addCommands() {
    var _this$parent3,
      _this = this;
    var i18n = (0,src_decidim_i18n__WEBPACK_IMPORTED_MODULE_1__.getDictionary)("editor.extensions.image");
    var uploadDialog = createImageUploadDialog(this.editor, this.options);
    return _objectSpread(_objectSpread({}, (_this$parent3 = this.parent) === null || _this$parent3 === void 0 ? void 0 : _this$parent3.call(this)), {}, {
      imageDialog: function imageDialog() {
        return /*#__PURE__*/function () {
          var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref3) {
            var dispatch, _this$editor$getAttri, src, alt, width, dialogState;
            return _regeneratorRuntime().wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  dispatch = _ref3.dispatch;
                  if (!dispatch) {
                    _context3.next = 15;
                    break;
                  }
                  _this$editor$getAttri = _this.editor.getAttributes("image"), src = _this$editor$getAttri.src, alt = _this$editor$getAttri.alt, width = _this$editor$getAttri.width;
                  _this.editor.commands.toggleDialog(true);
                  _context3.next = 6;
                  return uploadDialog.toggle({
                    src: src,
                    alt: alt
                  }, {
                    inputLabel: i18n.altLabel,
                    uploadHandler: function () {
                      var _uploadHandler = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(file) {
                        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                          while (1) switch (_context2.prev = _context2.next) {
                            case 0:
                              return _context2.abrupt("return", uploadImage(file, _this.options.uploadImagesPath));
                            case 1:
                            case "end":
                              return _context2.stop();
                          }
                        }, _callee2);
                      }));
                      function uploadHandler(_x4) {
                        return _uploadHandler.apply(this, arguments);
                      }
                      return uploadHandler;
                    }()
                  });
                case 6:
                  dialogState = _context3.sent;
                  _this.editor.commands.toggleDialog(false);
                  if (!(dialogState !== "save")) {
                    _context3.next = 11;
                    break;
                  }
                  _this.editor.commands.focus(null, {
                    scrollIntoView: false
                  });
                  return _context3.abrupt("return", false);
                case 11:
                  if (uploadDialog.getValue("src") !== src) {
                    // Reset the width to original width in case the image changed.
                    width = null;
                  }
                  src = uploadDialog.getValue("src");
                  alt = uploadDialog.getValue("alt");
                  return _context3.abrupt("return", _this.editor.chain().setImage({
                    src: src,
                    alt: alt,
                    width: width
                  }).focus(null, {
                    scrollIntoView: false
                  }).run());
                case 15:
                  return _context3.abrupt("return", true);
                case 16:
                case "end":
                  return _context3.stop();
              }
            }, _callee3);
          }));
          return function (_x3) {
            return _ref4.apply(this, arguments);
          };
        }();
      }
    });
  },
  addNodeView: function addNodeView() {
    return (0,src_decidim_editor_extensions_image_node_view__WEBPACK_IMPORTED_MODULE_3__["default"])(this);
  },
  parseHTML: function parseHTML() {
    return [{
      tag: "div[data-image] img[src]:not([src^='data:'])"
    }];
  },
  renderHTML: function renderHTML(_ref5) {
    var HTMLAttributes = _ref5.HTMLAttributes;
    return ["div", {
      "class": "editor-content-image",
      "data-image": ""
    }, ["img", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_5__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)]];
  },
  addProseMirrorPlugins: function addProseMirrorPlugins() {
    var editor = this.editor;
    var _this$options = this.options,
      uploadImagesPath = _this$options.uploadImagesPath,
      contentTypes = _this$options.contentTypes;
    var handleUploadedImages = function handleUploadedImages(uploadedImages) {
      uploadedImages.forEach(function (imageData) {
        if (!imageData.url) {
          return;
        }
        editor.commands.setImage({
          src: imageData.url,
          alt: imageData.title
        });
      });
    };
    return [new prosemirror_state__WEBPACK_IMPORTED_MODULE_6__.Plugin({
      props: {
        handlePaste: function handlePaste(view, event) {
          var items = (event.clipboardData || event.originalEvent.clipboardData).items;
          var images = filterImages(items, contentTypes);
          if (images.length < 1) {
            return false;
          }
          Promise.all(images.map(function (item) {
            return uploadImage(item.getAsFile(), uploadImagesPath);
          })).then(function (uploadedImages) {
            handleUploadedImages(uploadedImages);
          });
          return true;
        },
        handleDoubleClick: function handleDoubleClick() {
          if (!editor.isActive("image")) {
            return false;
          }
          editor.chain().focus().imageDialog().run();
          return true;
        },
        handleDOMEvents: {
          drop: function drop(view, event) {
            var _event$dataTransfer;
            var position = view.posAtCoords({
              left: event.clientX,
              top: event.clientY
            });
            var files = event === null || event === void 0 || (_event$dataTransfer = event.dataTransfer) === null || _event$dataTransfer === void 0 ? void 0 : _event$dataTransfer.files;
            if (!files || files.length < 1) {
              return;
            }
            var images = filterImages(files, contentTypes);
            if (images.length < 1) {
              return;
            }
            event.preventDefault();

            // Make sure the image is dropped at the right place. Otherwise
            // the image would appear at the current text selection position
            // and always in the beginning of the content in case the editor
            // did not have focus when the image was dropped.
            editor.chain().focus().setTextSelection(position.pos).run();
            Promise.all(images.map(function (image) {
              return uploadImage(image, uploadImagesPath);
            })).then(function (uploadedImages) {
              handleUploadedImages(uploadedImages);
            });
          }
        }
      }
    })];
  }
}));

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/image/node_view.js":
/*!*********************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/image/node_view.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.js");
/* harmony import */ var src_decidim_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! src/decidim/i18n */ "./gems/decidim-module-core/app/packs/src/decidim/i18n.js");
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}


var createControl = function createControl(position, label) {
  var el = document.createElement("button");
  el.type = "button";
  el.ariaLabel = label;
  el.dataset.imageResizerControl = position;
  return el;
};
var createDimensionDisplay = function createDimensionDisplay() {
  var el = document.createElement("div");
  el.dataset.imageResizerDimensions = "";
  var width = document.createElement("span");
  width.dataset.imageResizerDimension = "width";
  width.dataset.imageResizerDimensionValue = "";
  var height = document.createElement("span");
  height.dataset.imageResizerDimension = "height";
  height.dataset.imageResizerDimensionValue = "";
  el.append(width);
  el.append("");
  el.append(height);
  return {
    wrapper: el,
    width: width,
    height: height
  };
};

/**
 * Wraps the editor element around the resizable element and implements the
 * resizer functionality.
 *
 * @param {Object} self The node extension to create the view for
 * @returns {Function} The custom node view callback to pass on to TipTap
 */
/* harmony default export */ __webpack_exports__["default"] = (function (self) {
  var i18nResize = (0,src_decidim_i18n__WEBPACK_IMPORTED_MODULE_0__.getDictionary)("editor.extensions.image.nodeView.resizer");
  var createResizeControl = function createResizeControl(position) {
    var label = i18nResize["control.resize"];
    var positionLabel = i18nResize["position.".concat(position.replace(/-(\w)/, function (da, ch) {
      return ch.toUpperCase();
    }))];
    return createControl(position, label.replace("%position%", positionLabel));
  };
  return function (_ref) {
    var editor = _ref.editor,
      node = _ref.node,
      getPos = _ref.getPos;
    var resizer = document.createElement("div");
    resizer.dataset.imageResizerWrapper = "";
    resizer.append(createResizeControl("top-left"));
    resizer.append(createResizeControl("top-right"));
    resizer.append(createResizeControl("bottom-left"));
    resizer.append(createResizeControl("bottom-right"));
    var dimensions = createDimensionDisplay();
    resizer.append(dimensions.wrapper);
    var contentDOM = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMSerializer.fromSchema(node.type.schema).serializeNode(node);
    resizer.append(contentDOM);
    var img = contentDOM.querySelector("img");
    var activeResizeControl = null,
      currentHeight = null,
      currentSrc = node.attrs.src,
      currentWidth = null,
      naturalHeight = img.naturalHeight,
      naturalWidth = img.naturalWidth,
      originalWidth = null,
      resizeStartPosition = null;

    // Used to reliably get the image width so that it is not reported as zero
    // in case the original image element has not finished loading yet.
    var tmpImg = document.createElement("img");
    var givenWidth = node.attrs.width;
    tmpImg.onload = function () {
      naturalWidth = tmpImg.naturalWidth;
      naturalHeight = tmpImg.naturalHeight;

      // Set currentWidth and currentHeight
      if (givenWidth === null) {
        currentWidth = naturalWidth;
        currentHeight = naturalHeight;
      } else {
        currentWidth = givenWidth;
        currentHeight = Math.round(naturalHeight * (currentWidth / naturalWidth));
      }

      // Force node update in order to set the initial dimensions
      [_objectSpread(_objectSpread({}, node.attrs), {}, {
        width: 1
      }), node.attrs].forEach(function (newAttrs) {
        // The `setTimeout` below is to push the node updates to the next JS
        // event loop so that we are not triggering a change in the element
        // before it is created as would happen e.g. during the Jest tests.
        setTimeout(function () {
          editor.view.dispatch(editor.view.state.tr.setNodeMarkup(getPos(), self.type, newAttrs));
        }, 0);
      });
    };
    tmpImg.src = img.src;
    var getEventPagePosition = function getEventPagePosition(ev, device) {
      if (device === "touch") {
        var originalEv = ev.originalEvent;
        var touches = ev.touches || ev.changedTouches || originalEv.touches || originalEv.changedTouches;
        if (!touches) {
          return {
            xPos: null,
            yPos: null
          };
        }
        var touch = touches[0];
        return {
          xPos: touch.pageX,
          yPos: touch.pageY
        };
      }
      return {
        xPos: ev.clientX,
        yPos: ev.clientY
      };
    };
    var handleMove = function handleMove(ev, device) {
      var _getEventPagePosition = getEventPagePosition(ev, device),
        xPos = _getEventPagePosition.xPos;
      var diff = resizeStartPosition - xPos;
      if (activeResizeControl.match(/-left$/)) {
        diff *= -1;
      }
      currentWidth = Math.round(originalWidth * (1 - diff / originalWidth));
      if (currentWidth < 100) {
        currentWidth = 100;
      } else if (currentWidth >= naturalWidth) {
        currentWidth = naturalWidth;
      }
      currentHeight = Math.round(naturalHeight * (currentWidth / naturalWidth));
      var width = currentWidth;
      if (width >= naturalWidth) {
        width = null;
      }
      editor.commands.updateAttributes("image", {
        width: width
      });
    };
    var handleMouseMove = function handleMouseMove(ev) {
      return handleMove(ev, "mouse");
    };
    var handleTouchMove = function handleTouchMove(ev) {
      return handleMove(ev, "touch");
    };
    var handleEnd = function handleEnd() {
      activeResizeControl = resizeStartPosition = null;
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("touchmove", handleTouchMove);
      document.removeEventListener("mouseup", handleEnd);
      document.removeEventListener("touchend", handleEnd);
    };
    resizer.querySelectorAll("[data-image-resizer-control]").forEach(function (ctrl) {
      var handleStart = function handleStart(ev, device) {
        // Only allow mouse events to start the resize on the primary button
        // click.
        if (device === "mouse" && ev.button !== 0) {
          return;
        }
        if (!editor.isEditable || activeResizeControl) {
          return;
        }
        document.addEventListener("mousemove", handleMouseMove);
        document.addEventListener("touchmove", handleTouchMove);
        document.addEventListener("mouseup", handleEnd);
        document.addEventListener("touchend", handleEnd);
        ev.preventDefault();
        activeResizeControl = ctrl.dataset.imageResizerControl;
        originalWidth = editor.getAttributes("image").width || naturalWidth;
        resizeStartPosition = getEventPagePosition(ev, device).xPos;
      };
      var handleMouseStart = function handleMouseStart(ev) {
        return handleStart(ev, "mouse");
      };
      var handleTouchStart = function handleTouchStart(ev) {
        return handleStart(ev, "touch");
      };
      ctrl.addEventListener("mousedown", handleMouseStart);
      ctrl.addEventListener("touchstart", handleTouchStart);
    });
    var dom = document.createElement("div");
    dom.dataset.imageResizer = "";
    dom.append(resizer);
    return {
      dom: dom,
      contentDOM: contentDOM,
      update: function update(updatedNode) {
        if (updatedNode.type !== self.type) {
          return false;
        }
        var _updatedNode$attrs = updatedNode.attrs,
          alt = _updatedNode$attrs.alt,
          src = _updatedNode$attrs.src,
          title = _updatedNode$attrs.title,
          width = _updatedNode$attrs.width;

        // We set the value through an attribute change here because otherwise
        // we would trigger a mutation in the DOM which causes the update method
        // to be called recursively.
        dimensions.width.dataset.imageResizerDimensionValue = currentWidth;
        dimensions.height.dataset.imageResizerDimensionValue = currentHeight;
        img.alt = alt;
        if (currentSrc !== src) {
          img.src = src;
          currentSrc = src;
        }
        if (title) {
          img.title = title;
        } else {
          img.removeAttribute("title");
        }
        if (width) {
          img.width = width;
        } else {
          img.removeAttribute("width");
        }
        return true;
      }
    };
  };
});

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/indent/index.js":
/*!******************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/indent/index.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");


// The node types for which indentation is allowed
var allowedNodeTypes = ["heading", "paragraph"];

/**
 * Helper method to check whether one of the allowed type nodes is currently
 * active where the indentation can be performed on.
 *
 * @param {Object} editor The editor instance.
 * @returns {Boolean} A boolean indicating if an allowed type node is active
 */
var allowedNodeActive = function allowedNodeActive(editor) {
  return allowedNodeTypes.some(function (type) {
    return editor.isActive(type);
  });
};

/**
 * Finds the closest allowed type node from the given position. Traversese the
 * document depth upwards to search through all the node parents.
 *
 * @param {Object} position The position where to look for
 * @returns {Node|null} The allowed node or null if no allowed node is found
 */
var closestAllowedNode = function closestAllowedNode(position) {
  var depth = position.depth;
  var _loop = function _loop() {
      var node = position.node(depth);
      if (allowedNodeTypes.some(function (type) {
        return node.type.name === type;
      })) {
        return {
          v: node
        };
      }
      depth -= 1;
    },
    _ret;
  while (depth > 0) {
    _ret = _loop();
    if (_ret) return _ret.v;
  }
  return null;
};

/**
 * Indent extension for the Tiptap editor.
 *
 * Originally based on the following MIT licensed code:
 * https://github.com/ueberdosis/tiptap/issues/1036#issuecomment-1000983233
 * https://github.com/evanfuture/tiptaptop-extension-indent
 *
 * License as specified at:
 * https://github.com/evanfuture/tiptaptop-extension-indent
 *
 * The code has been simplified and modified to fit better the needs of Decidim.
 *
 * Authors/Credits: Jeet Mandaliya (@sereneinserenade),
 *   Evan Payne (@evanfuture), @danline, YukiYama (@yuyuyukie)
 */
/* harmony default export */ __webpack_exports__["default"] = (_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({
  name: "indent",
  addOptions: function addOptions() {
    return {
      minIndentLevel: 0,
      maxIndentLevel: 10,
      HTMLAttributes: {}
    };
  },
  addGlobalAttributes: function addGlobalAttributes() {
    var defaultIndentLevel = 0;
    return [{
      types: allowedNodeTypes,
      attributes: {
        indent: {
          "default": defaultIndentLevel,
          renderHTML: function renderHTML(attributes) {
            if (attributes.indent < 1) {
              return {};
            }
            return {
              "class": "editor-indent-".concat(attributes.indent)
            };
          },
          parseHTML: function parseHTML(element) {
            // The "ql" prefix here is to maintain backwards compatibility
            // with the old editor. The new prefix is editor-indent-X where X
            // is the current indentation level.
            var regexp = /^(editor|ql)-indent-([0-9]+)/;
            var indentClass = Array.from(element.classList).find(function (cls) {
              return regexp.test(cls);
            });
            if (!indentClass) {
              return defaultIndentLevel;
            }
            return parseInt(indentClass.match(regexp)[2], 10);
          }
        }
      }
    }];
  },
  addCommands: function addCommands() {
    var _this = this;
    var updateIndent = function updateIndent(modifier, _ref) {
      var editor = _ref.editor,
        state = _ref.state,
        dispatch = _ref.dispatch,
        commands = _ref.commands;
      if (!allowedNodeActive(editor)) {
        return false;
      }
      var node = closestAllowedNode(state.selection.$head);
      if (node === null) {
        return false;
      }
      var indent = node.attrs.indent + modifier;
      if (indent < _this.options.minIndentLevel || indent > _this.options.maxIndentLevel) {
        return false;
      }
      if (dispatch) {
        return commands.updateAttributes(node.type.name, {
          indent: indent
        });
      }
      return true;
    };
    return {
      indent: function indent() {
        return function (_ref2) {
          var editor = _ref2.editor,
            state = _ref2.state,
            commands = _ref2.commands,
            dispatch = _ref2.dispatch;
          if (editor.isActive("listItem")) {
            if (dispatch) {
              return commands.sinkListItem("listItem");
            }
            return true;
          }
          return updateIndent(1, {
            editor: editor,
            state: state,
            dispatch: dispatch,
            commands: commands
          });
        };
      },
      outdent: function outdent() {
        return function (_ref3) {
          var editor = _ref3.editor,
            state = _ref3.state,
            commands = _ref3.commands,
            dispatch = _ref3.dispatch;
          if (editor.isActive("listItem")) {
            // When the list item depth is at 3 it means that the list is at the
            // top level because of the following structure:
            // <ul><!-- depth: 1 -->
            //   <li><!-- depth: 2 -->
            //     <p>Content</p><!-- depth: 3 -->
            //   </li>
            // </ul>
            //
            // We do not allow outdent at the top level of the list.
            if (state.selection.$head.depth === 3) {
              return false;
            }
            if (dispatch) {
              return commands.liftListItem("listItem");
            }
            return true;
          }
          return updateIndent(-1, {
            editor: editor,
            state: state,
            dispatch: dispatch,
            commands: commands
          });
        };
      }
    };
  },
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this2 = this;
    var indent = function indent() {
      if (!_this2.editor.can().indent()) {
        return false;
      }
      return _this2.editor.commands.indent();
    };
    var outdent = function outdent() {
      if (!_this2.editor.can().outdent()) {
        return false;
      }
      return _this2.editor.commands.outdent();
    };
    return {
      Tab: indent,
      "Shift-Tab": outdent,
      Backspace: function Backspace() {
        if (_this2.editor.isActive("listItem")) {
          return false;
        }

        // With the backspace we only allow outdent when the cursor is at the
        // beginning of the line.
        if (_this2.editor.state.selection.$head.parentOffset > 0) {
          return false;
        }
        return outdent();
      },
      "Mod-]": indent,
      "Mod-[": outdent
    };
  }
}));

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/link/bubble_menu.js":
/*!**********************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/link/bubble_menu.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");
/* harmony import */ var src_decidim_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! src/decidim/i18n */ "./gems/decidim-module-core/app/packs/src/decidim/i18n.js");
/* harmony import */ var src_decidim_editor_common_bubble_menu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/decidim/editor/common/bubble_menu */ "./gems/decidim-module-core/app/packs/src/decidim/editor/common/bubble_menu.js");
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}
function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
    return !!t;
  })();
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}



var LinkBubbleMenu = /*#__PURE__*/function (_BubbleMenu) {
  _inherits(LinkBubbleMenu, _BubbleMenu);
  function LinkBubbleMenu() {
    _classCallCheck(this, LinkBubbleMenu);
    return _callSuper(this, LinkBubbleMenu, arguments);
  }
  _createClass(LinkBubbleMenu, [{
    key: "shouldDisplay",
    value: function shouldDisplay() {
      return this.editor.isActive("link");
    }
  }, {
    key: "display",
    value: function display() {
      var _this$editor$getAttri = this.editor.getAttributes("link"),
        href = _this$editor$getAttri.href;
      this.element.querySelector("[data-linkbubble-value]").textContent = href;
    }
  }, {
    key: "handleAction",
    value: function handleAction(action) {
      if (action === "remove") {
        this.editor.chain().focus(null, {
          scrollIntoView: false
        }).unsetLink().run();
      } else {
        this.editor.commands.linkDialog();
      }
    }
  }]);
  return LinkBubbleMenu;
}(src_decidim_editor_common_bubble_menu__WEBPACK_IMPORTED_MODULE_1__["default"]);
var createElement = function createElement() {
  var i18n = (0,src_decidim_i18n__WEBPACK_IMPORTED_MODULE_0__.getDictionary)("editor.extensions.link.bubbleMenu");
  var element = document.createElement("div");
  element.dataset.linkbubble = "";
  element.innerHTML = "\n    <span data-linkbubble-content>\n      ".concat(i18n.url, ":\n      <span data-linkbubble-value></span>\n    </span>\n    <span data-linkbubble-actions>\n      <button type=\"button\" data-action=\"edit\">").concat(i18n.edit, "</button>\n      <button type=\"button\" data-action=\"remove\">").concat(i18n.remove, "</button>\n    </span>\n  ");
  return element;
};
/* harmony default export */ __webpack_exports__["default"] = (function (editor) {
  return new LinkBubbleMenu({
    editor: editor,
    element: createElement(),
    pluginKey: new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey("LinkBubble")
  });
});

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/link/index.js":
/*!****************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/link/index.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tiptap_extension_link__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-link */ "./node_modules/@tiptap/extension-link/dist/index.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");
/* harmony import */ var src_decidim_i18n__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/decidim/i18n */ "./gems/decidim-module-core/app/packs/src/decidim/i18n.js");
/* harmony import */ var src_decidim_editor_common_input_dialog__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! src/decidim/editor/common/input_dialog */ "./gems/decidim-module-core/app/packs/src/decidim/editor/common/input_dialog.js");
/* harmony import */ var src_decidim_editor_extensions_link_bubble_menu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! src/decidim/editor/extensions/link/bubble_menu */ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/link/bubble_menu.js");
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}





/* harmony default export */ __webpack_exports__["default"] = (_tiptap_extension_link__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
  addStorage: function addStorage() {
    return {
      bubbleMenu: null
    };
  },
  onCreate: function onCreate() {
    var _this$parent;
    (_this$parent = this.parent) === null || _this$parent === void 0 || _this$parent.call(this);
    this.storage.bubbleMenu = (0,src_decidim_editor_extensions_link_bubble_menu__WEBPACK_IMPORTED_MODULE_3__["default"])(this.editor);
  },
  onDestroy: function onDestroy() {
    var _this$parent2;
    (_this$parent2 = this.parent) === null || _this$parent2 === void 0 || _this$parent2.call(this);
    this.storage.bubbleMenu.destroy();
    this.storage.bubbleMenu = null;
  },
  addOptions: function addOptions() {
    var _this$parent3;
    return _objectSpread(_objectSpread({}, (_this$parent3 = this.parent) === null || _this$parent3 === void 0 ? void 0 : _this$parent3.call(this)), {}, {
      allowTargetControl: false,
      HTMLAttributes: {
        target: "_blank",
        "class": null
      }
    });
  },
  addCommands: function addCommands() {
    var _this$parent4,
      _this = this;
    var i18n = (0,src_decidim_i18n__WEBPACK_IMPORTED_MODULE_1__.getDictionary)("editor.extensions.link");
    return _objectSpread(_objectSpread({}, (_this$parent4 = this.parent) === null || _this$parent4 === void 0 ? void 0 : _this$parent4.call(this)), {}, {
      toggleLinkBubble: function toggleLinkBubble() {
        return function (_ref) {
          var dispatch = _ref.dispatch;
          if (dispatch) {
            if (_this.editor.isActive("link")) {
              _this.storage.bubbleMenu.show();
              return true;
            }
            _this.storage.bubbleMenu.hide();
            return false;
          }
          return _this.editor.isActive("link");
        };
      },
      linkDialog: function linkDialog() {
        return /*#__PURE__*/function () {
          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref2) {
            var dispatch, commands, allowTargetControl, _this$editor$getAttri, href, target, inputs, linkDialog, dialogState;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  dispatch = _ref2.dispatch, commands = _ref2.commands;
                  if (!dispatch) {
                    _context.next = 21;
                    break;
                  }
                  // If the cursor is within the link but the link is not selected, the
                  // link would not be correctly updated. Also if only a part of the
                  // link is selected, the link would be split to separate links, only
                  // the current selection getting the updated link URL.
                  commands.extendMarkRange("link");
                  _this.storage.bubbleMenu.hide();
                  allowTargetControl = _this.options.allowTargetControl;
                  _this$editor$getAttri = _this.editor.getAttributes("link"), href = _this$editor$getAttri.href, target = _this$editor$getAttri.target;
                  inputs = {
                    href: {
                      type: "text",
                      label: i18n.hrefLabel
                    }
                  };
                  if (allowTargetControl) {
                    inputs.target = {
                      type: "select",
                      label: i18n.targetLabel,
                      options: [{
                        value: "",
                        label: i18n["targets.default"]
                      }, {
                        value: "_blank",
                        label: i18n["targets.blank"]
                      }]
                    };
                  }
                  linkDialog = new src_decidim_editor_common_input_dialog__WEBPACK_IMPORTED_MODULE_2__["default"](_this.editor, {
                    inputs: inputs
                  });
                  _context.next = 11;
                  return linkDialog.toggle({
                    href: href,
                    target: target
                  });
                case 11:
                  dialogState = _context.sent;
                  href = linkDialog.getValue("href");
                  target = linkDialog.getValue("target");
                  if (!allowTargetControl) {
                    target = "_blank";
                  } else if (!target || target.length < 1) {
                    target = null;
                  }
                  if (!(dialogState !== "save")) {
                    _context.next = 18;
                    break;
                  }
                  _this.editor.chain().focus(null, {
                    scrollIntoView: false
                  }).toggleLinkBubble().run();
                  return _context.abrupt("return", false);
                case 18:
                  if (!(!href || href.trim().length < 1)) {
                    _context.next = 20;
                    break;
                  }
                  return _context.abrupt("return", _this.editor.chain().focus(null, {
                    scrollIntoView: false
                  }).unsetLink().run());
                case 20:
                  return _context.abrupt("return", _this.editor.chain().focus(null, {
                    scrollIntoView: false
                  }).setLink({
                    href: href,
                    target: target
                  }).toggleLinkBubble().run());
                case 21:
                  return _context.abrupt("return", true);
                case 22:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          return function (_x) {
            return _ref3.apply(this, arguments);
          };
        }();
      }
    });
  },
  addProseMirrorPlugins: function addProseMirrorPlugins() {
    var _this$parent5;
    var editor = this.editor;
    return [].concat(_toConsumableArray(((_this$parent5 = this.parent) === null || _this$parent5 === void 0 ? void 0 : _this$parent5.call(this)) || {}), [new prosemirror_state__WEBPACK_IMPORTED_MODULE_4__.Plugin({
      props: {
        handleDoubleClick: function handleDoubleClick() {
          if (!editor.isActive("link")) {
            return false;
          }
          editor.chain().focus().linkDialog().run();
          return true;
        }
      }
    })]);
  }
}));

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/mention/index.js":
/*!*******************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/mention/index.js ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tiptap_extension_mention__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-mention */ "./node_modules/@tiptap/extension-mention/dist/index.js");
/* harmony import */ var src_decidim_editor_common_suggestion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/decidim/editor/common/suggestion */ "./gems/decidim-module-core/app/packs/src/decidim/editor/common/suggestion.js");
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}


var searchUsers = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(queryText) {
    var query;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          query = "{\n    users(filter: { wildcard: \"".concat(queryText, "\" }) {\n      nickname,\n      name,\n      avatarUrl,\n      __typename,\n      ...on UserGroup { membersCount }\n    }\n  }");
          return _context.abrupt("return", fetch("/api", {
            method: "POST",
            cache: "no-cache",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              query: query
            })
          }).then(function (response) {
            if (response.ok) {
              return response.json();
            }
            throw new Error("Could not retrieve data");
          }).then(function (json) {
            return json.data.users || [];
          }));
        case 2:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function searchUsers(_x) {
    return _ref.apply(this, arguments);
  };
}();
/* harmony default export */ __webpack_exports__["default"] = (_tiptap_extension_mention__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
  addOptions: function addOptions() {
    var _this$parent;
    var parentOptions = (_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.call(this);
    return _objectSpread(_objectSpread({}, parentOptions), {}, {
      renderLabel: function renderLabel(_ref2) {
        var _node$attrs$label;
        var node = _ref2.node;
        // The labels are formed based on the nicknames returned by the API
        // which already contain the suggestion character, so there is no need
        // to display it twice.
        return "".concat((_node$attrs$label = node.attrs.label) !== null && _node$attrs$label !== void 0 ? _node$attrs$label : node.attrs.id);
      },
      suggestion: _objectSpread(_objectSpread({}, parentOptions === null || parentOptions === void 0 ? void 0 : parentOptions.suggestion), {}, {
        allowSpaces: true,
        items: function () {
          var _items = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref3) {
            var query, data, sorted;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  query = _ref3.query;
                  if (!(query.length < 2)) {
                    _context2.next = 3;
                    break;
                  }
                  return _context2.abrupt("return", []);
                case 3:
                  _context2.next = 5;
                  return searchUsers(query);
                case 5:
                  data = _context2.sent;
                  sorted = data.sort(function (user) {
                    return user.nickname.slice(1);
                  });
                  return _context2.abrupt("return", sorted.slice(0, 5));
                case 8:
                case "end":
                  return _context2.stop();
              }
            }, _callee2);
          }));
          function items(_x2) {
            return _items.apply(this, arguments);
          }
          return items;
        }(),
        render: (0,src_decidim_editor_common_suggestion__WEBPACK_IMPORTED_MODULE_1__.createSuggestionRenderer)(this, {
          itemConverter: function itemConverter(user) {
            return {
              id: user.nickname,
              label: "".concat(user.nickname, " (").concat(user.name, ")")
            };
          }
        })
      })
    });
  },
  addNodeView: function addNodeView() {
    return (0,src_decidim_editor_common_suggestion__WEBPACK_IMPORTED_MODULE_1__.createNodeView)(this);
  }
}));

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/ordered_list/index.js":
/*!************************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/ordered_list/index.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
/* harmony import */ var _tiptap_extension_ordered_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-ordered-list */ "./node_modules/@tiptap/extension-ordered-list/dist/index.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");
/* harmony import */ var src_decidim_editor_utilities_paste_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/decidim/editor/utilities/paste_transform */ "./gems/decidim-module-core/app/packs/src/decidim/editor/utilities/paste_transform.js");
var _excluded = ["start"];
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}




var allowedListTypes = ["a", "A", "i", "I"];
var covertListStyleToType = function covertListStyleToType(style) {
  switch (style) {
    case "lower-alpha":
    case "lower-latin":
      return "a";
    case "upper-alpha":
    case "upper-latin":
      return "A";
    case "lower-roman":
      return "i";
    case "upper-roman":
      return "I";
    default:
      return "1";
  }
};

/**
 * This extension is customized in order to support the different styles of
 * ordered lists, such as the following.
 *
 * type "a":
 *   a) List item 1
 *   b) List item 2
 *   c) List item 3
 *
 * type "A":
 *   A) List item 1
 *   B) List item 2
 *   C) List item 3
 *
 * type "i":
 *   i) List item 1
 *   ii) List item 2
 *   iii) List item 3
 *
 * type "I":
 *   I) List item 1
 *   II) List item 2
 *   III) List item 3
 *
 * See: https://github.com/ueberdosis/tiptap/issues/3726
 */
/* harmony default export */ __webpack_exports__["default"] = (_tiptap_extension_ordered_list__WEBPACK_IMPORTED_MODULE_0__["default"].extend({
  addAttributes: function addAttributes() {
    var _this$parent;
    return _objectSpread(_objectSpread({}, (_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.call(this)), {}, {
      type: {
        "default": null,
        parseHTML: function parseHTML(element) {
          var type = element.getAttribute("type");
          if (allowedListTypes.includes(type)) {
            return type;
          }

          // Google Docs
          var listItem = element.querySelector("li");
          if (listItem) {
            type = covertListStyleToType(listItem.style.listStyleType);
            if (allowedListTypes.includes(type)) {
              return type;
            }
          }

          // Office 365
          type = covertListStyleToType(element.style.listStyleType);
          if (allowedListTypes.includes(type)) {
            return type;
          }
          return null;
        }
      }
    });
  },
  /**
   * Overridden render method to add the `data-type` attribute for the typed
   * ordered lists as a workaround to style these lists properly. The following
   * issue with the CSS attribute selectors for the `type` attribute prevents
   * styling them properly otherwise: https://stackoverflow.com/q/53099708.
   *
   * The issue cannot be solved without this until the case sensitivity selector
   * is implemented by browsers and widely available:
   * https://caniuse.com/mdn-css_selectors_attribute_case_sensitive_modifier
   *
   * This has been already agreed by the CSS working group as per:
   * https://github.com/w3c/csswg-drafts/commit/de57526
   *
   * For further details, see:
   * https://github.com/tailwindlabs/tailwindcss-typography/issues/296
   *
   * @param {Object} attributes The attributes object containing the
   *   `HTMLAttributes` key for the attributes to be rendered
   * @returns {Array} The node definition array as defined by TipTap
   */
  renderHTML: function renderHTML(_ref) {
    var HTMLAttributes = _ref.HTMLAttributes;
    var start = HTMLAttributes.start,
      attributesWithoutStart = _objectWithoutProperties(HTMLAttributes, _excluded);
    var attrs = null;
    if (start === 1) {
      attrs = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes)(this.options.HTMLAttributes, attributesWithoutStart);
    } else {
      attrs = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes);
    }
    if (attrs.type) {
      var _attrs, _dataType, _attrs$_dataType;
      (_attrs$_dataType = (_attrs = attrs)[_dataType = "data-type"]) !== null && _attrs$_dataType !== void 0 ? _attrs$_dataType : _attrs[_dataType] = attrs.type;
    }
    return ["ol", attrs, 0];
  },
  addCommands: function addCommands() {
    var _this$parent2,
      _this = this;
    return _objectSpread(_objectSpread({}, (_this$parent2 = this.parent) === null || _this$parent2 === void 0 ? void 0 : _this$parent2.call(this)), {}, {
      setOrderedListType: function setOrderedListType(type) {
        return function (_ref2) {
          var commands = _ref2.commands,
            dispatch = _ref2.dispatch;
          var listActive = _this.editor.isActive("orderedList");
          if (dispatch && listActive) {
            return commands.updateAttributes("orderedList", {
              type: type
            });
          }
          return listActive;
        };
      }
    });
  },
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this2 = this,
      _this$parent3;
    var currentType = function currentType() {
      return _this2.editor.getAttributes("orderedList").type;
    };
    var determineType = function determineType(type, direction) {
      var idx = allowedListTypes.indexOf(type) + direction;
      if (idx === -2) {
        idx = allowedListTypes.length - 1;
      } else if (idx < 0 || idx >= allowedListTypes.length) {
        return null;
      }
      return allowedListTypes[idx];
    };
    var listTypeChange = function listTypeChange(direction) {
      if (!_this2.editor.isActive("orderedList")) {
        return false;
      }
      var type = determineType(currentType(), direction);
      if (!_this2.editor.can().setOrderedListType(type)) {
        return false;
      }
      return _this2.editor.commands.setOrderedListType(type);
    };
    return _objectSpread(_objectSpread({}, (_this$parent3 = this.parent) === null || _this$parent3 === void 0 ? void 0 : _this$parent3.call(this)), {}, {
      "Alt-Shift-ArrowUp": function AltShiftArrowUp() {
        return listTypeChange(-1);
      },
      "Alt-Shift-ArrowDown": function AltShiftArrowDown() {
        return listTypeChange(1);
      }
    });
  },
  /**
   * Adds a plugin that modifies the pasted HTML before it is passed to the
   * editor to fix some problems in the pasted content structure from different
   * online and desktop editors.
   *
   * See: https://github.com/ueberdosis/tiptap/issues/3751
   *
   * @returns {Array} The ProseMirror plugins provided by this extension
   */
  addProseMirrorPlugins: function addProseMirrorPlugins() {
    return [new prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.Plugin({
      props: {
        transformPastedHTML: function transformPastedHTML(html) {
          return (0,src_decidim_editor_utilities_paste_transform__WEBPACK_IMPORTED_MODULE_1__["default"])(html);
        }
      }
    })];
  }
}));

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/video_embed/index.js":
/*!***********************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/video_embed/index.js ***!
  \***********************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");
/* harmony import */ var src_decidim_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! src/decidim/i18n */ "./gems/decidim-module-core/app/packs/src/decidim/i18n.js");
/* harmony import */ var src_decidim_editor_common_input_dialog__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/decidim/editor/common/input_dialog */ "./gems/decidim-module-core/app/packs/src/decidim/editor/common/input_dialog.js");
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _regeneratorRuntime() {
  "use strict";

  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
  _regeneratorRuntime = function _regeneratorRuntime() {
    return e;
  };
  var t,
    e = {},
    r = Object.prototype,
    n = r.hasOwnProperty,
    o = Object.defineProperty || function (t, e, r) {
      t[e] = r.value;
    },
    i = "function" == typeof Symbol ? Symbol : {},
    a = i.iterator || "@@iterator",
    c = i.asyncIterator || "@@asyncIterator",
    u = i.toStringTag || "@@toStringTag";
  function define(t, e, r) {
    return Object.defineProperty(t, e, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), t[e];
  }
  try {
    define({}, "");
  } catch (t) {
    define = function define(t, e, r) {
      return t[e] = r;
    };
  }
  function wrap(t, e, r, n) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype),
      c = new Context(n || []);
    return o(a, "_invoke", {
      value: makeInvokeMethod(t, r, c)
    }), a;
  }
  function tryCatch(t, e, r) {
    try {
      return {
        type: "normal",
        arg: t.call(e, r)
      };
    } catch (t) {
      return {
        type: "throw",
        arg: t
      };
    }
  }
  e.wrap = wrap;
  var h = "suspendedStart",
    l = "suspendedYield",
    f = "executing",
    s = "completed",
    y = {};
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}
  var p = {};
  define(p, a, function () {
    return this;
  });
  var d = Object.getPrototypeOf,
    v = d && d(d(values([])));
  v && v !== r && n.call(v, a) && (p = v);
  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
  function defineIteratorMethods(t) {
    ["next", "throw", "return"].forEach(function (e) {
      define(t, e, function (t) {
        return this._invoke(e, t);
      });
    });
  }
  function AsyncIterator(t, e) {
    function invoke(r, o, i, a) {
      var c = tryCatch(t[r], t, o);
      if ("throw" !== c.type) {
        var u = c.arg,
          h = u.value;
        return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
          invoke("next", t, i, a);
        }, function (t) {
          invoke("throw", t, i, a);
        }) : e.resolve(h).then(function (t) {
          u.value = t, i(u);
        }, function (t) {
          return invoke("throw", t, i, a);
        });
      }
      a(c.arg);
    }
    var r;
    o(this, "_invoke", {
      value: function value(t, n) {
        function callInvokeWithMethodAndArg() {
          return new e(function (e, r) {
            invoke(t, n, e, r);
          });
        }
        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      }
    });
  }
  function makeInvokeMethod(e, r, n) {
    var o = h;
    return function (i, a) {
      if (o === f) throw new Error("Generator is already running");
      if (o === s) {
        if ("throw" === i) throw a;
        return {
          value: t,
          done: !0
        };
      }
      for (n.method = i, n.arg = a;;) {
        var c = n.delegate;
        if (c) {
          var u = maybeInvokeDelegate(c, n);
          if (u) {
            if (u === y) continue;
            return u;
          }
        }
        if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
          if (o === h) throw o = s, n.arg;
          n.dispatchException(n.arg);
        } else "return" === n.method && n.abrupt("return", n.arg);
        o = f;
        var p = tryCatch(e, r, n);
        if ("normal" === p.type) {
          if (o = n.done ? s : l, p.arg === y) continue;
          return {
            value: p.arg,
            done: n.done
          };
        }
        "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
      }
    };
  }
  function maybeInvokeDelegate(e, r) {
    var n = r.method,
      o = e.iterator[n];
    if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
    var i = tryCatch(o, e.iterator, r.arg);
    if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
    var a = i.arg;
    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
  }
  function pushTryEntry(t) {
    var e = {
      tryLoc: t[0]
    };
    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
  }
  function resetTryEntry(t) {
    var e = t.completion || {};
    e.type = "normal", delete e.arg, t.completion = e;
  }
  function Context(t) {
    this.tryEntries = [{
      tryLoc: "root"
    }], t.forEach(pushTryEntry, this), this.reset(!0);
  }
  function values(e) {
    if (e || "" === e) {
      var r = e[a];
      if (r) return r.call(e);
      if ("function" == typeof e.next) return e;
      if (!isNaN(e.length)) {
        var o = -1,
          i = function next() {
            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;
            return next.value = t, next.done = !0, next;
          };
        return i.next = i;
      }
    }
    throw new TypeError(_typeof(e) + " is not iterable");
  }
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
    value: GeneratorFunctionPrototype,
    configurable: !0
  }), o(GeneratorFunctionPrototype, "constructor", {
    value: GeneratorFunction,
    configurable: !0
  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
    var e = "function" == typeof t && t.constructor;
    return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
  }, e.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
  }, e.awrap = function (t) {
    return {
      __await: t
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
    return this;
  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(wrap(t, r, n, o), i);
    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    });
  }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
    return this;
  }), define(g, "toString", function () {
    return "[object Generator]";
  }), e.keys = function (t) {
    var e = Object(t),
      r = [];
    for (var n in e) r.push(n);
    return r.reverse(), function next() {
      for (; r.length;) {
        var t = r.pop();
        if (t in e) return next.value = t, next.done = !1, next;
      }
      return next.done = !0, next;
    };
  }, e.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(e) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
    },
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0].completion;
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(e) {
      if (this.done) throw e;
      var r = this;
      function handle(n, o) {
        return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
      }
      for (var o = this.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i.completion;
        if ("root" === i.tryLoc) return handle("end");
        if (i.tryLoc <= this.prev) {
          var c = n.call(i, "catchLoc"),
            u = n.call(i, "finallyLoc");
          if (c && u) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          } else if (c) {
            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);
          } else {
            if (!u) throw new Error("try statement without catch or finally");
            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(t, e) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var o = this.tryEntries[r];
        if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
          var i = o;
          break;
        }
      }
      i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
      var a = i ? i.completion : {};
      return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
    },
    complete: function complete(t, e) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
    },
    finish: function finish(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
      }
    },
    "catch": function _catch(t) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var r = this.tryEntries[e];
        if (r.tryLoc === t) {
          var n = r.completion;
          if ("throw" === n.type) {
            var o = n.arg;
            resetTryEntry(r);
          }
          return o;
        }
      }
      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(e, r, n) {
      return this.delegate = {
        iterator: values(e),
        resultName: r,
        nextLoc: n
      }, "next" === this.method && (this.arg = t), y;
    }
  }, e;
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}




var YOUTUBE_REGEX = /^(https?:\/\/)?(www\.|music\.)?(youtube\.com|youtu\.be)(.+)?$/;
var YOUTUBE_REGEX_GLOBAL = /^(https?:\/\/)?(www\.|music\.)?(youtube\.com|youtu\.be)(.+)?$/g;
var VIMEO_REGEX = /^(https?:\/\/)?(www\.|player\.)?(vimeo\.com)(.+)?$/;
var VIMEO_REGEX_GLOBAL = /^(https?:\/\/)?(www\.|player\.)?(vimeo\.com)(.+)?$/g;
var isValidYoutubeUrl = function isValidYoutubeUrl(url) {
  return url.match(YOUTUBE_REGEX);
};
var isValidVimeoUrl = function isValidVimeoUrl(url) {
  return url.match(VIMEO_REGEX);
};
var getEmbedUrlFromYoutubeUrl = function getEmbedUrlFromYoutubeUrl(options) {
  var embedUrl = "https://www.youtube-nocookie.com/embed/";
  var url = options.url;

  // if is already an embed url, return it
  if (url.includes("/embed/")) {
    return url;
  }

  // if is a youtu.be url, get the id after the /
  if (url.includes("youtu.be")) {
    var id = url.split("/").pop();
    if (!id) {
      return null;
    }
    return "".concat(embedUrl).concat(id);
  }
  var videoIdRegex = /v=([-\w]+)/gm;
  var matches = videoIdRegex.exec(url);
  if (!matches || !matches[1]) {
    return null;
  }
  var outputUrl = "".concat(embedUrl).concat(matches[1]);
  var params = {
    ccLoadPolicy: 1,
    modestbranding: 1
  };
  var urlParams = {};
  Object.keys(params).forEach(function (key) {
    var urlKey = key.replace(/[A-Z]/g, function (_char) {
      return "_".concat(_char.toLowerCase());
    });
    urlParams[urlKey] = params[key];
  });
  return "".concat(outputUrl, "?").concat(new URLSearchParams(urlParams));
};
var getEmbedUrlFromVimeoUrl = function getEmbedUrlFromVimeoUrl(options) {
  var embedUrl = "https://player.vimeo.com/video/";
  var url = options.url;
  var cleanUrl = url.split("?").shift();
  var id = cleanUrl.split("/").pop();
  return "".concat(embedUrl).concat(id);
};
var getEmbedUrlFromVideoUrl = function getEmbedUrlFromVideoUrl(options) {
  var url = options.url;
  if (isValidYoutubeUrl(url)) {
    return getEmbedUrlFromYoutubeUrl(options);
  } else if (isValidVimeoUrl(url)) {
    return getEmbedUrlFromVimeoUrl(options);
  }
  return url;
};

/**
 * Video embed extension for the Tiptap editor.
 *
 * Based on the original `@tiptap/extension-youtube` extension with support to
 * other embedding services than only YouTube.
 */
/* harmony default export */ __webpack_exports__["default"] = (_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Node.create({
  name: "videoEmbed",
  draggable: true,
  addOptions: function addOptions() {
    return {
      height: null,
      width: null,
      inline: false
    };
  },
  inline: function inline() {
    return this.options.inline;
  },
  group: function group() {
    if (this.options.inline) {
      return "inline";
    }
    return "block";
  },
  addAttributes: function addAttributes() {
    return {
      src: {
        "default": null,
        parseHTML: function parseHTML(element) {
          var _element$parentElemen, _wrapper$dataset;
          var wrapper = element === null || element === void 0 || (_element$parentElemen = element.parentElement) === null || _element$parentElemen === void 0 ? void 0 : _element$parentElemen.parentElement;
          var embedUrl = wrapper === null || wrapper === void 0 || (_wrapper$dataset = wrapper.dataset) === null || _wrapper$dataset === void 0 ? void 0 : _wrapper$dataset.videoEmbed;
          if (embedUrl && embedUrl.length > 0) {
            return embedUrl;
          }
          return element.src;
        }
      },
      title: {
        "default": null
      },
      width: {
        "default": this.options.width
      },
      height: {
        "default": this.options.height
      },
      frameborder: {
        "default": 0
      },
      allowfullscreen: {
        "default": true
      }
    };
  },
  parseHTML: function parseHTML() {
    return [{
      tag: "div[data-video-embed] div iframe"
    }];
  },
  addCommands: function addCommands() {
    var _this = this;
    var i18n = (0,src_decidim_i18n__WEBPACK_IMPORTED_MODULE_0__.getDictionary)("editor.extensions.videoEmbed");
    return {
      setVideo: function setVideo(options) {
        return function (_ref) {
          var commands = _ref.commands;
          return commands.insertContent({
            type: _this.name,
            attrs: options
          });
        };
      },
      videoEmbedDialog: function videoEmbedDialog() {
        return /*#__PURE__*/function () {
          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref2) {
            var dispatch, videoDialog, _this$editor$getAttri, src, title, dialogState;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  dispatch = _ref2.dispatch;
                  if (!dispatch) {
                    _context.next = 15;
                    break;
                  }
                  videoDialog = new src_decidim_editor_common_input_dialog__WEBPACK_IMPORTED_MODULE_1__["default"](_this.editor, {
                    inputs: {
                      src: {
                        type: "text",
                        label: i18n.urlLabel
                      },
                      title: {
                        type: "text",
                        label: i18n.titleLabel
                      }
                    }
                  });
                  _this$editor$getAttri = _this.editor.getAttributes("videoEmbed"), src = _this$editor$getAttri.src, title = _this$editor$getAttri.title;
                  _context.next = 6;
                  return videoDialog.toggle({
                    src: src,
                    title: title
                  });
                case 6:
                  dialogState = _context.sent;
                  if (!(dialogState !== "save")) {
                    _context.next = 9;
                    break;
                  }
                  return _context.abrupt("return", false);
                case 9:
                  src = videoDialog.getValue("src");
                  title = videoDialog.getValue("title");
                  if (!(!src || src.length < 1)) {
                    _context.next = 14;
                    break;
                  }
                  _this.editor.commands.focus(null, {
                    scrollIntoView: false
                  });
                  return _context.abrupt("return", false);
                case 14:
                  return _context.abrupt("return", _this.editor.chain().setVideo({
                    src: src,
                    title: title
                  }).focus(null, {
                    scrollIntoView: false
                  }).run());
                case 15:
                  return _context.abrupt("return", true);
                case 16:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          return function (_x) {
            return _ref3.apply(this, arguments);
          };
        }();
      }
    };
  },
  addPasteRules: function addPasteRules() {
    return [(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.nodePasteRule)({
      find: YOUTUBE_REGEX_GLOBAL,
      type: this.type,
      getAttributes: function getAttributes(match) {
        return {
          src: match.input,
          title: ""
        };
      }
    }), (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.nodePasteRule)({
      find: VIMEO_REGEX_GLOBAL,
      type: this.type,
      getAttributes: function getAttributes(match) {
        return {
          src: match.input,
          title: ""
        };
      }
    })];
  },
  renderHTML: function renderHTML(_ref4) {
    var HTMLAttributes = _ref4.HTMLAttributes;
    var src = HTMLAttributes.src;
    HTMLAttributes.src = getEmbedUrlFromVideoUrl({
      url: src
    });
    return ["div", {
      "class": "editor-content-videoEmbed",
      "data-video-embed": src
    }, ["div", {}, ["iframe", (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes)({
      width: this.options.width,
      height: this.options.height
    }, HTMLAttributes)]]];
  },
  addProseMirrorPlugins: function addProseMirrorPlugins() {
    var editor = this.editor;
    return [new prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.Plugin({
      props: {
        handleDoubleClick: function handleDoubleClick() {
          if (!editor.isActive("videoEmbed")) {
            return false;
          }
          editor.chain().focus().videoEmbedDialog().run();
          return true;
        }
      }
    })];
  }
}));

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/index.js":
/*!************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/index.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ createEditor; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
/* harmony import */ var src_decidim_editor_extensions_decidim_kit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! src/decidim/editor/extensions/decidim_kit */ "./gems/decidim-module-core/app/packs/src/decidim/editor/extensions/decidim_kit/index.js");
/* harmony import */ var src_decidim_editor_toolbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/decidim/editor/toolbar */ "./gems/decidim-module-core/app/packs/src/decidim/editor/toolbar.js");
/* harmony import */ var src_decidim_editor_common_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! src/decidim/editor/common/helpers */ "./gems/decidim-module-core/app/packs/src/decidim/editor/common/helpers.js");





/**
 * Creates a new rich text editor instance.
 *
 * @param {HTMLElement} container The element that contains the editor.
 * @return {Editor} The rich text editor instance.
 */
function createEditor(container) {
  var _container$dataset;
  var input = container.parentElement.querySelector("input[type=hidden]");
  var label = container.parentElement.querySelector("label");
  var editorContainer = container.querySelector(".editor-input");
  var editorAttributes = {
    role: "textbox",
    "aria-multiline": true
  };
  if (label) {
    var labelId = (0,src_decidim_editor_common_helpers__WEBPACK_IMPORTED_MODULE_2__.uniqueId)("editorlabel");
    label.setAttribute("id", labelId);
    editorAttributes["aria-labelledby"] = labelId;
  }

  /**
   * Toolbar features can be one of:
   *
   * - basic = only basic controls without headings
   * - content = basic + headings
   * - full = basic + headings + image + video
   */
  var features = ((_container$dataset = container.dataset) === null || _container$dataset === void 0 ? void 0 : _container$dataset.toolbar) || "basic";
  var options = JSON.parse(container.dataset.options);
  var context = options.context,
    contentTypes = options.contentTypes;
  var decidimOptions = {};
  if (context !== "participant") {
    decidimOptions.link = {
      allowTargetControl: true
    };
  }
  if (input.hasAttribute("maxlength")) {
    decidimOptions.characterCount = {
      limit: parseInt(input.getAttribute("maxlength"), 10)
    };
  }
  if (features === "basic") {
    decidimOptions.heading = false;
  }
  if (features === "full") {
    decidimOptions.videoEmbed = true;
    var uploadImagesPath = options.uploadImagesPath,
      uploadDialogSelector = options.uploadDialogSelector;
    decidimOptions.image = {
      uploadDialogSelector: uploadDialogSelector,
      contentTypes: contentTypes.image,
      uploadImagesPath: uploadImagesPath
    };
  }
  if (container.classList.contains("js-hashtags")) {
    decidimOptions.hashtag = true;
  }
  if (container.classList.contains("js-mentions")) {
    decidimOptions.mention = true;
  }
  if (container.classList.contains("js-emojis")) {
    decidimOptions.emoji = true;
  }
  var editor = new _tiptap_core__WEBPACK_IMPORTED_MODULE_3__.Editor({
    element: editorContainer,
    editorProps: {
      attributes: editorAttributes
    },
    content: input.value,
    editable: !input.disabled,
    extensions: [src_decidim_editor_extensions_decidim_kit__WEBPACK_IMPORTED_MODULE_0__["default"].configure(decidimOptions)]
  });
  var toolbar = (0,src_decidim_editor_toolbar__WEBPACK_IMPORTED_MODULE_1__["default"])(editor);
  container.insertBefore(toolbar, editorContainer);
  editor.on("update", function () {
    return input.value = editor.getHTML();
  });
  return editor;
}

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/toolbar.js":
/*!**************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/toolbar.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ createEditorToolbar; }
/* harmony export */ });
/* harmony import */ var src_decidim_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! src/decidim/i18n */ "./gems/decidim-module-core/app/packs/src/decidim/i18n.js");
/* harmony import */ var src_decidim_editor_utilities_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/decidim/editor/utilities/html */ "./gems/decidim-module-core/app/packs/src/decidim/editor/utilities/html.js");
/* harmony import */ var images_decidim_remixicon_symbol_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! images/decidim/remixicon.symbol.svg */ "./gems/decidim-module-core/app/packs/images/decidim/remixicon.symbol.svg");



var createIcon = function createIcon(iconName) {
  return "<svg class=\"editor-toolbar-icon\" role=\"img\" aria-hidden=\"true\">\n    <use href=\"".concat(images_decidim_remixicon_symbol_svg__WEBPACK_IMPORTED_MODULE_2__, "#ri-").concat(iconName, "\" />\n  </svg>");
};
var createEditorToolbarGroup = function createEditorToolbarGroup() {
  return (0,src_decidim_editor_utilities_html__WEBPACK_IMPORTED_MODULE_1__["default"])("div").dom(function (el) {
    return el.classList.add("editor-toolbar-group");
  });
};
var createEditorToolbarToggle = function createEditorToolbarToggle(editor, _ref) {
  var type = _ref.type,
    label = _ref.label,
    icon = _ref.icon,
    action = _ref.action,
    _ref$activatable = _ref.activatable,
    activatable = _ref$activatable === void 0 ? true : _ref$activatable;
  return (0,src_decidim_editor_utilities_html__WEBPACK_IMPORTED_MODULE_1__["default"])("button").dom(function (ctrl) {
    ctrl.classList.add("editor-toolbar-control");
    ctrl.dataset.editorType = type;
    if (activatable) {
      ctrl.dataset.editorSelectionType = type;
    }
    ctrl.type = "button";
    ctrl.ariaLabel = label;
    ctrl.title = label;
    ctrl.innerHTML = createIcon(icon);
    ctrl.addEventListener("click", function (ev) {
      ev.preventDefault();
      editor.commands.focus();
      action();
    });
  });
};
var createEditorToolbarSelect = function createEditorToolbarSelect(editor, _ref2) {
  var type = _ref2.type,
    label = _ref2.label,
    options = _ref2.options,
    action = _ref2.action,
    _ref2$activatable = _ref2.activatable,
    activatable = _ref2$activatable === void 0 ? true : _ref2$activatable;
  return (0,src_decidim_editor_utilities_html__WEBPACK_IMPORTED_MODULE_1__["default"])("select").dom(function (ctrl) {
    ctrl.classList.add("editor-toolbar-control", "!pr-8");
    ctrl.dataset.editorType = type;
    if (activatable) {
      ctrl.dataset.editorSelectionType = type;
    }
    ctrl.ariaLabel = label;
    ctrl.title = label;
    options.forEach(function (_ref3) {
      var optionLabel = _ref3.label,
        value = _ref3.value;
      var option = document.createElement("option");
      option.setAttribute("value", value);
      option.textContent = optionLabel;
      ctrl.appendChild(option);
    });
    ctrl.addEventListener("change", function () {
      editor.commands.focus();
      action(ctrl.value);
    });
  });
};

/**
 * Creates the editor toolbar for the given editor instance.
 *
 * @param {Editor} editor An instance of the rich text editor.
 * @returns {HTMLElement} The toolbar element
 */
function createEditorToolbar(editor) {
  var i18n = (0,src_decidim_i18n__WEBPACK_IMPORTED_MODULE_0__.getDictionary)("editor.toolbar");
  var supported = {
    nodes: [],
    marks: [],
    extensions: []
  };
  editor.extensionManager.extensions.forEach(function (ext) {
    if (ext.type === "node") {
      supported.nodes.push(ext.name);
    } else if (ext.type === "mark") {
      supported.marks.push(ext.name);
    } else if (ext.type === "extension") {
      supported.extensions.push(ext.name);
    }
  });

  // Create the toolbar element
  var toolbar = (0,src_decidim_editor_utilities_html__WEBPACK_IMPORTED_MODULE_1__["default"])("div").dom(function (el) {
    return el.classList.add("editor-toolbar");
  }).append(
  // Text style controls
  createEditorToolbarGroup(editor).append(createEditorToolbarSelect(editor, {
    type: "heading",
    label: i18n["control.heading"],
    options: [{
      value: "normal",
      label: i18n["textStyle.normal"]
    }, {
      value: 2,
      label: i18n["textStyle.heading"].replace("%level%", 2)
    }, {
      value: 3,
      label: i18n["textStyle.heading"].replace("%level%", 3)
    }, {
      value: 4,
      label: i18n["textStyle.heading"].replace("%level%", 4)
    }, {
      value: 5,
      label: i18n["textStyle.heading"].replace("%level%", 5)
    }, {
      value: 6,
      label: i18n["textStyle.heading"].replace("%level%", 6)
    }],
    action: function action(value) {
      if (value === "normal") {
        editor.commands.setParagraph();
      } else {
        editor.commands.toggleHeading({
          level: parseInt(value, 10)
        });
      }
    }
  }).render(supported.nodes.includes("heading")))).append(
  // Basic styling controls
  createEditorToolbarGroup(editor).append(createEditorToolbarToggle(editor, {
    type: "bold",
    icon: "bold",
    label: i18n["control.bold"],
    action: function action() {
      return editor.commands.toggleBold();
    }
  }).render(supported.marks.includes("bold")), createEditorToolbarToggle(editor, {
    type: "italic",
    icon: "italic",
    label: i18n["control.italic"],
    action: function action() {
      return editor.commands.toggleItalic();
    }
  }).render(supported.marks.includes("italic")), createEditorToolbarToggle(editor, {
    type: "underline",
    icon: "underline",
    label: i18n["control.underline"],
    action: function action() {
      return editor.commands.toggleUnderline();
    }
  }).render(supported.marks.includes("underline")), createEditorToolbarToggle(editor, {
    type: "hardBreak",
    icon: "text-wrap",
    label: i18n["control.hardBreak"],
    activatable: false,
    action: function action() {
      return editor.commands.setHardBreak();
    }
  }).render(supported.nodes.includes("hardBreak")))).append(
  // List controls
  createEditorToolbarGroup(editor).append(createEditorToolbarToggle(editor, {
    type: "orderedList",
    icon: "list-ordered",
    label: i18n["control.orderedList"],
    action: function action() {
      return editor.commands.toggleOrderedList();
    }
  }).render(supported.nodes.includes("orderedList")), createEditorToolbarToggle(editor, {
    type: "bulletList",
    icon: "list-unordered",
    label: i18n["control.bulletList"],
    action: function action() {
      return editor.commands.toggleBulletList();
    }
  }).render(supported.nodes.includes("bulletList")))).append(
  // Link and erase styles
  createEditorToolbarGroup(editor).append(createEditorToolbarToggle(editor, {
    type: "link",
    icon: "link",
    label: i18n["control.link"],
    action: function action() {
      return editor.commands.linkDialog();
    }
  }).render(supported.marks.includes("link")), createEditorToolbarToggle(editor, {
    type: "common:eraseStyles",
    icon: "eraser-line",
    label: i18n["control.common.eraseStyles"],
    activatable: false,
    action: function action() {
      if (editor.isActive("link") && editor.view.state.selection.empty) {
        var originalPos = editor.view.state.selection.anchor;
        editor.chain().focus().extendMarkRange("link").unsetLink().setTextSelection(originalPos).run();
      } else {
        editor.chain().focus().clearNodes().unsetAllMarks().run();
      }
    }
  }).render(supported.nodes.includes("heading") || supported.marks.includes("bold") || supported.marks.includes("italic") || supported.marks.includes("underline") || supported.nodes.includes("hardBreak") || supported.nodes.includes("orderedList") || supported.nodes.includes("bulletList") || supported.marks.includes("link")))).append(
  // Block styling
  createEditorToolbarGroup(editor).append(createEditorToolbarToggle(editor, {
    type: "codeBlock",
    icon: "code-line",
    label: i18n["control.codeBlock"],
    action: function action() {
      return editor.commands.toggleCodeBlock();
    }
  }).render(supported.nodes.includes("codeBlock")), createEditorToolbarToggle(editor, {
    type: "blockquote",
    icon: "double-quotes-l",
    label: i18n["control.blockquote"],
    action: function action() {
      return editor.commands.toggleBlockquote();
    }
  }).render(supported.nodes.includes("blockquote")))).append(
  // Indent and outdent
  createEditorToolbarGroup(editor).append(createEditorToolbarToggle(editor, {
    type: "indent:indent",
    icon: "indent-increase",
    label: i18n["control.indent.indent"],
    activatable: false,
    action: function action() {
      return editor.commands.indent();
    }
  }).render(supported.extensions.includes("indent")), createEditorToolbarToggle(editor, {
    type: "indent:outdent",
    icon: "indent-decrease",
    label: i18n["control.indent.outdent"],
    activatable: false,
    action: function action() {
      return editor.commands.outdent();
    }
  }).render(supported.extensions.includes("indent")))).append(
  // Multimedia
  createEditorToolbarGroup(editor).append(createEditorToolbarToggle(editor, {
    type: "videoEmbed",
    icon: "video-line",
    label: i18n["control.videoEmbed"],
    action: function action() {
      return editor.commands.videoEmbedDialog();
    }
  }).render(supported.nodes.includes("videoEmbed")), createEditorToolbarToggle(editor, {
    type: "image",
    icon: "image-line",
    label: i18n["control.image"],
    action: function action() {
      return editor.commands.imageDialog();
    }
  }).render(supported.nodes.includes("image")))).render();
  var selectionControls = toolbar.querySelectorAll(".editor-toolbar-control[data-editor-selection-type]");
  var headingSelect = toolbar.querySelector(".editor-toolbar-control[data-editor-type='heading']");
  var selectionUpdated = function selectionUpdated() {
    if (editor.isActive("heading")) {
      var _editor$getAttributes = editor.getAttributes("heading"),
        level = _editor$getAttributes.level;
      headingSelect.value = "".concat(level);
    } else if (headingSelect) {
      headingSelect.value = "normal";
    }
    selectionControls.forEach(function (ctrl) {
      if (editor.isActive(ctrl.dataset.editorSelectionType)) {
        ctrl.classList.add("active");
      } else {
        ctrl.classList.remove("active");
      }
    });
  };
  editor.on("update", selectionUpdated);
  editor.on("selectionUpdate", selectionUpdated);
  return toolbar;
}
;

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/utilities/file.js":
/*!*********************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/utilities/file.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   fileNameToTitle: function() { return /* binding */ fileNameToTitle; }
/* harmony export */ });
var fileNameToTitle = function fileNameToTitle(fileName) {
  return fileName.split(".").slice(0, -1).join(".");
};

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/utilities/html.js":
/*!*********************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/utilities/html.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Calls the provided function and returns the proxy object after the call.
 *
 * @param {*} proxy The proxy object to return after the call.
 * @param {Function} callable The method to call.
 * @returns {*} The provided proxy object
 */
var proxyCall = function proxyCall(proxy, callable) {
  return function () {
    callable.apply(void 0, arguments);
    return proxy;
  };
};

/**
 * Provides a HTML utility to control the HTML rendering more easily and add
 * support for conditional rendering.
 *
 * @param {String} tag The name of the HTML tag to be created.
 * @returns {Object} A proxy object to control the HTML rendering of the
 *   elements.
 */
/* harmony default export */ __webpack_exports__["default"] = (function () {
  var tag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "div";
  var el = document.createElement(tag);
  var proxy = {};
  proxy.dom = proxyCall(proxy, function (callback) {
    return callback(el);
  });
  proxy.append = proxyCall(proxy, function (element) {
    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }
    if (rest.length > 0) {
      proxy.append(element);
      rest.forEach(function (subEl) {
        return proxy.append(subEl);
      });
      return;
    } else if (!element) {
      return;
    }
    if (element instanceof Function) {
      proxy.append(element());
    } else if ((element === null || element === void 0 ? void 0 : element.render) instanceof Function) {
      proxy.append(element.render());
    } else if (element instanceof Node && element.childNodes.length > 0) {
      el.appendChild(element);
    }
  });
  proxy.render = function (condition) {
    if (condition instanceof Function && !condition(el)) {
      return null;
    } else if (condition === false) {
      return null;
    }
    return el;
  };
  return proxy;
});

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/editor/utilities/paste_transform.js":
/*!********************************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/editor/utilities/paste_transform.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   removeMsMetaSegments: function() { return /* binding */ removeMsMetaSegments; },
/* harmony export */   transformMsCould: function() { return /* binding */ transformMsCould; },
/* harmony export */   transformMsDesktop: function() { return /* binding */ transformMsDesktop; }
/* harmony export */ });
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
var parseMsoListStyles = function parseMsoListStyles(doc) {
  var _doc$querySelector;
  var style = (_doc$querySelector = doc.querySelector("style")) === null || _doc$querySelector === void 0 ? void 0 : _doc$querySelector.textContent;
  if (!style) {
    return {};
  }
  var listStyles = {};
  _toConsumableArray(style.matchAll(/@list\s+(l\d+:level\d+)[\s]+\{([^}]+)\}/g)).forEach(function (match) {
    var styleDefs = {};
    match[2].replace(/[\s]+/g, "").split(";").forEach(function (styleDef) {
      var _styleDef$split = styleDef.split(":"),
        _styleDef$split2 = _slicedToArray(_styleDef$split, 2),
        key = _styleDef$split2[0],
        val = _styleDef$split2[1];
      styleDefs[key] = val;
    });
    listStyles[match[1]] = styleDefs;
  });
  return listStyles;
};
var detectMsoList = function detectMsoList(element) {
  var currentStyle = element.getAttribute("style");
  if (!currentStyle) {
    return {
      type: null,
      level: 1
    };
  }
  var listStyleMatch = currentStyle.match(/mso-list:(l\d+)\s(level\d+)/);
  if (listStyleMatch) {
    var _listStyleMatch = _slicedToArray(listStyleMatch, 3),
      type = _listStyleMatch[1],
      level = _listStyleMatch[2];
    return {
      type: type,
      level: parseInt(level.match(/\d/), 10)
    };
  }
  return {
    type: null,
    level: 1
  };
};
var getMsoListStyle = function getMsoListStyle(type, level, styleDefs) {
  if (type === null) {
    return {};
  }
  var typeStyle = styleDefs[type] || {};
  var levelStyle = styleDefs["".concat(type, ":level").concat(level)] || {};
  return Object.assign(typeStyle, levelStyle);
};
var converMsoListStyleToHtml = function converMsoListStyleToHtml(listStyle) {
  var tag = "ol",
    type = null;
  switch (listStyle["mso-level-number-format"]) {
    case "bullet":
      tag = "ul";
      break;
    case "alpha-lower":
    case "lower-alpha":
      type = "a";
      break;
    case "alpha-upper":
    case "upper-alpha":
      type = "A";
      break;
    case "roman-lower":
    case "lower-roman":
      type = "i";
      break;
    case "roman-upper":
    case "upper-roman":
      type = "I";
      break;
    default:
      type = "1";
      break;
  }
  return {
    tag: tag,
    type: type
  };
};
var removeMsMetaSegments = function removeMsMetaSegments(html) {
  return html.replace(/<!\[if\s+[^\]]+\]>((?!<!\[endif\])[\s\S])+<!\[endif\]>/g, "");
};

/**
 * Fixes issues pasting content from desktop version of Word. Replaces the flat
 * lists represented with `<p>` elements with actual list hierarchy based on the
 * data available in the HTML copied from desktop Word.
 *
 * See: https://github.com/ueberdosis/tiptap/issues/3756
 *
 * @param {String} html The original HTML pasted to the editor.
 * @returns {String} The transformed HTML that fixes the list markup to be
 *   correctly represented on an HTML document.
 */
var transformMsDesktop = function transformMsDesktop(html) {
  var _doc$querySelector2;
  var doc = document.createElement("div");
  doc.innerHTML = removeMsMetaSegments(html);
  var elements = doc.querySelectorAll([".MsoListParagraph", ".MsoListParagraphCxSpFirst", ".MsoListParagraphCxSpMiddle", ".MsoListParagraphCxSpLast"].join(", "));
  if (elements.length < 1) {
    return html;
  }
  var listStyles = parseMsoListStyles(doc);
  (_doc$querySelector2 = doc.querySelector("style")) === null || _doc$querySelector2 === void 0 || _doc$querySelector2.remove();
  var currentLevel = 1,
    currentList = null;
  elements.forEach(function (paragraph) {
    var _detectMsoList = detectMsoList(paragraph),
      msoType = _detectMsoList.type,
      level = _detectMsoList.level;
    var listStyle = getMsoListStyle(msoType, level, listStyles);
    var _converMsoListStyleTo = converMsoListStyleToHtml(listStyle),
      tag = _converMsoListStyleTo.tag,
      type = _converMsoListStyleTo.type;
    var li = document.createElement("li");
    var pa = document.createElement("p");
    pa.innerHTML = paragraph.innerHTML;
    li.append(pa);
    if (paragraph.classList.contains("MsoListParagraph") || paragraph.classList.contains("MsoListParagraphCxSpFirst")) {
      currentLevel = 1;
      currentList = document.createElement(tag);
      if (tag === "ol" && type) {
        currentList.setAttribute("type", type);
      }
      currentList.append(li);
      paragraph.replaceWith(currentList);
    } else {
      if (level > currentLevel) {
        currentLevel += 1;
        var subList = document.createElement(tag);
        if (tag === "ol" && type) {
          subList.setAttribute("type", type);
        }
        if (level === currentLevel) {
          subList.append(li);
        } else {
          var subLi = document.createElement("li");
          var subPa = document.createElement("p");
          subLi.append(subPa);
          subList.append(subLi);
        }
        currentList.lastElementChild.append(subList);
        currentList = subList;
      } else {
        while (level < currentLevel) {
          currentLevel -= 1;
          var candidate = currentList.parentNode.closest("ol, ul");
          if (candidate) {
            currentList = candidate;
          } else {
            currentLevel = level;
            break;
          }
        }
        currentList.append(li);
      }
      if (paragraph.classList.contains("MsoListParagraphCxSpLast")) {
        currentLevel = 1;
        currentList = null;
      }
      paragraph.remove();
    }
  });
  return doc.innerHTML;
};

/**
 * Fixes issues pasting content from Office 365. Modifies the list structure
 * to represent the correct sub-list hierarchy based on the data available in
 * the HTML copied from Office 365. Based on this, Tiptap is able to correctly
 * create the hierarchy structure for the lists.
 *
 * See: https://github.com/ueberdosis/tiptap/issues/3751
 *
 * @param {String} html The original HTML pasted to the editor.
 * @returns {String} The transformed HTML that fixes the list hierarchy to be
 *   correctly represented on an HTML document.
 */
var transformMsCould = function transformMsCould(html) {
  var doc = document.createElement("div");
  doc.innerHTML = html;

  // Fetch all the MS lists from the pasted content
  var lists = {};
  doc.querySelectorAll(".ListContainerWrapper").forEach(function (wrapper) {
    var _li$dataset$listid, _lists$_li$dataset$li;
    var li = wrapper.querySelector("li[data-listid]");
    (_lists$_li$dataset$li = lists[_li$dataset$listid = li.dataset.listid]) !== null && _lists$_li$dataset$li !== void 0 ? _lists$_li$dataset$li : lists[_li$dataset$listid] = [];
    lists[li.dataset.listid].push({
      wrapper: wrapper,
      level: parseInt(li.dataset.ariaLevel, 10)
    });
  });
  if (Object.keys(lists).length < 1) {
    return html;
  }

  // Move the list elements to the correct hierarchical positions
  Object.values(lists).forEach(function (list) {
    var _list$shift = list.shift(),
      parentWrapper = _list$shift.wrapper;
    var parent = parentWrapper.querySelector("ol, ul");
    parentWrapper.replaceWith(parent);
    var currentLevel = 1;
    var documentCurrentLevel = 1;
    list.forEach(function (_ref) {
      var wrapper = _ref.wrapper,
        level = _ref.level;
      var listElement = wrapper.querySelector("ol, ul");
      if (level > documentCurrentLevel) {
        var target = null;
        while (level > documentCurrentLevel) {
          documentCurrentLevel += 1;
          if (parent.lastElementChild) {
            currentLevel += 1;
            target = parent.lastElementChild;
          }
        }
        target.append(listElement);
        parent = listElement;
      } else {
        var _parent;
        while (level < currentLevel) {
          currentLevel -= 1;
          var candidate = parent.parentNode.closest("ol, ul");
          if (candidate) {
            parent = candidate;
          } else {
            currentLevel = level;
            break;
          }
        }
        documentCurrentLevel = level;
        (_parent = parent).append.apply(_parent, _toConsumableArray(listElement.querySelectorAll("li")));
        listElement.remove();
      }
      wrapper.remove();
    });
  });
  return doc.innerHTML;
};
var transformers = [transformMsDesktop, transformMsCould];
/* harmony default export */ __webpack_exports__["default"] = (function (html) {
  var _final = html;
  transformers.forEach(function (method) {
    return _final = method(_final);
  });
  return _final;
});

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/i18n.js":
/*!****************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/i18n.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createDictionary: function() { return /* binding */ createDictionary; },
/* harmony export */   getDictionary: function() { return /* binding */ getDictionary; },
/* harmony export */   getMessages: function() { return /* binding */ getMessages; }
/* harmony export */ });
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
/**
 * Gets the configured messages for Decidim. The configuration is passed from
 * the view to the JS within the layout template.
 *
 * @param {String | null} key The top-level key to fetch from the messages
 *   object or `null` to fetch all messages.
 * @returns {Object} The messages object
 */
var getMessages = function getMessages() {
  var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var allMessages = window.Decidim.config.get("messages");
  if (key === null) {
    return allMessages;
  }
  var messages = allMessages;
  key.split(".").forEach(function (part) {
    return messages = messages[part] || {};
  });
  return messages;
};

/**
 * Turns a deep messages object into a dictionary object with a single level and
 * the keys separated with a dot.
 *
 * @param {Object} messages The messages object
 * @param {String | null} prefix Prefix for the messages on recursive calls
 * @returns {Object} The converted dictionary object
 */
var createDictionary = function createDictionary(messages) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
  var _final = {};
  Object.keys(messages).forEach(function (key) {
    if (_typeof(messages[key]) === "object") {
      _final = _objectSpread(_objectSpread({}, _final), createDictionary(messages[key], "".concat(prefix).concat(key, ".")));
    } else if (key === "") {
      _final[(prefix === null || prefix === void 0 ? void 0 : prefix.replace(/\.$/, "")) || ""] = messages[key];
    } else {
      _final["".concat(prefix).concat(key)] = messages[key];
    }
  });
  return _final;
};

/**
 * Creates a dictionary object from the top-level messages object with the
 * provided key.
 *
 * @param {String | null} key The top-level message key to create the dictionary
 *   for
 * @returns {Object} The dictionary object
 */
var getDictionary = function getDictionary(key) {
  return createDictionary(getMessages(key));
};

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/icon.js":
/*!****************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/icon.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ icon; }
/* harmony export */ });
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var DEFAULT_ATTRIBUTES = {
  role: "img",
  "aria-hidden": "true"
};

/**
 * Generates a Decidim icon element and returns it as a string.
 * @param {String} iconKey - the key of the icon to be generated
 * @param {Object} attributes - extra attributes to define for the icon SVG
 * @param {int} wait - number of milliseconds to wait before executing the function.
 * @private
 * @returns {Void} - Returns nothing.
 */
function icon(iconKey) {
  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var iconAttributes = _objectSpread(_objectSpread({}, DEFAULT_ATTRIBUTES), attributes);
  var htmlAttributes = {
    width: "0.75em",
    height: "0.75em"
  };
  Object.keys(iconAttributes).forEach(function (key) {
    // Convert the key to dash-format.
    var newKey = key.replace(/([A-Z])/g, function (ucw) {
      return "-".concat(ucw[0].toLowerCase());
    });
    if (typeof htmlAttributes[key] === "undefined") {
      htmlAttributes[newKey] = iconAttributes[key];
    } else {
      htmlAttributes[newKey] = "".concat(htmlAttributes[newKey], " ").concat(iconAttributes[key]);
    }
  });
  var svg = document.createElement("svg");
  var use = document.createElement("use");
  var title = document.createElement("title");
  title.innerHTML = iconAttributes.title || iconAttributes.ariaLabel || iconKey;
  use.setAttribute("href", "".concat(window.Decidim.config.get("icons_path"), "#ri-").concat(iconKey));
  Object.entries(htmlAttributes).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      key = _ref2[0],
      value = _ref2[1];
    return svg.setAttribute(key, value);
  });
  svg.appendChild(title);
  svg.appendChild(use);
  return svg.outerHTML;
}

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/src/decidim/input_emoji.js":
/*!***********************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/src/decidim/input_emoji.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EmojiButton: function() { return /* binding */ EmojiButton; },
/* harmony export */   "default": function() { return /* binding */ addInputEmoji; }
/* harmony export */ });
/* harmony import */ var _picmo_popup_picker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @picmo/popup-picker */ "./node_modules/@picmo/popup-picker/dist/index.js");
/* harmony import */ var tailwindcss_defaultTheme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tailwindcss/defaultTheme */ "./node_modules/tailwindcss/defaultTheme.js");
/* harmony import */ var tailwindcss_defaultTheme__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tailwindcss_defaultTheme__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var emojibase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! emojibase */ "./node_modules/emojibase/esm/index.js");
/* harmony import */ var src_decidim_i18n__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! src/decidim/i18n */ "./gems/decidim-module-core/app/packs/src/decidim/i18n.js");
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}




var I18N_CONFIG = null;
var EmojiButton = /*#__PURE__*/function () {
  function EmojiButton(elem) {
    _classCallCheck(this, EmojiButton);
    var i18nConfig = EmojiButton.i18n();
    var i18nDictionary = i18nConfig.dictionary;
    var buttonText = i18nConfig.messages.buttonText;
    var wrapper = document.createElement("span");
    wrapper.className = "emoji__container";
    var btnContainer = document.createElement("span");
    btnContainer.className = "emoji__trigger";
    var btn = document.createElement("button");
    btn.className = "emoji__button";
    btn.type = "button";
    btn.setAttribute("aria-label", buttonText);
    btn.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="far" data-icon="smile" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentColor" d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm0 448c-110.3 0-200-89.7-200-200S137.7 56 248 56s200 89.7 200 200-89.7 200-200 200zm-80-216c17.7 0 32-14.3 32-32s-14.3-32-32-32-32 14.3-32 32 14.3 32 32 32zm160 0c17.7 0 32-14.3 32-32s-14.3-32-32-32-32 14.3-32 32 14.3 32 32 32zm4 72.6c-20.8 25-51.5 39.4-84 39.4s-63.2-14.3-84-39.4c-8.5-10.2-23.7-11.5-33.8-3.1-10.2 8.5-11.5 23.6-3.1 33.8 30 36 74.1 56.6 120.9 56.6s90.9-20.6 120.9-56.6c8.5-10.2 7.1-25.3-3.1-33.8-10.1-8.4-25.3-7.1-33.8 3.1z"></path></svg>';
    var referenceElement = document.createElement("span");
    referenceElement.className = "emoji__reference";
    var parent = elem.parentNode;
    parent.insertBefore(wrapper, elem);
    wrapper.appendChild(elem);
    wrapper.appendChild(btnContainer);
    wrapper.appendChild(referenceElement);
    btnContainer.appendChild(btn);

    // The form errors need to be in the same container with the field they
    // belong to for Foundation Abide to show them automatically.
    parent.querySelectorAll(".form-error").forEach(function (el) {
      return wrapper.appendChild(el);
    });
    var picker = (0,_picmo_popup_picker__WEBPACK_IMPORTED_MODULE_0__.createPopup)(_objectSpread({
      autoFocus: "search",
      locale: EmojiButton.locale(),
      i18n: i18nDictionary
    }, window.matchMedia("(max-width: ".concat(tailwindcss_defaultTheme__WEBPACK_IMPORTED_MODULE_1__.screens.sm, ")")).matches && {
      emojiSize: "1.5rem"
    }), {
      position: "bottom-end",
      triggerElement: btn,
      className: "emoji__decidim",
      referenceElement: referenceElement
    });

    // Prevent the picker close button to submit the comment form
    picker.closeButton.type = "button";
    var handlerPicker = function handlerPicker() {
      picker.toggle();
    };
    btn.addEventListener("click", handlerPicker);
    elem.addEventListener("characterCounter", function (event) {
      if (event.detail.remaining >= 4) {
        btn.addEventListener("click", handlerPicker);
        btn.removeAttribute("style");
      } else {
        btn.removeEventListener("click", handlerPicker);
        btn.setAttribute("style", "color:lightgrey");
      }
    });
    picker.addEventListener("emoji:select", function (_ref) {
      var emoji = _ref.emoji;
      if (elem.contentEditable === "true") {
        if (elem.editor) {
          elem.editor.chain().insertContent(" ".concat(emoji, " ")).focus().run();
        } else {
          elem.innerHTML += " ".concat(emoji, " ");
        }
      } else {
        elem.value += " ".concat(emoji, " ");
      }

      // Make sure the input event is dispatched on the input/textarea elements
      if (elem.tagName === "TEXTAREA" || elem.tagName === "INPUT") {
        elem.dispatchEvent(new Event("input"));
      }
      var event = new Event("emoji.added");
      elem.dispatchEvent(event);
    });
  }
  _createClass(EmojiButton, null, [{
    key: "i18n",
    value: function i18n() {
      if (I18N_CONFIG) {
        return I18N_CONFIG;
      }
      var dict = src_decidim_i18n__WEBPACK_IMPORTED_MODULE_2__.getMessages("emojis") || null;
      var buttonText = dict.button;
      if (dict) {
        Reflect.deleteProperty(dict, "button");
        dict = src_decidim_i18n__WEBPACK_IMPORTED_MODULE_2__.createDictionary(dict);
      }

      // dictionary = the messages dictionary passed to Picmo
      // messages = local "extra" messages
      I18N_CONFIG = {
        dictionary: dict,
        messages: {
          buttonText: buttonText
        }
      };
      return I18N_CONFIG;
    }

    // Get the current locale used for the emoji database
    //
    // @returns {string} the current locale if it is supported by emoji base, or english as the fallback locale
  }, {
    key: "locale",
    value: function locale() {
      var emojiLocale = document.documentElement.getAttribute("lang");
      if (!emojibase__WEBPACK_IMPORTED_MODULE_3__.SUPPORTED_LOCALES.includes(emojiLocale)) {
        var _emojiLocale;
        var secondaryLocale = (_emojiLocale = emojiLocale) === null || _emojiLocale === void 0 ? void 0 : _emojiLocale.split("-")[0];
        if (emojibase__WEBPACK_IMPORTED_MODULE_3__.SUPPORTED_LOCALES.includes(secondaryLocale)) {
          emojiLocale = secondaryLocale;
        } else {
          emojiLocale = "en";
        }
      }
      return emojiLocale;
    }
  }]);
  return EmojiButton;
}();

/**
 * Adds the input emojis to the input elements that are defined to have them.
 *
 * @param {HTMLElement} element target node
 * @returns {void}
 */
function addInputEmoji() {
  var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
  var containers = element.querySelectorAll("[data-input-emoji]");
  if (containers.length) {
    containers.forEach(function (elem) {
      return new EmojiButton(elem);
    });
  }
}
;

/***/ }),

/***/ "./node_modules/emojibase/esm/index.js":
/*!*********************************************!*\
  !*** ./node_modules/emojibase/esm/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DARK_SKIN: function() { return /* binding */ DARK_SKIN; },
/* harmony export */   EMOJI: function() { return /* binding */ EMOJI; },
/* harmony export */   EMOJI_VERSIONS: function() { return /* binding */ EMOJI_VERSIONS; },
/* harmony export */   EMOTICON_OPTIONS: function() { return /* binding */ EMOTICON_OPTIONS; },
/* harmony export */   FEMALE: function() { return /* binding */ FEMALE; },
/* harmony export */   FIRST_UNICODE_EMOJI_VERSION: function() { return /* binding */ FIRST_UNICODE_EMOJI_VERSION; },
/* harmony export */   FULLY_QUALIFIED: function() { return /* binding */ FULLY_QUALIFIED; },
/* harmony export */   GROUP_KEY_ACTIVITIES: function() { return /* binding */ GROUP_KEY_ACTIVITIES; },
/* harmony export */   GROUP_KEY_ANIMALS_NATURE: function() { return /* binding */ GROUP_KEY_ANIMALS_NATURE; },
/* harmony export */   GROUP_KEY_COMPONENT: function() { return /* binding */ GROUP_KEY_COMPONENT; },
/* harmony export */   GROUP_KEY_FLAGS: function() { return /* binding */ GROUP_KEY_FLAGS; },
/* harmony export */   GROUP_KEY_FOOD_DRINK: function() { return /* binding */ GROUP_KEY_FOOD_DRINK; },
/* harmony export */   GROUP_KEY_OBJECTS: function() { return /* binding */ GROUP_KEY_OBJECTS; },
/* harmony export */   GROUP_KEY_PEOPLE_BODY: function() { return /* binding */ GROUP_KEY_PEOPLE_BODY; },
/* harmony export */   GROUP_KEY_SMILEYS_EMOTION: function() { return /* binding */ GROUP_KEY_SMILEYS_EMOTION; },
/* harmony export */   GROUP_KEY_SYMBOLS: function() { return /* binding */ GROUP_KEY_SYMBOLS; },
/* harmony export */   GROUP_KEY_TRAVEL_PLACES: function() { return /* binding */ GROUP_KEY_TRAVEL_PLACES; },
/* harmony export */   LATEST_CLDR_VERSION: function() { return /* binding */ LATEST_CLDR_VERSION; },
/* harmony export */   LATEST_EMOJI_VERSION: function() { return /* binding */ LATEST_EMOJI_VERSION; },
/* harmony export */   LATEST_UNICODE_VERSION: function() { return /* binding */ LATEST_UNICODE_VERSION; },
/* harmony export */   LIGHT_SKIN: function() { return /* binding */ LIGHT_SKIN; },
/* harmony export */   MALE: function() { return /* binding */ MALE; },
/* harmony export */   MEDIUM_DARK_SKIN: function() { return /* binding */ MEDIUM_DARK_SKIN; },
/* harmony export */   MEDIUM_LIGHT_SKIN: function() { return /* binding */ MEDIUM_LIGHT_SKIN; },
/* harmony export */   MEDIUM_SKIN: function() { return /* binding */ MEDIUM_SKIN; },
/* harmony export */   MINIMALLY_QUALIFIED: function() { return /* binding */ MINIMALLY_QUALIFIED; },
/* harmony export */   SEQUENCE_REMOVAL_PATTERN: function() { return /* binding */ SEQUENCE_REMOVAL_PATTERN; },
/* harmony export */   SKIN_KEY_DARK: function() { return /* binding */ SKIN_KEY_DARK; },
/* harmony export */   SKIN_KEY_LIGHT: function() { return /* binding */ SKIN_KEY_LIGHT; },
/* harmony export */   SKIN_KEY_MEDIUM: function() { return /* binding */ SKIN_KEY_MEDIUM; },
/* harmony export */   SKIN_KEY_MEDIUM_DARK: function() { return /* binding */ SKIN_KEY_MEDIUM_DARK; },
/* harmony export */   SKIN_KEY_MEDIUM_LIGHT: function() { return /* binding */ SKIN_KEY_MEDIUM_LIGHT; },
/* harmony export */   SUPPORTED_LOCALES: function() { return /* binding */ SUPPORTED_LOCALES; },
/* harmony export */   TEXT: function() { return /* binding */ TEXT; },
/* harmony export */   UNICODE_VERSIONS: function() { return /* binding */ UNICODE_VERSIONS; },
/* harmony export */   UNQUALIFIED: function() { return /* binding */ UNQUALIFIED; },
/* harmony export */   appendSkinToneIndex: function() { return /* binding */ appendSkinToneIndex; },
/* harmony export */   fetchEmojis: function() { return /* binding */ fetchEmojis; },
/* harmony export */   fetchFromCDN: function() { return /* binding */ fetchFromCDN; },
/* harmony export */   fetchMessages: function() { return /* binding */ fetchMessages; },
/* harmony export */   fetchShortcodes: function() { return /* binding */ fetchShortcodes; },
/* harmony export */   flattenEmojiData: function() { return /* binding */ flattenEmojiData; },
/* harmony export */   fromCodepointToUnicode: function() { return /* binding */ fromCodepointToUnicode; },
/* harmony export */   fromHexcodeToCodepoint: function() { return /* binding */ fromHexcodeToCodepoint; },
/* harmony export */   fromUnicodeToHexcode: function() { return /* binding */ fromUnicodeToHexcode; },
/* harmony export */   generateEmoticonPermutations: function() { return /* binding */ generateEmoticonPermutations; },
/* harmony export */   joinShortcodes: function() { return /* binding */ joinShortcodes; },
/* harmony export */   joinShortcodesToEmoji: function() { return /* binding */ joinShortcodesToEmoji; },
/* harmony export */   stripHexcode: function() { return /* binding */ stripHexcode; }
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["skins"],
  _excluded2 = ["local", "version", "cdnUrl"],
  _excluded3 = ["compact", "flat", "shortcodes"];
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
// Bundled with Packemon: https://packemon.dev
// Platform: browser, Support: stable, Format: esm

/**
 * Append a skin tone index (number) to the end of a shortcode.
 */
function appendSkinToneIndex(shortcode, emoji) {
  var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  return "".concat(shortcode, "_").concat(prefix).concat(Array.isArray(emoji.tone) ? emoji.tone.join('-') : emoji.tone);
}
var SEQUENCE_REMOVAL_PATTERN = /200D|FE0E|FE0F/g; // Use numbers instead of string values, as the filesize is greatly reduced.

var TEXT = 0;
var EMOJI = 1;
var FEMALE = 0;
var MALE = 1;
var FULLY_QUALIFIED = 0;
var MINIMALLY_QUALIFIED = 1;
var UNQUALIFIED = 2;
var LIGHT_SKIN = 1;
var MEDIUM_LIGHT_SKIN = 2;
var MEDIUM_SKIN = 3;
var MEDIUM_DARK_SKIN = 4;
var DARK_SKIN = 5;
var GROUP_KEY_SMILEYS_EMOTION = 'smileys-emotion';
var GROUP_KEY_PEOPLE_BODY = 'people-body';
var GROUP_KEY_ANIMALS_NATURE = 'animals-nature';
var GROUP_KEY_FOOD_DRINK = 'food-drink';
var GROUP_KEY_TRAVEL_PLACES = 'travel-places';
var GROUP_KEY_ACTIVITIES = 'activities';
var GROUP_KEY_OBJECTS = 'objects';
var GROUP_KEY_SYMBOLS = 'symbols';
var GROUP_KEY_FLAGS = 'flags';
var GROUP_KEY_COMPONENT = 'component';
var SKIN_KEY_LIGHT = 'light';
var SKIN_KEY_MEDIUM_LIGHT = 'medium-light';
var SKIN_KEY_MEDIUM = 'medium';
var SKIN_KEY_MEDIUM_DARK = 'medium-dark';
var SKIN_KEY_DARK = 'dark'; // Important release versions and locales in generating accurate data.

var LATEST_EMOJI_VERSION = '14.0';
var LATEST_UNICODE_VERSION = '14.0.0';
var LATEST_CLDR_VERSION = '40';
var FIRST_UNICODE_EMOJI_VERSION = '6.0.0';
var EMOJI_VERSIONS = ['1.0', '2.0', '3.0', '4.0', '5.0', '11.0', '12.0', '12.1', '13.0', '13.1', '14.0'];
var UNICODE_VERSIONS = ['6.0', '6.1', '6.2', '6.3', '7.0', '8.0', '9.0', '10.0', '11.0', '12.0', '12.1', '13.0', '14.0'];
var SUPPORTED_LOCALES = ['da',
// Danish
'de',
// German
'en',
// English
'en-gb',
// English (Great Britain)
'es',
// Spanish
'es-mx',
// Spanish (Mexico)
'et',
// Estonian
'fi',
// Finnish
'fr',
// French
'hu',
// Hungarian
'it',
// Italian
'ja',
// Japanese
'ko',
// Korean
'lt',
// Lithuanian
'ms',
// Malay
'nb',
// Norwegian
'nl',
// Dutch
'pl',
// Polish
'pt',
// Portuguese
'ru',
// Russian
'sv',
// Swedish
'th',
// Thai
'uk',
// Ukrainian
'zh',
// Chinese
'zh-hant' // Chinese (Traditional)
]; // Special options for emoticon permutations.

var EMOTICON_OPTIONS = {
  //  man mage
  ':{>': {
    withNose: false
  },
  //  broken heart
  '</3': {
    isFace: false
  },
  //  red heart
  '<3': {
    isFace: false
  },
  //  sign of the horns
  '\\m/': {
    isFace: false
  },
  '\\M/': {
    isFace: false
  },
  //  ogre
  '0)': {
    withNose: false
  }
};
function getFetchUrl(path, version, cdnUrl) {
  var fetchUrl = "https://cdn.jsdelivr.net/npm/emojibase-data@".concat(version, "/").concat(path);
  if (typeof cdnUrl === 'function') {
    fetchUrl = cdnUrl(path, version);
  } else if (typeof cdnUrl === 'string') {
    fetchUrl = "".concat(cdnUrl, "/").concat(path);
  }
  if (true) {
    if (!path || !path.endsWith('.json')) {
      throw new Error('A valid JSON dataset is required to fetch.');
    }
    if (!fetchUrl || !/^https?:\/\//.test(fetchUrl) || !fetchUrl.endsWith('.json')) {
      throw new Error('A valid CDN url is required to fetch.');
    }
    if (!version) {
      throw new Error('A valid release version is required.');
    }
  }
  return fetchUrl;
}
/**
 * This function will fetch `emojibase-data` JSON files from our CDN, parse them,
 * and return the response. It requires a file path relative to the `emojibase-data` package
 * as the 1st argument and an optional object of options as the 2rd argument.
 *
 * ```ts
 * import { fetchFromCDN } from 'emojibase';
 *
 * await fetchFromCDN('ja/compact.json', { version: '2.1.3' });
 * await fetchFromCDN('ja/compact.json', { cdnUrl: 'https://example.com/cdn/emojidata/latest' });
 * await fetchFromCDN('ja/compact.json', {
 *     cdnUrl: (path: string, version: string) => {
 *         return `https://example.com/cdn/emojidata/${version}/${path}`;
 *     }
 * });
 * ```
 */
function fetchFromCDN(_x) {
  return _fetchFromCDN.apply(this, arguments);
}
function _fetchFromCDN() {
  _fetchFromCDN = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(path) {
    var options,
      _options$local,
      local,
      _options$version,
      version,
      cdnUrl,
      opts,
      fetchUrl,
      storage,
      cacheKey,
      cachedData,
      response,
      data,
      _args = arguments;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
          _options$local = options.local, local = _options$local === void 0 ? false : _options$local, _options$version = options.version, version = _options$version === void 0 ? 'latest' : _options$version, cdnUrl = options.cdnUrl, opts = _objectWithoutProperties(options, _excluded2);
          fetchUrl = getFetchUrl(path, version, cdnUrl);
          storage = local ? localStorage : sessionStorage;
          cacheKey = "emojibase/".concat(version, "/").concat(path);
          cachedData = storage.getItem(cacheKey); // Check the cache first
          if (!cachedData) {
            _context.next = 8;
            break;
          }
          return _context.abrupt("return", Promise.resolve(JSON.parse(cachedData)));
        case 8:
          _context.next = 10;
          return fetch(fetchUrl, _objectSpread({
            credentials: 'omit',
            mode: 'cors',
            redirect: 'error'
          }, opts));
        case 10:
          response = _context.sent;
          if (response.ok) {
            _context.next = 13;
            break;
          }
          throw new Error('Failed to load Emojibase dataset.');
        case 13:
          _context.next = 15;
          return response.json();
        case 15:
          data = _context.sent;
          try {
            storage.setItem(cacheKey, JSON.stringify(data));
          } catch (_unused) {// Do not allow quota errors to break the app
          }
          return _context.abrupt("return", data);
        case 18:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _fetchFromCDN.apply(this, arguments);
}
var ALIASES = {
  discord: 'joypixels',
  slack: 'iamcal'
};
/**
 * Fetches and returns localized shortcodes for the defined preset from our CDN.
 * The response is a mapping of emoji hexcodes to shortcodes (either a string or array of strings).
 * Uses `fetchFromCDN` under the hood.
 *
 * ```ts
 * import { fetchShortcodes } from 'emojibase';
 *
 * await fetchShortcodes('ja', 'cldr', { version: '2.1.3' });
 * ```
 */
function fetchShortcodes(_x2, _x3, _x4) {
  return _fetchShortcodes.apply(this, arguments);
}
/**
 * Will join shortcodes from multiple shortcode datasets into a single emoji object
 * using its hexcode. Will remove duplicates in the process.
 */
function _fetchShortcodes() {
  _fetchShortcodes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(locale, preset, options) {
    var _ALIASES$preset;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          return _context2.abrupt("return", fetchFromCDN("".concat(locale, "/shortcodes/").concat((_ALIASES$preset = ALIASES[preset]) !== null && _ALIASES$preset !== void 0 ? _ALIASES$preset : preset, ".json"), options));
        case 1:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _fetchShortcodes.apply(this, arguments);
}
function joinShortcodesToEmoji(emoji, shortcodeDatasets) {
  if (shortcodeDatasets.length === 0) {
    return emoji;
  }
  var list = new Set(emoji.shortcodes);
  shortcodeDatasets.forEach(function (dataset) {
    var shortcodes = dataset[emoji.hexcode];
    if (Array.isArray(shortcodes)) {
      shortcodes.forEach(function (code) {
        return list.add(code);
      });
    } else if (shortcodes) {
      list.add(shortcodes);
    }
  });
  emoji.shortcodes = _toConsumableArray(list);
  if (emoji.skins) {
    emoji.skins.forEach(function (skin) {
      joinShortcodesToEmoji(skin, shortcodeDatasets);
    });
  }
  return emoji;
}
function flattenEmojiData(data) {
  var shortcodeDatasets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var emojis = [];
  data.forEach(function (emoji) {
    if (emoji.skins) {
      // Dont include nested skins array
      var skins = emoji.skins,
        baseEmoji = _objectWithoutProperties(emoji, _excluded);
      emojis.push(joinShortcodesToEmoji(baseEmoji, shortcodeDatasets)); // Push each skin modification into the root list

      skins.forEach(function (skin) {
        var skinEmoji = _objectSpread({}, skin); // Inherit tags from parent if they exist

        if (baseEmoji.tags) {
          skinEmoji.tags = _toConsumableArray(baseEmoji.tags);
        }
        emojis.push(joinShortcodesToEmoji(skinEmoji, shortcodeDatasets));
      });
    } else {
      emojis.push(joinShortcodesToEmoji(emoji, shortcodeDatasets));
    }
  });
  return emojis;
}
function joinShortcodes(emojis, shortcodeDatasets) {
  if (shortcodeDatasets.length === 0) {
    return emojis;
  }
  emojis.forEach(function (emoji) {
    joinShortcodesToEmoji(emoji, shortcodeDatasets);
  });
  return emojis;
}
function fetchEmojis(_x5) {
  return _fetchEmojis.apply(this, arguments);
}
/**
 * Fetches and returns localized messages for emoji related information like groups and sub-groups.
 * Uses `fetchFromCDN` under the hood.
 *
 * ```ts
 * import { fetchMessages } from 'emojibase';
 *
 * await fetchMessages('zh', { version: '2.1.3' });
 * ```
 */
function _fetchEmojis() {
  _fetchEmojis = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(locale) {
    var options,
      _options$compact,
      compact,
      _options$flat,
      flat,
      _options$shortcodes,
      presets,
      opts,
      emojis,
      shortcodes,
      _args3 = arguments;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
          _options$compact = options.compact, compact = _options$compact === void 0 ? false : _options$compact, _options$flat = options.flat, flat = _options$flat === void 0 ? false : _options$flat, _options$shortcodes = options.shortcodes, presets = _options$shortcodes === void 0 ? [] : _options$shortcodes, opts = _objectWithoutProperties(options, _excluded3);
          _context3.next = 4;
          return fetchFromCDN("".concat(locale, "/").concat(compact ? 'compact' : 'data', ".json"), opts);
        case 4:
          emojis = _context3.sent;
          shortcodes = [];
          if (!(presets.length > 0)) {
            _context3.next = 10;
            break;
          }
          _context3.next = 9;
          return Promise.all(presets.map(function (preset) {
            var promise;
            if (preset.includes('/')) {
              var _preset$split = preset.split('/'),
                _preset$split2 = _slicedToArray(_preset$split, 2),
                customLocale = _preset$split2[0],
                customPreset = _preset$split2[1];
              promise = fetchShortcodes(customLocale, customPreset, opts);
            } else {
              promise = fetchShortcodes(locale, preset, opts);
            } // Ignore as the primary dataset should still load

            return promise["catch"](function () {
              return {};
            });
          }));
        case 9:
          shortcodes = _context3.sent;
        case 10:
          return _context3.abrupt("return", flat ? flattenEmojiData(emojis, shortcodes) : joinShortcodes(emojis, shortcodes));
        case 11:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _fetchEmojis.apply(this, arguments);
}
function fetchMessages(_x6, _x7) {
  return _fetchMessages.apply(this, arguments);
}
/**
 * This function will convert an array of numerical codepoints to a literal emoji Unicode character.
 *
 * ```ts
 * import { fromCodepointToUnicode } from 'emojibase';
 *
 * fromCodepointToUnicode([128104, 8205, 128105, 8205, 128103, 8205, 128102]); // 
 * ```
 */
function _fetchMessages() {
  _fetchMessages = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(locale, options) {
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          return _context4.abrupt("return", fetchFromCDN("".concat(locale, "/messages.json"), options));
        case 1:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _fetchMessages.apply(this, arguments);
}
function fromCodepointToUnicode(codepoint) {
  return String.fromCodePoint.apply(String, _toConsumableArray(codepoint));
}
/**
 * This function will convert a hexadecimal codepoint to an array of numerical codepoints.
 * By default, it will split the hexcode using a dash, but can be customized with the 2nd argument.
 *
 * ```ts
 * import { fromHexcodeToCodepoint } from 'emojibase';
 *
 * fromHexcodeToCodepoint('270A-1F3FC'); // [9994, 127996]
 * fromHexcodeToCodepoint('270A 1F3FC', ' '); // [9994, 127996]
 * ```
 */

function fromHexcodeToCodepoint(code) {
  var joiner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '-';
  return code.split(joiner).map(function (point) {
    return Number.parseInt(point, 16);
  });
}
/**
 * This function will convert a literal emoji Unicode character into a dash separated
 * hexadecimal codepoint. Unless `false` is passed as the 2nd argument, zero width
 * joiner's and variation selectors are removed.
 *
 * ```ts
 * import { fromUnicodeToHexcode } from 'emojibase';
 *
 * fromUnicodeToHexcode(''); // 1F468-1F469-1F467-1F466
 * fromUnicodeToHexcode('', false); // 1F468-200D-1F469-200D-1F467-200D-1F466
 * ```
 */

function fromUnicodeToHexcode(unicode) {
  var strip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var hexcode = [];
  _toConsumableArray(unicode).forEach(function (codepoint) {
    var _codepoint$codePointA, _codepoint$codePointA2;
    var hex = (_codepoint$codePointA = (_codepoint$codePointA2 = codepoint.codePointAt(0)) === null || _codepoint$codePointA2 === void 0 ? void 0 : _codepoint$codePointA2.toString(16).toUpperCase()) !== null && _codepoint$codePointA !== void 0 ? _codepoint$codePointA : '';
    while (hex.length < 4) {
      hex = "0".concat(hex);
    }
    if (!strip || strip && !hex.match(SEQUENCE_REMOVAL_PATTERN)) {
      hexcode.push(hex);
    }
  });
  return hexcode.join('-');
}
/**
 * This function will generate multiple permutations of a base emoticon character.
 * The following permutations will occur:
 *
 * - `)` mouth will be replaced with `]` and `}`. The same applies to sad/frowning mouths.
 * - `/` mouth will be replaced with `\`.
 * - `:` eyes will be replaced with `=`.
 * - Supports a `-` nose, by injecting between the eyes and mouth.
 * - Supports both uppercase and lowercase variants.
 *
 * ```ts
 * import { generateEmoticonPermutations } from 'emojibase';
 *
 * generateEmoticonPermutations(':)'); // =-), =-}, :-], =-], :-}, :-), =}, =], =), :}, :], :)
 * ```
 *
 * > The base emoticon must follow a set of naming guidelines to work properly.
 *
 * Furthermore, this function accepts an options object as the 2nd argument, as a means to customize
 * the output.
 *
 * - `isFace` (bool) - Toggles face permutations (mouth and eye variants). Defaults to `true`.
 * - `withNose` (bool) - Toggles nose inclusion. Defaults to `true`.
 *
 * ```ts
 * generateEmoticonPermutations(':)', { withNose: false }); // =}, =], =), :}, :], :)
 * generateEmoticonPermutations('\\m/', { isFace: false }); // \m/, \M/
 * ```
 */

function generateEmoticonPermutations(emoticon) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _options$isFace = options.isFace,
    isFace = _options$isFace === void 0 ? true : _options$isFace,
    _options$withNose = options.withNose,
    withNose = _options$withNose === void 0 ? true : _options$withNose;
  var list = [emoticon]; // Uppercase variant

  if (emoticon.toUpperCase() !== emoticon) {
    list.push.apply(list, _toConsumableArray(generateEmoticonPermutations(emoticon.toUpperCase(), options)));
  }
  if (isFace) {
    // Backwards slash mouth variant
    if (emoticon.includes('/')) {
      list.push.apply(list, _toConsumableArray(generateEmoticonPermutations(emoticon.replace('/', '\\'), options)));
    } // Bracket and curly brace mouth variants

    if (emoticon.includes(')')) {
      list.push.apply(list, _toConsumableArray(generateEmoticonPermutations(emoticon.replace(')', ']'), options)).concat(_toConsumableArray(generateEmoticonPermutations(emoticon.replace(')', '}'), options))));
    }
    if (emoticon.includes('(')) {
      list.push.apply(list, _toConsumableArray(generateEmoticonPermutations(emoticon.replace('(', '['), options)).concat(_toConsumableArray(generateEmoticonPermutations(emoticon.replace('(', '{'), options))));
    } // Eye variant

    if (emoticon.includes(':')) {
      list.push.apply(list, _toConsumableArray(generateEmoticonPermutations(emoticon.replace(':', '='), options)));
    } // Nose variant for ALL

    if (withNose) {
      list.forEach(function (emo) {
        if (!emo.includes('-')) {
          list.push("".concat(emo.slice(0, -1), "-").concat(emo.slice(-1)));
        }
      });
    }
  } // Sort from longest to shortest

  list.sort(function (a, b) {
    return b.length - a.length;
  });
  return _toConsumableArray(new Set(list));
}
var STRIP_PATTERN = new RegExp("(-| )?(".concat(SEQUENCE_REMOVAL_PATTERN.source, ")"), 'g');
/**
 * This function will strip zero width joiners (`200D`) and variation selectors
 * (`FE0E`, `FE0F`) from a hexadecimal codepoint.
 *
 * ```ts
 * import { stripHexcode } from 'emojibase';
 *
 * stripHexcode('1F468-200D-2695-FE0F'); // 1F468-2695
 * ```
 */

function stripHexcode(hexcode) {
  return hexcode.replace(STRIP_PATTERN, '');
}


/***/ }),

/***/ "./node_modules/linkifyjs/dist/linkify.es.js":
/*!***************************************************!*\
  !*** ./node_modules/linkifyjs/dist/linkify.es.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MultiToken: function() { return /* binding */ MultiToken; },
/* harmony export */   Options: function() { return /* binding */ Options; },
/* harmony export */   State: function() { return /* binding */ State; },
/* harmony export */   createTokenClass: function() { return /* binding */ createTokenClass; },
/* harmony export */   find: function() { return /* binding */ find; },
/* harmony export */   init: function() { return /* binding */ init; },
/* harmony export */   multi: function() { return /* binding */ multi; },
/* harmony export */   options: function() { return /* binding */ options; },
/* harmony export */   regexp: function() { return /* binding */ regexp; },
/* harmony export */   registerCustomProtocol: function() { return /* binding */ registerCustomProtocol; },
/* harmony export */   registerPlugin: function() { return /* binding */ registerPlugin; },
/* harmony export */   registerTokenPlugin: function() { return /* binding */ registerTokenPlugin; },
/* harmony export */   reset: function() { return /* binding */ reset; },
/* harmony export */   stringToArray: function() { return /* binding */ stringToArray; },
/* harmony export */   test: function() { return /* binding */ test; },
/* harmony export */   tokenize: function() { return /* binding */ tokenize; }
/* harmony export */ });
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// THIS FILE IS AUTOMATICALLY GENERATED DO NOT EDIT DIRECTLY
// See update-tlds.js for encoding/decoding format
// https://data.iana.org/TLD/tlds-alpha-by-domain.txt
var encodedTlds = 'aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2';
// Internationalized domain names containing non-ASCII
var encodedUtlds = '121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222';

/**
 * @template A
 * @template B
 * @param {A} target
 * @param {B} properties
 * @return {A & B}
 */
var assign = function assign(target, properties) {
  for (var key in properties) {
    target[key] = properties[key];
  }
  return target;
};

/**
 * Finite State Machine generation utilities
 */

/**
 * @template T
 * @typedef {{ [group: string]: T[] }} Collections
 */

/**
 * @typedef {{ [group: string]: true }} Flags
 */

// Keys in scanner Collections instances
var numeric = 'numeric';
var ascii = 'ascii';
var alpha = 'alpha';
var asciinumeric = 'asciinumeric';
var alphanumeric = 'alphanumeric';
var domain = 'domain';
var emoji = 'emoji';
var scheme = 'scheme';
var slashscheme = 'slashscheme';
var whitespace = 'whitespace';

/**
 * @template T
 * @param {string} name
 * @param {Collections<T>} groups to register in
 * @returns {T[]} Current list of tokens in the given collection
 */
function registerGroup(name, groups) {
  if (!(name in groups)) {
    groups[name] = [];
  }
  return groups[name];
}

/**
 * @template T
 * @param {T} t token to add
 * @param {Collections<T>} groups
 * @param {Flags} flags
 */
function addToGroups(t, flags, groups) {
  if (flags[numeric]) {
    flags[asciinumeric] = true;
    flags[alphanumeric] = true;
  }
  if (flags[ascii]) {
    flags[asciinumeric] = true;
    flags[alpha] = true;
  }
  if (flags[asciinumeric]) {
    flags[alphanumeric] = true;
  }
  if (flags[alpha]) {
    flags[alphanumeric] = true;
  }
  if (flags[alphanumeric]) {
    flags[domain] = true;
  }
  if (flags[emoji]) {
    flags[domain] = true;
  }
  for (var k in flags) {
    var group = registerGroup(k, groups);
    if (group.indexOf(t) < 0) {
      group.push(t);
    }
  }
}

/**
 * @template T
 * @param {T} t token to check
 * @param {Collections<T>} groups
 * @returns {Flags} group flags that contain this token
 */
function flagsForToken(t, groups) {
  var result = {};
  for (var c in groups) {
    if (groups[c].indexOf(t) >= 0) {
      result[c] = true;
    }
  }
  return result;
}

/**
 * @template T
 * @typedef {null | T } Transition
 */

/**
 * Define a basic state machine state. j is the list of character transitions,
 * jr is the list of regex-match transitions, jd is the default state to
 * transition to t is the accepting token type, if any. If this is the terminal
 * state, then it does not emit a token.
 *
 * The template type T represents the type of the token this state accepts. This
 * should be a string (such as of the token exports in `text.js`) or a
 * MultiToken subclass (from `multi.js`)
 *
 * @template T
 * @param {T} [token] Token that this state emits
 */
function State(token) {
  if (token === void 0) {
    token = null;
  }
  // this.n = null; // DEBUG: State name
  /** @type {{ [input: string]: State<T> }} j */
  this.j = {}; // IMPLEMENTATION 1
  // this.j = []; // IMPLEMENTATION 2
  /** @type {[RegExp, State<T>][]} jr */
  this.jr = [];
  /** @type {?State<T>} jd */
  this.jd = null;
  /** @type {?T} t */
  this.t = token;
}

/**
 * Scanner token groups
 * @type Collections<string>
 */
State.groups = {};
State.prototype = {
  accepts: function accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go: function go(input) {
    var state = this;
    var nextState = state.j[input];
    if (nextState) {
      return nextState;
    }
    for (var i = 0; i < state.jr.length; i++) {
      var regex = state.jr[i][0];
      var _nextState = state.jr[i][1]; // note: might be empty to prevent default jump
      if (_nextState && regex.test(input)) {
        return _nextState;
      }
    }
    // Nowhere left to jump! Return default, if any
    return state.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has: function has(input, exactOnly) {
    if (exactOnly === void 0) {
      exactOnly = false;
    }
    return exactOnly ? input in this.j : !!this.go(input);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta: function ta(inputs, next, flags, groups) {
    for (var i = 0; i < inputs.length; i++) {
      this.tt(inputs[i], next, flags, groups);
    }
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr: function tr(regexp, next, flags, groups) {
    groups = groups || State.groups;
    var nextState;
    if (next && next.j) {
      nextState = next;
    } else {
      // Token with maybe token groups
      nextState = new State(next);
      if (flags && groups) {
        addToGroups(next, flags, groups);
      }
    }
    this.jr.push([regexp, nextState]);
    return nextState;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts: function ts(input, next, flags, groups) {
    var state = this;
    var len = input.length;
    if (!len) {
      return state;
    }
    for (var i = 0; i < len - 1; i++) {
      state = state.tt(input[i]);
    }
    return state.tt(input[len - 1], next, flags, groups);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt: function tt(input, next, flags, groups) {
    groups = groups || State.groups;
    var state = this;

    // Check if existing state given, just a basic transition
    if (next && next.j) {
      state.j[input] = next;
      return next;
    }
    var t = next;

    // Take the transition with the usual default mechanisms and use that as
    // a template for creating the next state
    var nextState,
      templateState = state.go(input);
    if (templateState) {
      nextState = new State();
      assign(nextState.j, templateState.j);
      nextState.jr.push.apply(nextState.jr, templateState.jr);
      nextState.jd = templateState.jd;
      nextState.t = templateState.t;
    } else {
      nextState = new State();
    }
    if (t) {
      // Ensure newly token is in the same groups as the old token
      if (groups) {
        if (nextState.t && typeof nextState.t === 'string') {
          var allFlags = assign(flagsForToken(nextState.t, groups), flags);
          addToGroups(t, allFlags, groups);
        } else if (flags) {
          addToGroups(t, flags, groups);
        }
      }
      nextState.t = t; // overwrite anything that was previously there
    }
    state.j[input] = nextState;
    return nextState;
  }
};

// Helper functions to improve minification (not exported outside linkifyjs module)

/**
 * @template T
 * @param {State<T>} state
 * @param {string | string[]} input
 * @param {Flags} [flags]
 * @param {Collections<T>} [groups]
 */
var ta = function ta(state, input, next, flags, groups) {
  return state.ta(input, next, flags, groups);
};

/**
 * @template T
 * @param {State<T>} state
 * @param {RegExp} regexp
 * @param {T | State<T>} [next]
 * @param {Flags} [flags]
 * @param {Collections<T>} [groups]
 */
var tr = function tr(state, regexp, next, flags, groups) {
  return state.tr(regexp, next, flags, groups);
};

/**
 * @template T
 * @param {State<T>} state
 * @param {string | string[]} input
 * @param {T | State<T>} [next]
 * @param {Flags} [flags]
 * @param {Collections<T>} [groups]
 */
var ts = function ts(state, input, next, flags, groups) {
  return state.ts(input, next, flags, groups);
};

/**
 * @template T
 * @param {State<T>} state
 * @param {string} input
 * @param {T | State<T>} [next]
 * @param {Collections<T>} [groups]
 * @param {Flags} [flags]
 */
var tt = function tt(state, input, next, flags, groups) {
  return state.tt(input, next, flags, groups);
};

/******************************************************************************
Text Tokens
Identifiers for token outputs from the regexp scanner
******************************************************************************/

// A valid web domain token
var WORD = 'WORD'; // only contains a-z
var UWORD = 'UWORD'; // contains letters other than a-z, used for IDN

// Special case of word
var LOCALHOST = 'LOCALHOST';

// Valid top-level domain, special case of WORD (see tlds.js)
var TLD = 'TLD';

// Valid IDN TLD, special case of UWORD (see tlds.js)
var UTLD = 'UTLD';

// The scheme portion of a web URI protocol. Supported types include: `mailto`,
// `file`, and user-defined custom protocols. Limited to schemes that contain
// only letters
var SCHEME = 'SCHEME';

// Similar to SCHEME, except makes distinction for schemes that must always be
// followed by `://`, not just `:`. Supported types include `http`, `https`,
// `ftp`, `ftps`
var SLASH_SCHEME = 'SLASH_SCHEME';

// Any sequence of digits 0-9
var NUM = 'NUM';

// Any number of consecutive whitespace characters that are not newline
var WS = 'WS';

// New line (unix style)
var NL$1 = 'NL'; // \n

// Opening/closing bracket classes
// TODO: Rename OPEN -> LEFT and CLOSE -> RIGHT in v5 to fit with Unicode names
// Also rename angle brackes to LESSTHAN and GREATER THAN
var OPENBRACE = 'OPENBRACE'; // {
var CLOSEBRACE = 'CLOSEBRACE'; // }
var OPENBRACKET = 'OPENBRACKET'; // [
var CLOSEBRACKET = 'CLOSEBRACKET'; // ]
var OPENPAREN = 'OPENPAREN'; // (
var CLOSEPAREN = 'CLOSEPAREN'; // )
var OPENANGLEBRACKET = 'OPENANGLEBRACKET'; // <
var CLOSEANGLEBRACKET = 'CLOSEANGLEBRACKET'; // >
var FULLWIDTHLEFTPAREN = 'FULLWIDTHLEFTPAREN'; // 
var FULLWIDTHRIGHTPAREN = 'FULLWIDTHRIGHTPAREN'; // 
var LEFTCORNERBRACKET = 'LEFTCORNERBRACKET'; // 
var RIGHTCORNERBRACKET = 'RIGHTCORNERBRACKET'; // 
var LEFTWHITECORNERBRACKET = 'LEFTWHITECORNERBRACKET'; // 
var RIGHTWHITECORNERBRACKET = 'RIGHTWHITECORNERBRACKET'; // 
var FULLWIDTHLESSTHAN = 'FULLWIDTHLESSTHAN'; // 
var FULLWIDTHGREATERTHAN = 'FULLWIDTHGREATERTHAN'; // 

// Various symbols
var AMPERSAND = 'AMPERSAND'; // &
var APOSTROPHE = 'APOSTROPHE'; // '
var ASTERISK = 'ASTERISK'; // *
var AT = 'AT'; // @
var BACKSLASH = 'BACKSLASH'; // \
var BACKTICK = 'BACKTICK'; // `
var CARET = 'CARET'; // ^
var COLON = 'COLON'; // :
var COMMA = 'COMMA'; // ,
var DOLLAR = 'DOLLAR'; // $
var DOT = 'DOT'; // .
var EQUALS = 'EQUALS'; // =
var EXCLAMATION = 'EXCLAMATION'; // !
var HYPHEN = 'HYPHEN'; // -
var PERCENT = 'PERCENT'; // %
var PIPE = 'PIPE'; // |
var PLUS = 'PLUS'; // +
var POUND = 'POUND'; // #
var QUERY = 'QUERY'; // ?
var QUOTE = 'QUOTE'; // "

var SEMI = 'SEMI'; // ;
var SLASH = 'SLASH'; // /
var TILDE = 'TILDE'; // ~
var UNDERSCORE = 'UNDERSCORE'; // _

// Emoji symbol
var EMOJI$1 = 'EMOJI';

// Default token - anything that is not one of the above
var SYM = 'SYM';
var tk = /*#__PURE__*/Object.freeze({
  __proto__: null,
  WORD: WORD,
  UWORD: UWORD,
  LOCALHOST: LOCALHOST,
  TLD: TLD,
  UTLD: UTLD,
  SCHEME: SCHEME,
  SLASH_SCHEME: SLASH_SCHEME,
  NUM: NUM,
  WS: WS,
  NL: NL$1,
  OPENBRACE: OPENBRACE,
  CLOSEBRACE: CLOSEBRACE,
  OPENBRACKET: OPENBRACKET,
  CLOSEBRACKET: CLOSEBRACKET,
  OPENPAREN: OPENPAREN,
  CLOSEPAREN: CLOSEPAREN,
  OPENANGLEBRACKET: OPENANGLEBRACKET,
  CLOSEANGLEBRACKET: CLOSEANGLEBRACKET,
  FULLWIDTHLEFTPAREN: FULLWIDTHLEFTPAREN,
  FULLWIDTHRIGHTPAREN: FULLWIDTHRIGHTPAREN,
  LEFTCORNERBRACKET: LEFTCORNERBRACKET,
  RIGHTCORNERBRACKET: RIGHTCORNERBRACKET,
  LEFTWHITECORNERBRACKET: LEFTWHITECORNERBRACKET,
  RIGHTWHITECORNERBRACKET: RIGHTWHITECORNERBRACKET,
  FULLWIDTHLESSTHAN: FULLWIDTHLESSTHAN,
  FULLWIDTHGREATERTHAN: FULLWIDTHGREATERTHAN,
  AMPERSAND: AMPERSAND,
  APOSTROPHE: APOSTROPHE,
  ASTERISK: ASTERISK,
  AT: AT,
  BACKSLASH: BACKSLASH,
  BACKTICK: BACKTICK,
  CARET: CARET,
  COLON: COLON,
  COMMA: COMMA,
  DOLLAR: DOLLAR,
  DOT: DOT,
  EQUALS: EQUALS,
  EXCLAMATION: EXCLAMATION,
  HYPHEN: HYPHEN,
  PERCENT: PERCENT,
  PIPE: PIPE,
  PLUS: PLUS,
  POUND: POUND,
  QUERY: QUERY,
  QUOTE: QUOTE,
  SEMI: SEMI,
  SLASH: SLASH,
  TILDE: TILDE,
  UNDERSCORE: UNDERSCORE,
  EMOJI: EMOJI$1,
  SYM: SYM
});

// Note that these two Unicode ones expand into a really big one with Babel
var ASCII_LETTER = /[a-z]/;
var LETTER = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0\uDFF0-\uDFFF]|\uD87B[\uDC00-\uDE5D]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])/; // Any Unicode character with letter data type
var EMOJI = /(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDC-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC5\uDECE-\uDEDB\uDEE0-\uDEE8\uDEF0-\uDEF8])/; // Any Unicode emoji character
var EMOJI_VARIATION$1 = /\ufe0f/;
var DIGIT = /\d/;
var SPACE = /\s/;
var regexp = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ASCII_LETTER: ASCII_LETTER,
  LETTER: LETTER,
  EMOJI: EMOJI,
  EMOJI_VARIATION: EMOJI_VARIATION$1,
  DIGIT: DIGIT,
  SPACE: SPACE
});

/**
	The scanner provides an interface that takes a string of text as input, and
	outputs an array of tokens instances that can be used for easy URL parsing.
*/
var NL = '\n'; // New line character
var EMOJI_VARIATION = "\uFE0F"; // Variation selector, follows heart and others
var EMOJI_JOINER = "\u200D"; // zero-width joiner

var tlds = null,
  utlds = null; // don't change so only have to be computed once

/**
 * Scanner output token:
 * - `t` is the token name (e.g., 'NUM', 'EMOJI', 'TLD')
 * - `v` is the value of the token (e.g., '123', '', 'com')
 * - `s` is the start index of the token in the original string
 * - `e` is the end index of the token in the original string
 * @typedef {{t: string, v: string, s: number, e: number}} Token
 */

/**
 * @template T
 * @typedef {{ [collection: string]: T[] }} Collections
 */

/**
 * Initialize the scanner character-based state machine for the given start
 * state
 * @param {[string, boolean][]} customSchemes List of custom schemes, where each
 * item is a length-2 tuple with the first element set to the string scheme, and
 * the second element set to `true` if the `://` after the scheme is optional
 */
function init$2(customSchemes) {
  if (customSchemes === void 0) {
    customSchemes = [];
  }
  // Frequently used states (name argument removed during minification)
  /** @type Collections<string> */
  var groups = {}; // of tokens
  State.groups = groups;
  /** @type State<string> */
  var Start = new State();
  if (tlds == null) {
    tlds = decodeTlds(encodedTlds);
  }
  if (utlds == null) {
    utlds = decodeTlds(encodedUtlds);
  }

  // States for special URL symbols that accept immediately after start
  tt(Start, "'", APOSTROPHE);
  tt(Start, '{', OPENBRACE);
  tt(Start, '}', CLOSEBRACE);
  tt(Start, '[', OPENBRACKET);
  tt(Start, ']', CLOSEBRACKET);
  tt(Start, '(', OPENPAREN);
  tt(Start, ')', CLOSEPAREN);
  tt(Start, '<', OPENANGLEBRACKET);
  tt(Start, '>', CLOSEANGLEBRACKET);
  tt(Start, '', FULLWIDTHLEFTPAREN);
  tt(Start, '', FULLWIDTHRIGHTPAREN);
  tt(Start, '', LEFTCORNERBRACKET);
  tt(Start, '', RIGHTCORNERBRACKET);
  tt(Start, '', LEFTWHITECORNERBRACKET);
  tt(Start, '', RIGHTWHITECORNERBRACKET);
  tt(Start, '', FULLWIDTHLESSTHAN);
  tt(Start, '', FULLWIDTHGREATERTHAN);
  tt(Start, '&', AMPERSAND);
  tt(Start, '*', ASTERISK);
  tt(Start, '@', AT);
  tt(Start, '`', BACKTICK);
  tt(Start, '^', CARET);
  tt(Start, ':', COLON);
  tt(Start, ',', COMMA);
  tt(Start, '$', DOLLAR);
  tt(Start, '.', DOT);
  tt(Start, '=', EQUALS);
  tt(Start, '!', EXCLAMATION);
  tt(Start, '-', HYPHEN);
  tt(Start, '%', PERCENT);
  tt(Start, '|', PIPE);
  tt(Start, '+', PLUS);
  tt(Start, '#', POUND);
  tt(Start, '?', QUERY);
  tt(Start, '"', QUOTE);
  tt(Start, '/', SLASH);
  tt(Start, ';', SEMI);
  tt(Start, '~', TILDE);
  tt(Start, '_', UNDERSCORE);
  tt(Start, '\\', BACKSLASH);
  var Num = tr(Start, DIGIT, NUM, _defineProperty({}, numeric, true));
  tr(Num, DIGIT, Num);

  // State which emits a word token
  var Word = tr(Start, ASCII_LETTER, WORD, _defineProperty({}, ascii, true));
  tr(Word, ASCII_LETTER, Word);

  // Same as previous, but specific to non-fsm.ascii alphabet words
  var UWord = tr(Start, LETTER, UWORD, _defineProperty({}, alpha, true));
  tr(UWord, ASCII_LETTER); // Non-accepting
  tr(UWord, LETTER, UWord);

  // Whitespace jumps
  // Tokens of only non-newline whitespace are arbitrarily long
  // If any whitespace except newline, more whitespace!
  var Ws = tr(Start, SPACE, WS, _defineProperty({}, whitespace, true));
  tt(Start, NL, NL$1, _defineProperty({}, whitespace, true));
  tt(Ws, NL); // non-accepting state to avoid mixing whitespaces
  tr(Ws, SPACE, Ws);

  // Emoji tokens. They are not grouped by the scanner except in cases where a
  // zero-width joiner is present
  var Emoji = tr(Start, EMOJI, EMOJI$1, _defineProperty({}, emoji, true));
  tr(Emoji, EMOJI, Emoji);
  tt(Emoji, EMOJI_VARIATION, Emoji);
  // tt(Start, EMOJI_VARIATION, Emoji); // This one is sketchy

  var EmojiJoiner = tt(Emoji, EMOJI_JOINER);
  tr(EmojiJoiner, EMOJI, Emoji);
  // tt(EmojiJoiner, EMOJI_VARIATION, Emoji); // also sketchy

  // Generates states for top-level domains
  // Note that this is most accurate when tlds are in alphabetical order
  var wordjr = [[ASCII_LETTER, Word]];
  var uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];
  for (var i = 0; i < tlds.length; i++) {
    fastts(Start, tlds[i], TLD, WORD, wordjr);
  }
  for (var _i = 0; _i < utlds.length; _i++) {
    fastts(Start, utlds[_i], UTLD, UWORD, uwordjr);
  }
  addToGroups(TLD, {
    tld: true,
    ascii: true
  }, groups);
  addToGroups(UTLD, {
    utld: true,
    alpha: true
  }, groups);

  // Collect the states generated by different protocols. NOTE: If any new TLDs
  // get added that are also protocols, set the token to be the same as the
  // protocol to ensure parsing works as expected.
  fastts(Start, 'file', SCHEME, WORD, wordjr);
  fastts(Start, 'mailto', SCHEME, WORD, wordjr);
  fastts(Start, 'http', SLASH_SCHEME, WORD, wordjr);
  fastts(Start, 'https', SLASH_SCHEME, WORD, wordjr);
  fastts(Start, 'ftp', SLASH_SCHEME, WORD, wordjr);
  fastts(Start, 'ftps', SLASH_SCHEME, WORD, wordjr);
  addToGroups(SCHEME, {
    scheme: true,
    ascii: true
  }, groups);
  addToGroups(SLASH_SCHEME, {
    slashscheme: true,
    ascii: true
  }, groups);

  // Register custom schemes. Assumes each scheme is asciinumeric with hyphens
  customSchemes = customSchemes.sort(function (a, b) {
    return a[0] > b[0] ? 1 : -1;
  });
  for (var _i2 = 0; _i2 < customSchemes.length; _i2++) {
    var sch = customSchemes[_i2][0];
    var optionalSlashSlash = customSchemes[_i2][1];
    var flags = optionalSlashSlash ? _defineProperty({}, scheme, true) : _defineProperty({}, slashscheme, true);
    if (sch.indexOf('-') >= 0) {
      flags[domain] = true;
    } else if (!ASCII_LETTER.test(sch)) {
      flags[numeric] = true; // numbers only
    } else if (DIGIT.test(sch)) {
      flags[asciinumeric] = true;
    } else {
      flags[ascii] = true;
    }
    ts(Start, sch, sch, flags);
  }

  // Localhost token
  ts(Start, 'localhost', LOCALHOST, {
    ascii: true
  });

  // Set default transition for start state (some symbol)
  Start.jd = new State(SYM);
  return {
    start: Start,
    tokens: assign({
      groups: groups
    }, tk)
  };
}

/**
	Given a string, returns an array of TOKEN instances representing the
	composition of that string.

	@method run
	@param {State<string>} start scanner starting state
	@param {string} str input string to scan
	@return {Token[]} list of tokens, each with a type and value
*/
function run$1(start, str) {
  // State machine is not case sensitive, so input is tokenized in lowercased
  // form (still returns regular case). Uses selective `toLowerCase` because
  // lowercasing the entire string causes the length and character position to
  // vary in some non-English strings with V8-based runtimes.
  var iterable = stringToArray(str.replace(/[A-Z]/g, function (c) {
    return c.toLowerCase();
  }));
  var charCount = iterable.length; // <= len if there are emojis, etc
  var tokens = []; // return value

  // cursor through the string itself, accounting for characters that have
  // width with length 2 such as emojis
  var cursor = 0;

  // Cursor through the array-representation of the string
  var charCursor = 0;

  // Tokenize the string
  while (charCursor < charCount) {
    var state = start;
    var nextState = null;
    var tokenLength = 0;
    var latestAccepting = null;
    var sinceAccepts = -1;
    var charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
      state = nextState;

      // Keep track of the latest accepting state
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    }

    // Roll back to the latest accepting state
    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;

    // No more jumps, just make a new token from the last accepting one
    tokens.push({
      t: latestAccepting.t,
      // token type/name
      v: str.slice(cursor - tokenLength, cursor),
      // string value
      s: cursor - tokenLength,
      // start index
      e: cursor // end index (excluding)
    });
  }
  return tokens;
}

/**
 * Convert a String to an Array of characters, taking into account that some
 * characters like emojis take up two string indexes.
 *
 * Adapted from core-js (MIT license)
 * https://github.com/zloirock/core-js/blob/2d69cf5f99ab3ea3463c395df81e5a15b68f49d9/packages/core-js/internals/string-multibyte.js
 *
 * @function stringToArray
 * @param {string} str
 * @returns {string[]}
 */
function stringToArray(str) {
  var result = [];
  var len = str.length;
  var index = 0;
  while (index < len) {
    var first = str.charCodeAt(index);
    var second = void 0;
    var _char = first < 0xd800 || first > 0xdbff || index + 1 === len || (second = str.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? str[index] // single character
    : str.slice(index, index + 2); // two-index characters
    result.push(_char);
    index += _char.length;
  }
  return result;
}

/**
 * Fast version of ts function for when transition defaults are well known
 * @param {State<string>} state
 * @param {string} input
 * @param {string} t
 * @param {string} defaultt
 * @param {[RegExp, State<string>][]} jr
 * @returns {State<string>}
 */
function fastts(state, input, t, defaultt, jr) {
  var next;
  var len = input.length;
  for (var i = 0; i < len - 1; i++) {
    var _char2 = input[i];
    if (state.j[_char2]) {
      next = state.j[_char2];
    } else {
      next = new State(defaultt);
      next.jr = jr.slice();
      state.j[_char2] = next;
    }
    state = next;
  }
  next = new State(t);
  next.jr = jr.slice();
  state.j[input[len - 1]] = next;
  return next;
}

/**
 * Converts a string of Top-Level Domain names encoded in update-tlds.js back
 * into a list of strings.
 * @param {str} encoded encoded TLDs string
 * @returns {str[]} original TLDs list
 */
function decodeTlds(encoded) {
  var words = [];
  var stack = [];
  var i = 0;
  var digits = '0123456789';
  while (i < encoded.length) {
    var popDigitCount = 0;
    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {
      popDigitCount++; // encountered some digits, have to pop to go one level up trie
    }
    if (popDigitCount > 0) {
      words.push(stack.join('')); // whatever preceded the pop digits must be a word
      for (var popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {
        stack.pop();
      }
      i += popDigitCount;
    } else {
      stack.push(encoded[i]); // drop down a level into the trie
      i++;
    }
  }
  return words;
}

/**
 * An object where each key is a valid DOM Event Name such as `click` or `focus`
 * and each value is an event handler function.
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/Element#events
 * @typedef {?{ [event: string]: Function }} EventListeners
 */

/**
 * All formatted properties required to render a link, including `tagName`,
 * `attributes`, `content` and `eventListeners`.
 * @typedef {{ tagName: any, attributes: {[attr: string]: any}, content: string,
 * eventListeners: EventListeners }} IntermediateRepresentation
 */

/**
 * Specify either an object described by the template type `O` or a function.
 *
 * The function takes a string value (usually the link's href attribute), the
 * link type (`'url'`, `'hashtag`', etc.) and an internal token representation
 * of the link. It should return an object of the template type `O`
 * @template O
 * @typedef {O | ((value: string, type: string, token: MultiToken) => O)} OptObj
 */

/**
 * Specify either a function described by template type `F` or an object.
 *
 * Each key in the object should be a link type (`'url'`, `'hashtag`', etc.). Each
 * value should be a function with template type `F` that is called when the
 * corresponding link type is encountered.
 * @template F
 * @typedef {F | { [type: string]: F}} OptFn
 */

/**
 * Specify either a value with template type `V`, a function that returns `V` or
 * an object where each value resolves to `V`.
 *
 * The function takes a string value (usually the link's href attribute), the
 * link type (`'url'`, `'hashtag`', etc.) and an internal token representation
 * of the link. It should return an object of the template type `V`
 *
 * For the object, each key should be a link type (`'url'`, `'hashtag`', etc.).
 * Each value should either have type `V` or a function that returns V. This
 * function similarly takes a string value and a token.
 *
 * Example valid types for `Opt<string>`:
 *
 * ```js
 * 'hello'
 * (value, type, token) => 'world'
 * { url: 'hello', email: (value, token) => 'world'}
 * ```
 * @template V
 * @typedef {V | ((value: string, type: string, token: MultiToken) => V) | { [type: string]: V | ((value: string, token: MultiToken) => V) }} Opt
 */

/**
 * See available options: https://linkify.js.org/docs/options.html
 * @typedef {{
 * 	defaultProtocol?: string,
 *  events?: OptObj<EventListeners>,
 * 	format?: Opt<string>,
 * 	formatHref?: Opt<string>,
 * 	nl2br?: boolean,
 * 	tagName?: Opt<any>,
 * 	target?: Opt<string>,
 * 	rel?: Opt<string>,
 * 	validate?: Opt<boolean>,
 * 	truncate?: Opt<number>,
 * 	className?: Opt<string>,
 * 	attributes?: OptObj<({ [attr: string]: any })>,
 *  ignoreTags?: string[],
 * 	render?: OptFn<((ir: IntermediateRepresentation) => any)>
 * }} Opts
 */

/**
 * @type Required<Opts>
 */
var defaults = {
  defaultProtocol: 'http',
  events: null,
  format: noop,
  formatHref: noop,
  nl2br: false,
  tagName: 'a',
  target: null,
  rel: null,
  validate: true,
  truncate: Infinity,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};

/**
 * Utility class for linkify interfaces to apply specified
 * {@link Opts formatting and rendering options}.
 *
 * @param {Opts | Options} [opts] Option value overrides.
 * @param {(ir: IntermediateRepresentation) => any} [defaultRender] (For
 *   internal use) default render function that determines how to generate an
 *   HTML element based on a link token's derived tagName, attributes and HTML.
 *   Similar to render option
 */
function Options(opts, defaultRender) {
  if (defaultRender === void 0) {
    defaultRender = null;
  }
  var o = assign({}, defaults);
  if (opts) {
    o = assign(o, opts instanceof Options ? opts.o : opts);
  }

  // Ensure all ignored tags are uppercase
  var ignoredTags = o.ignoreTags;
  var uppercaseIgnoredTags = [];
  for (var i = 0; i < ignoredTags.length; i++) {
    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());
  }
  /** @protected */
  this.o = o;
  if (defaultRender) {
    this.defaultRender = defaultRender;
  }
  this.ignoreTags = uppercaseIgnoredTags;
}
Options.prototype = {
  o: defaults,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender: function defaultRender(ir) {
    return ir;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check: function check(token) {
    return this.get('validate', token.toString(), token);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get: function get(key, operator, token) {
    var isCallable = operator != null;
    var option = this.o[key];
    if (!option) {
      return option;
    }
    if (_typeof(option) === 'object') {
      option = token.t in option ? option[token.t] : defaults[key];
      if (typeof option === 'function' && isCallable) {
        option = option(operator, token);
      }
    } else if (typeof option === 'function' && isCallable) {
      option = option(operator, token.t, token);
    }
    return option;
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj: function getObj(key, operator, token) {
    var obj = this.o[key];
    if (typeof obj === 'function' && operator != null) {
      obj = obj(operator, token.t, token);
    }
    return obj;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render: function render(token) {
    var ir = token.render(this); // intermediate representation
    var renderFn = this.get('render', null, token) || this.defaultRender;
    return renderFn(ir, token.t, token);
  }
};
function noop(val) {
  return val;
}
var options = /*#__PURE__*/Object.freeze({
  __proto__: null,
  defaults: defaults,
  Options: Options,
  assign: assign
});

/******************************************************************************
	Multi-Tokens
	Tokens composed of arrays of TextTokens
******************************************************************************/

/**
 * @param {string} value
 * @param {Token[]} tokens
 */
function MultiToken(value, tokens) {
  this.t = 'token';
  this.v = value;
  this.tk = tokens;
}

/**
 * Abstract class used for manufacturing tokens of text tokens. That is rather
 * than the value for a token being a small string of text, it's value an array
 * of text tokens.
 *
 * Used for grouping together URLs, emails, hashtags, and other potential
 * creations.
 * @class MultiToken
 * @property {string} t
 * @property {string} v
 * @property {Token[]} tk
 * @abstract
 */
MultiToken.prototype = {
  isLink: false,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString: function toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
  */
  toHref: function toHref(scheme) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString: function toFormattedString(options) {
    var val = this.toString();
    var truncate = options.get('truncate', val, this);
    var formatted = options.get('format', val, this);
    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + '' : formatted;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref: function toFormattedHref(options) {
    return options.get('formatHref', this.toHref(options.get('defaultProtocol')), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex: function startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex: function endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject: function toObject(protocol) {
    if (protocol === void 0) {
      protocol = defaults.defaultProtocol;
    }
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject: function toFormattedObject(options) {
    return {
      type: this.t,
      value: this.toFormattedString(options),
      isLink: this.isLink,
      href: this.toFormattedHref(options),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate: function validate(options) {
    return options.get('validate', this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render: function render(options) {
    var token = this;
    var href = this.toHref(options.get('defaultProtocol'));
    var formattedHref = options.get('formatHref', href, this);
    var tagName = options.get('tagName', href, token);
    var content = this.toFormattedString(options);
    var attributes = {};
    var className = options.get('className', href, token);
    var target = options.get('target', href, token);
    var rel = options.get('rel', href, token);
    var attrs = options.getObj('attributes', href, token);
    var eventListeners = options.getObj('events', href, token);
    attributes.href = formattedHref;
    if (className) {
      attributes["class"] = className;
    }
    if (target) {
      attributes.target = target;
    }
    if (rel) {
      attributes.rel = rel;
    }
    if (attrs) {
      assign(attributes, attrs);
    }
    return {
      tagName: tagName,
      attributes: attributes,
      content: content,
      eventListeners: eventListeners
    };
  }
};

/**
 * Create a new token that can be emitted by the parser state machine
 * @param {string} type readable type of the token
 * @param {object} props properties to assign or override, including isLink = true or false
 * @returns {new (value: string, tokens: Token[]) => MultiToken} new token class
 */
function createTokenClass(type, props) {
  var Token = /*#__PURE__*/function (_MultiToken) {
    _inherits(Token, _MultiToken);
    function Token(value, tokens) {
      var _this;
      _classCallCheck(this, Token);
      _this = _callSuper(this, Token, [value, tokens]);
      _this.t = type;
      return _this;
    }
    return _createClass(Token);
  }(MultiToken);
  for (var p in props) {
    Token.prototype[p] = props[p];
  }
  Token.t = type;
  return Token;
}

/**
	Represents a list of tokens making up a valid email address
*/
var Email = createTokenClass('email', {
  isLink: true,
  toHref: function toHref() {
    return 'mailto:' + this.toString();
  }
});

/**
	Represents some plain text
*/
var Text = createTokenClass('text');

/**
	Multi-linebreak token - represents a line break
	@class Nl
*/
var Nl = createTokenClass('nl');

/**
	Represents a list of text tokens making up a valid URL
	@class Url
*/
var Url = createTokenClass('url', {
  isLink: true,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref: function toHref(scheme) {
    if (scheme === void 0) {
      scheme = defaults.defaultProtocol;
    }
    // Check if already has a prefix scheme
    return this.hasProtocol() ? this.v : "".concat(scheme, "://").concat(this.v);
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol: function hasProtocol() {
    var tokens = this.tk;
    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
  }
});
var multi = /*#__PURE__*/Object.freeze({
  __proto__: null,
  MultiToken: MultiToken,
  Base: MultiToken,
  createTokenClass: createTokenClass,
  Email: Email,
  Text: Text,
  Nl: Nl,
  Url: Url
});

/**
	Not exactly parser, more like the second-stage scanner (although we can
	theoretically hotswap the code here with a real parser in the future... but
	for a little URL-finding utility abstract syntax trees may be a little
	overkill).

	URL format: http://en.wikipedia.org/wiki/URI_scheme
	Email format: http://en.wikipedia.org/wiki/EmailAddress (links to RFC in
	reference)

	@module linkify
	@submodule parser
	@main run
*/
var makeState = function makeState(arg) {
  return new State(arg);
};

/**
 * Generate the parser multi token-based state machine
 * @param {{ groups: Collections<string> }} tokens
 */
function init$1(_ref) {
  var groups = _ref.groups;
  // Types of characters the URL can definitely end in
  var qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);

  // Types of tokens that can follow a URL and be part of the query string
  // but cannot be the very last characters
  // Characters that cannot appear in the URL at all should be excluded
  var qsNonAccepting = [APOSTROPHE, COLON, COMMA, DOT, EXCLAMATION, QUERY, QUOTE, SEMI, OPENANGLEBRACKET, CLOSEANGLEBRACKET, OPENBRACE, CLOSEBRACE, CLOSEBRACKET, OPENBRACKET, OPENPAREN, CLOSEPAREN, FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN, LEFTCORNERBRACKET, RIGHTCORNERBRACKET, LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET, FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN];

  // For addresses without the mailto prefix
  // Tokens allowed in the localpart of the email
  var localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, OPENBRACE, CLOSEBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];

  // The universal starting state.
  /**
   * @type State<Token>
   */
  var Start = makeState();
  var Localpart = tt(Start, TILDE); // Local part of the email address
  ta(Localpart, localpartAccepting, Localpart);
  ta(Localpart, groups.domain, Localpart);
  var Domain = makeState(),
    Scheme = makeState(),
    SlashScheme = makeState();
  ta(Start, groups.domain, Domain); // parsed string ends with a potential domain name (A)
  ta(Start, groups.scheme, Scheme); // e.g., 'mailto'
  ta(Start, groups.slashscheme, SlashScheme); // e.g., 'http'

  ta(Domain, localpartAccepting, Localpart);
  ta(Domain, groups.domain, Domain);
  var LocalpartAt = tt(Domain, AT); // Local part of the email address plus @

  tt(Localpart, AT, LocalpartAt); // close to an email address now

  // Local part of an email address can be e.g. 'http' or 'mailto'
  tt(Scheme, AT, LocalpartAt);
  tt(SlashScheme, AT, LocalpartAt);
  var LocalpartDot = tt(Localpart, DOT); // Local part of the email address plus '.' (localpart cannot end in .)
  ta(LocalpartDot, localpartAccepting, Localpart);
  ta(LocalpartDot, groups.domain, Localpart);
  var EmailDomain = makeState();
  ta(LocalpartAt, groups.domain, EmailDomain); // parsed string starts with local email info + @ with a potential domain name
  ta(EmailDomain, groups.domain, EmailDomain);
  var EmailDomainDot = tt(EmailDomain, DOT); // domain followed by DOT
  ta(EmailDomainDot, groups.domain, EmailDomain);
  var Email$1 = makeState(Email); // Possible email address (could have more tlds)
  ta(EmailDomainDot, groups.tld, Email$1);
  ta(EmailDomainDot, groups.utld, Email$1);
  tt(LocalpartAt, LOCALHOST, Email$1);

  // Hyphen can jump back to a domain name
  var EmailDomainHyphen = tt(EmailDomain, HYPHEN); // parsed string starts with local email info + @ with a potential domain name
  ta(EmailDomainHyphen, groups.domain, EmailDomain);
  ta(Email$1, groups.domain, EmailDomain);
  tt(Email$1, DOT, EmailDomainDot);
  tt(Email$1, HYPHEN, EmailDomainHyphen);

  // Final possible email states
  var EmailColon = tt(Email$1, COLON); // URL followed by colon (potential port number here)
  /*const EmailColonPort = */
  ta(EmailColon, groups.numeric, Email); // URL followed by colon and port number

  // Account for dots and hyphens. Hyphens are usually parts of domain names
  // (but not TLDs)
  var DomainHyphen = tt(Domain, HYPHEN); // domain followed by hyphen
  var DomainDot = tt(Domain, DOT); // domain followed by DOT
  ta(DomainHyphen, groups.domain, Domain);
  ta(DomainDot, localpartAccepting, Localpart);
  ta(DomainDot, groups.domain, Domain);
  var DomainDotTld = makeState(Url); // Simplest possible URL with no query string
  ta(DomainDot, groups.tld, DomainDotTld);
  ta(DomainDot, groups.utld, DomainDotTld);
  ta(DomainDotTld, groups.domain, Domain);
  ta(DomainDotTld, localpartAccepting, Localpart);
  tt(DomainDotTld, DOT, DomainDot);
  tt(DomainDotTld, HYPHEN, DomainHyphen);
  tt(DomainDotTld, AT, LocalpartAt);
  var DomainDotTldColon = tt(DomainDotTld, COLON); // URL followed by colon (potential port number here)
  var DomainDotTldColonPort = makeState(Url); // TLD followed by a port number
  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);

  // Long URL with optional port and maybe query string
  var Url$1 = makeState(Url);

  // URL with extra symbols at the end, followed by an opening bracket
  var UrlNonaccept = makeState(); // URL followed by some symbols (will not be part of the final URL)

  // Query strings
  ta(Url$1, qsAccepting, Url$1);
  ta(Url$1, qsNonAccepting, UrlNonaccept);
  ta(UrlNonaccept, qsAccepting, Url$1);
  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);

  // Become real URLs after `SLASH` or `COLON NUM SLASH`
  // Here works with or without scheme:// prefix
  tt(DomainDotTld, SLASH, Url$1);
  tt(DomainDotTldColonPort, SLASH, Url$1);

  // Note that domains that begin with schemes are treated slighly differently
  var SchemeColon = tt(Scheme, COLON); // e.g., 'mailto:'
  var SlashSchemeColon = tt(SlashScheme, COLON); // e.g., 'http:'
  var SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH); // e.g., 'http:/'

  var UriPrefix = tt(SlashSchemeColonSlash, SLASH); // e.g., 'http://'

  // Scheme states can transition to domain states
  ta(Scheme, groups.domain, Domain);
  tt(Scheme, DOT, DomainDot);
  tt(Scheme, HYPHEN, DomainHyphen);
  ta(SlashScheme, groups.domain, Domain);
  tt(SlashScheme, DOT, DomainDot);
  tt(SlashScheme, HYPHEN, DomainHyphen);

  // Force URL with scheme prefix followed by anything sane
  ta(SchemeColon, groups.domain, Url$1);
  tt(SchemeColon, SLASH, Url$1);
  ta(UriPrefix, groups.domain, Url$1);
  ta(UriPrefix, qsAccepting, Url$1);
  tt(UriPrefix, SLASH, Url$1);
  var bracketPairs = [[OPENBRACE, CLOSEBRACE],
  // {}
  [OPENBRACKET, CLOSEBRACKET],
  // []
  [OPENPAREN, CLOSEPAREN],
  // ()
  [OPENANGLEBRACKET, CLOSEANGLEBRACKET],
  // <>
  [FULLWIDTHLEFTPAREN, FULLWIDTHRIGHTPAREN],
  // 
  [LEFTCORNERBRACKET, RIGHTCORNERBRACKET],
  // 
  [LEFTWHITECORNERBRACKET, RIGHTWHITECORNERBRACKET],
  // 
  [FULLWIDTHLESSTHAN, FULLWIDTHGREATERTHAN] // 
  ];
  for (var i = 0; i < bracketPairs.length; i++) {
    var _bracketPairs$i = _slicedToArray(bracketPairs[i], 2),
      OPEN = _bracketPairs$i[0],
      CLOSE = _bracketPairs$i[1];
    var UrlOpen = tt(Url$1, OPEN); // URL followed by open bracket

    // Continue not accepting for open brackets
    tt(UrlNonaccept, OPEN, UrlOpen);

    // Closing bracket component. This character WILL be included in the URL
    tt(UrlOpen, CLOSE, Url$1);

    // URL that beings with an opening bracket, followed by a symbols.
    // Note that the final state can still be `UrlOpen` (if the URL has a
    // single opening bracket for some reason).
    var UrlOpenQ = makeState(Url);
    ta(UrlOpen, qsAccepting, UrlOpenQ);
    var UrlOpenSyms = makeState(); // UrlOpen followed by some symbols it cannot end it
    ta(UrlOpen, qsNonAccepting);

    // URL that begins with an opening bracket, followed by some symbols
    ta(UrlOpenQ, qsAccepting, UrlOpenQ);
    ta(UrlOpenQ, qsNonAccepting, UrlOpenSyms);
    ta(UrlOpenSyms, qsAccepting, UrlOpenQ);
    ta(UrlOpenSyms, qsNonAccepting, UrlOpenSyms);

    // Close brace/bracket to become regular URL
    tt(UrlOpenQ, CLOSE, Url$1);
    tt(UrlOpenSyms, CLOSE, Url$1);
  }
  tt(Start, LOCALHOST, DomainDotTld); // localhost is a valid URL state
  tt(Start, NL$1, Nl); // single new line

  return {
    start: Start,
    tokens: tk
  };
}

/**
 * Run the parser state machine on a list of scanned string-based tokens to
 * create a list of multi tokens, each of which represents a URL, email address,
 * plain text, etc.
 *
 * @param {State<MultiToken>} start parser start state
 * @param {string} input the original input used to generate the given tokens
 * @param {Token[]} tokens list of scanned tokens
 * @returns {MultiToken[]}
 */
function run(start, input, tokens) {
  var len = tokens.length;
  var cursor = 0;
  var multis = [];
  var textTokens = [];
  while (cursor < len) {
    var state = start;
    var secondState = null;
    var nextState = null;
    var multiLength = 0;
    var latestAccepting = null;
    var sinceAccepts = -1;
    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
      // Starting tokens with nowhere to jump to.
      // Consider these to be just plain text
      textTokens.push(tokens[cursor++]);
    }
    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
      // Get the next state
      secondState = null;
      state = nextState;

      // Keep track of the latest accepting state
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      // No accepting state was found, part of a regular text token add
      // the first text token to the text tokens array and try again from
      // the next
      cursor -= multiLength;
      if (cursor < len) {
        textTokens.push(tokens[cursor]);
        cursor++;
      }
    } else {
      // Accepting state!
      // First close off the textTokens (if available)
      if (textTokens.length > 0) {
        multis.push(initMultiToken(Text, input, textTokens));
        textTokens = [];
      }

      // Roll back to the latest accepting state
      cursor -= sinceAccepts;
      multiLength -= sinceAccepts;

      // Create a new multitoken
      var Multi = latestAccepting.t;
      var subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(initMultiToken(Multi, input, subtokens));
    }
  }

  // Finally close off the textTokens (if available)
  if (textTokens.length > 0) {
    multis.push(initMultiToken(Text, input, textTokens));
  }
  return multis;
}

/**
 * Utility function for instantiating a new multitoken with all the relevant
 * fields during parsing.
 * @param {new (value: string, tokens: Token[]) => MultiToken} Multi class to instantiate
 * @param {string} input original input string
 * @param {Token[]} tokens consecutive tokens scanned from input string
 * @returns {MultiToken}
 */
function initMultiToken(Multi, input, tokens) {
  var startIdx = tokens[0].s;
  var endIdx = tokens[tokens.length - 1].e;
  var value = input.slice(startIdx, endIdx);
  return new Multi(value, tokens);
}
var warn = typeof console !== 'undefined' && console && console.warn || function () {};
var warnAdvice = 'until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.';

// Side-effect initialization state
var INIT = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: false
};

/**
 * @typedef {{
 * 	start: State<string>,
 * 	tokens: { groups: Collections<string> } & typeof tk
 * }} ScannerInit
 */

/**
 * @typedef {{
 * 	start: State<MultiToken>,
 * 	tokens: typeof multi
 * }} ParserInit
 */

/**
 * @typedef {(arg: { scanner: ScannerInit }) => void} TokenPlugin
 */

/**
 * @typedef {(arg: { scanner: ScannerInit, parser: ParserInit }) => void} Plugin
 */

/**
 * De-register all plugins and reset the internal state-machine. Used for
 * testing; not required in practice.
 * @private
 */
function reset() {
  State.groups = {};
  INIT.scanner = null;
  INIT.parser = null;
  INIT.tokenQueue = [];
  INIT.pluginQueue = [];
  INIT.customSchemes = [];
  INIT.initialized = false;
}

/**
 * Register a token plugin to allow the scanner to recognize additional token
 * types before the parser state machine is constructed from the results.
 * @param {string} name of plugin to register
 * @param {TokenPlugin} plugin function that accepts the scanner state machine
 * and available scanner tokens and collections and extends the state machine to
 * recognize additional tokens or groups.
 */
function registerTokenPlugin(name, plugin) {
  if (typeof plugin !== 'function') {
    throw new Error("linkifyjs: Invalid token plugin ".concat(plugin, " (expects function)"));
  }
  for (var i = 0; i < INIT.tokenQueue.length; i++) {
    if (name === INIT.tokenQueue[i][0]) {
      warn("linkifyjs: token plugin \"".concat(name, "\" already registered - will be overwritten"));
      INIT.tokenQueue[i] = [name, plugin];
      return;
    }
  }
  INIT.tokenQueue.push([name, plugin]);
  if (INIT.initialized) {
    warn("linkifyjs: already initialized - will not register token plugin \"".concat(name, "\" ").concat(warnAdvice));
  }
}

/**
 * Register a linkify plugin
 * @param {string} name of plugin to register
 * @param {Plugin} plugin function that accepts the parser state machine and
 * extends the parser to recognize additional link types
 */
function registerPlugin(name, plugin) {
  if (typeof plugin !== 'function') {
    throw new Error("linkifyjs: Invalid plugin ".concat(plugin, " (expects function)"));
  }
  for (var i = 0; i < INIT.pluginQueue.length; i++) {
    if (name === INIT.pluginQueue[i][0]) {
      warn("linkifyjs: plugin \"".concat(name, "\" already registered - will be overwritten"));
      INIT.pluginQueue[i] = [name, plugin];
      return;
    }
  }
  INIT.pluginQueue.push([name, plugin]);
  if (INIT.initialized) {
    warn("linkifyjs: already initialized - will not register plugin \"".concat(name, "\" ").concat(warnAdvice));
  }
}

/**
 * Detect URLs with the following additional protocol. Anything with format
 * "protocol://..." will be considered a link. If `optionalSlashSlash` is set to
 * `true`, anything with format "protocol:..." will be considered a link.
 * @param {string} protocol
 * @param {boolean} [optionalSlashSlash]
 */
function registerCustomProtocol(scheme, optionalSlashSlash) {
  if (optionalSlashSlash === void 0) {
    optionalSlashSlash = false;
  }
  if (INIT.initialized) {
    warn("linkifyjs: already initialized - will not register custom scheme \"".concat(scheme, "\" ").concat(warnAdvice));
  }
  if (!/^[0-9a-z]+(-[0-9a-z]+)*$/.test(scheme)) {
    throw new Error("linkifyjs: incorrect scheme format.\n1. Must only contain digits, lowercase ASCII letters or \"-\"\n2. Cannot start or end with \"-\"\n3. \"-\" cannot repeat");
  }
  INIT.customSchemes.push([scheme, optionalSlashSlash]);
}

/**
 * Initialize the linkify state machine. Called automatically the first time
 * linkify is called on a string, but may be called manually as well.
 */
function init() {
  // Initialize scanner state machine and plugins
  INIT.scanner = init$2(INIT.customSchemes);
  for (var i = 0; i < INIT.tokenQueue.length; i++) {
    INIT.tokenQueue[i][1]({
      scanner: INIT.scanner
    });
  }

  // Initialize parser state machine and plugins
  INIT.parser = init$1(INIT.scanner.tokens);
  for (var _i3 = 0; _i3 < INIT.pluginQueue.length; _i3++) {
    INIT.pluginQueue[_i3][1]({
      scanner: INIT.scanner,
      parser: INIT.parser
    });
  }
  INIT.initialized = true;
}

/**
 * Parse a string into tokens that represent linkable and non-linkable sub-components
 * @param {string} str
 * @return {MultiToken[]} tokens
 */
function tokenize(str) {
  if (!INIT.initialized) {
    init();
  }
  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));
}

/**
 * Find a list of linkable items in the given string.
 * @param {string} str string to find links in
 * @param {string | Opts} [type] either formatting options or specific type of
 * links to find, e.g., 'url' or 'email'
 * @param {Opts} [opts] formatting options for final output. Cannot be specified
 * if opts already provided in `type` argument
 */
function find(str, type, opts) {
  if (type === void 0) {
    type = null;
  }
  if (opts === void 0) {
    opts = null;
  }
  if (type && _typeof(type) === 'object') {
    if (opts) {
      throw Error("linkifyjs: Invalid link type ".concat(type, "; must be a string"));
    }
    opts = type;
    type = null;
  }
  var options = new Options(opts);
  var tokens = tokenize(str);
  var filtered = [];
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];
    if (token.isLink && (!type || token.t === type) && options.check(token)) {
      filtered.push(token.toFormattedObject(options));
    }
  }
  return filtered;
}

/**
 * Is the given string valid linkable text of some sort. Note that this does not
 * trim the text for you.
 *
 * Optionally pass in a second `type` param, which is the type of link to test
 * for.
 *
 * For example,
 *
 *     linkify.test(str, 'email');
 *
 * Returns `true` if str is a valid email.
 * @param {string} str string to test for links
 * @param {string} [type] optional specific link type to look for
 * @returns boolean true/false
 */
function test(str, type) {
  if (type === void 0) {
    type = null;
  }
  var tokens = tokenize(str);
  return tokens.length === 1 && tokens[0].isLink && (!type || tokens[0].t === type);
}


/***/ }),

/***/ "./node_modules/tailwindcss/defaultTheme.js":
/*!**************************************************!*\
  !*** ./node_modules/tailwindcss/defaultTheme.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var defaultTheme = __webpack_require__(/*! ./lib/public/default-theme */ "./node_modules/tailwindcss/lib/public/default-theme.js");
module.exports = (defaultTheme.__esModule ? defaultTheme : {
  "default": defaultTheme
})["default"];

/***/ }),

/***/ "./node_modules/tailwindcss/lib/public/default-theme.js":
/*!**************************************************************!*\
  !*** ./node_modules/tailwindcss/lib/public/default-theme.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "default", ({
  enumerable: true,
  get: function get() {
    return _default;
  }
}));
var _cloneDeep = __webpack_require__(/*! ../util/cloneDeep */ "./node_modules/tailwindcss/lib/util/cloneDeep.js");
var _configfull = /*#__PURE__*/_interop_require_default(__webpack_require__(/*! ../../stubs/config.full */ "./node_modules/tailwindcss/stubs/config.full.js"));
function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var _default = (0, _cloneDeep.cloneDeep)(_configfull["default"].theme);

/***/ }),

/***/ "./node_modules/tailwindcss/lib/util/cloneDeep.js":
/*!********************************************************!*\
  !*** ./node_modules/tailwindcss/lib/util/cloneDeep.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "cloneDeep", ({
  enumerable: true,
  get: function get() {
    return cloneDeep;
  }
}));
function cloneDeep(value) {
  if (Array.isArray(value)) {
    return value.map(function (child) {
      return cloneDeep(child);
    });
  }
  if (_typeof(value) === "object" && value !== null) {
    return Object.fromEntries(Object.entries(value).map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        k = _ref2[0],
        v = _ref2[1];
      return [k, cloneDeep(v)];
    }));
  }
  return value;
}

/***/ }),

/***/ "./node_modules/tailwindcss/stubs/config.full.js":
/*!*******************************************************!*\
  !*** ./node_modules/tailwindcss/stubs/config.full.js ***!
  \*******************************************************/
/***/ (function(module) {

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
module.exports = {
  content: [],
  presets: [],
  darkMode: 'media',
  // or 'class'
  theme: {
    accentColor: function accentColor(_ref) {
      var theme = _ref.theme;
      return _objectSpread(_objectSpread({}, theme('colors')), {}, {
        auto: 'auto'
      });
    },
    animation: {
      none: 'none',
      spin: 'spin 1s linear infinite',
      ping: 'ping 1s cubic-bezier(0, 0, 0.2, 1) infinite',
      pulse: 'pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
      bounce: 'bounce 1s infinite'
    },
    aria: {
      busy: 'busy="true"',
      checked: 'checked="true"',
      disabled: 'disabled="true"',
      expanded: 'expanded="true"',
      hidden: 'hidden="true"',
      pressed: 'pressed="true"',
      readonly: 'readonly="true"',
      required: 'required="true"',
      selected: 'selected="true"'
    },
    aspectRatio: {
      auto: 'auto',
      square: '1 / 1',
      video: '16 / 9'
    },
    backdropBlur: function backdropBlur(_ref2) {
      var theme = _ref2.theme;
      return theme('blur');
    },
    backdropBrightness: function backdropBrightness(_ref3) {
      var theme = _ref3.theme;
      return theme('brightness');
    },
    backdropContrast: function backdropContrast(_ref4) {
      var theme = _ref4.theme;
      return theme('contrast');
    },
    backdropGrayscale: function backdropGrayscale(_ref5) {
      var theme = _ref5.theme;
      return theme('grayscale');
    },
    backdropHueRotate: function backdropHueRotate(_ref6) {
      var theme = _ref6.theme;
      return theme('hueRotate');
    },
    backdropInvert: function backdropInvert(_ref7) {
      var theme = _ref7.theme;
      return theme('invert');
    },
    backdropOpacity: function backdropOpacity(_ref8) {
      var theme = _ref8.theme;
      return theme('opacity');
    },
    backdropSaturate: function backdropSaturate(_ref9) {
      var theme = _ref9.theme;
      return theme('saturate');
    },
    backdropSepia: function backdropSepia(_ref10) {
      var theme = _ref10.theme;
      return theme('sepia');
    },
    backgroundColor: function backgroundColor(_ref11) {
      var theme = _ref11.theme;
      return theme('colors');
    },
    backgroundImage: {
      none: 'none',
      'gradient-to-t': 'linear-gradient(to top, var(--tw-gradient-stops))',
      'gradient-to-tr': 'linear-gradient(to top right, var(--tw-gradient-stops))',
      'gradient-to-r': 'linear-gradient(to right, var(--tw-gradient-stops))',
      'gradient-to-br': 'linear-gradient(to bottom right, var(--tw-gradient-stops))',
      'gradient-to-b': 'linear-gradient(to bottom, var(--tw-gradient-stops))',
      'gradient-to-bl': 'linear-gradient(to bottom left, var(--tw-gradient-stops))',
      'gradient-to-l': 'linear-gradient(to left, var(--tw-gradient-stops))',
      'gradient-to-tl': 'linear-gradient(to top left, var(--tw-gradient-stops))'
    },
    backgroundOpacity: function backgroundOpacity(_ref12) {
      var theme = _ref12.theme;
      return theme('opacity');
    },
    backgroundPosition: {
      bottom: 'bottom',
      center: 'center',
      left: 'left',
      'left-bottom': 'left bottom',
      'left-top': 'left top',
      right: 'right',
      'right-bottom': 'right bottom',
      'right-top': 'right top',
      top: 'top'
    },
    backgroundSize: {
      auto: 'auto',
      cover: 'cover',
      contain: 'contain'
    },
    blur: {
      0: '0',
      none: '0',
      sm: '4px',
      DEFAULT: '8px',
      md: '12px',
      lg: '16px',
      xl: '24px',
      '2xl': '40px',
      '3xl': '64px'
    },
    borderColor: function borderColor(_ref13) {
      var theme = _ref13.theme;
      return _objectSpread(_objectSpread({}, theme('colors')), {}, {
        DEFAULT: theme('colors.gray.200', 'currentColor')
      });
    },
    borderOpacity: function borderOpacity(_ref14) {
      var theme = _ref14.theme;
      return theme('opacity');
    },
    borderRadius: {
      none: '0px',
      sm: '0.125rem',
      DEFAULT: '0.25rem',
      md: '0.375rem',
      lg: '0.5rem',
      xl: '0.75rem',
      '2xl': '1rem',
      '3xl': '1.5rem',
      full: '9999px'
    },
    borderSpacing: function borderSpacing(_ref15) {
      var theme = _ref15.theme;
      return _objectSpread({}, theme('spacing'));
    },
    borderWidth: {
      DEFAULT: '1px',
      0: '0px',
      2: '2px',
      4: '4px',
      8: '8px'
    },
    boxShadow: {
      sm: '0 1px 2px 0 rgb(0 0 0 / 0.05)',
      DEFAULT: '0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)',
      md: '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
      lg: '0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)',
      xl: '0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)',
      '2xl': '0 25px 50px -12px rgb(0 0 0 / 0.25)',
      inner: 'inset 0 2px 4px 0 rgb(0 0 0 / 0.05)',
      none: 'none'
    },
    boxShadowColor: function boxShadowColor(_ref16) {
      var theme = _ref16.theme;
      return theme('colors');
    },
    brightness: {
      0: '0',
      50: '.5',
      75: '.75',
      90: '.9',
      95: '.95',
      100: '1',
      105: '1.05',
      110: '1.1',
      125: '1.25',
      150: '1.5',
      200: '2'
    },
    caretColor: function caretColor(_ref17) {
      var theme = _ref17.theme;
      return theme('colors');
    },
    colors: function colors(_ref18) {
      var _colors = _ref18.colors;
      return {
        inherit: _colors.inherit,
        current: _colors.current,
        transparent: _colors.transparent,
        black: _colors.black,
        white: _colors.white,
        slate: _colors.slate,
        gray: _colors.gray,
        zinc: _colors.zinc,
        neutral: _colors.neutral,
        stone: _colors.stone,
        red: _colors.red,
        orange: _colors.orange,
        amber: _colors.amber,
        yellow: _colors.yellow,
        lime: _colors.lime,
        green: _colors.green,
        emerald: _colors.emerald,
        teal: _colors.teal,
        cyan: _colors.cyan,
        sky: _colors.sky,
        blue: _colors.blue,
        indigo: _colors.indigo,
        violet: _colors.violet,
        purple: _colors.purple,
        fuchsia: _colors.fuchsia,
        pink: _colors.pink,
        rose: _colors.rose
      };
    },
    columns: {
      auto: 'auto',
      1: '1',
      2: '2',
      3: '3',
      4: '4',
      5: '5',
      6: '6',
      7: '7',
      8: '8',
      9: '9',
      10: '10',
      11: '11',
      12: '12',
      '3xs': '16rem',
      '2xs': '18rem',
      xs: '20rem',
      sm: '24rem',
      md: '28rem',
      lg: '32rem',
      xl: '36rem',
      '2xl': '42rem',
      '3xl': '48rem',
      '4xl': '56rem',
      '5xl': '64rem',
      '6xl': '72rem',
      '7xl': '80rem'
    },
    container: {},
    content: {
      none: 'none'
    },
    contrast: {
      0: '0',
      50: '.5',
      75: '.75',
      100: '1',
      125: '1.25',
      150: '1.5',
      200: '2'
    },
    cursor: {
      auto: 'auto',
      "default": 'default',
      pointer: 'pointer',
      wait: 'wait',
      text: 'text',
      move: 'move',
      help: 'help',
      'not-allowed': 'not-allowed',
      none: 'none',
      'context-menu': 'context-menu',
      progress: 'progress',
      cell: 'cell',
      crosshair: 'crosshair',
      'vertical-text': 'vertical-text',
      alias: 'alias',
      copy: 'copy',
      'no-drop': 'no-drop',
      grab: 'grab',
      grabbing: 'grabbing',
      'all-scroll': 'all-scroll',
      'col-resize': 'col-resize',
      'row-resize': 'row-resize',
      'n-resize': 'n-resize',
      'e-resize': 'e-resize',
      's-resize': 's-resize',
      'w-resize': 'w-resize',
      'ne-resize': 'ne-resize',
      'nw-resize': 'nw-resize',
      'se-resize': 'se-resize',
      'sw-resize': 'sw-resize',
      'ew-resize': 'ew-resize',
      'ns-resize': 'ns-resize',
      'nesw-resize': 'nesw-resize',
      'nwse-resize': 'nwse-resize',
      'zoom-in': 'zoom-in',
      'zoom-out': 'zoom-out'
    },
    divideColor: function divideColor(_ref19) {
      var theme = _ref19.theme;
      return theme('borderColor');
    },
    divideOpacity: function divideOpacity(_ref20) {
      var theme = _ref20.theme;
      return theme('borderOpacity');
    },
    divideWidth: function divideWidth(_ref21) {
      var theme = _ref21.theme;
      return theme('borderWidth');
    },
    dropShadow: {
      sm: '0 1px 1px rgb(0 0 0 / 0.05)',
      DEFAULT: ['0 1px 2px rgb(0 0 0 / 0.1)', '0 1px 1px rgb(0 0 0 / 0.06)'],
      md: ['0 4px 3px rgb(0 0 0 / 0.07)', '0 2px 2px rgb(0 0 0 / 0.06)'],
      lg: ['0 10px 8px rgb(0 0 0 / 0.04)', '0 4px 3px rgb(0 0 0 / 0.1)'],
      xl: ['0 20px 13px rgb(0 0 0 / 0.03)', '0 8px 5px rgb(0 0 0 / 0.08)'],
      '2xl': '0 25px 25px rgb(0 0 0 / 0.15)',
      none: '0 0 #0000'
    },
    fill: function fill(_ref22) {
      var theme = _ref22.theme;
      return _objectSpread({
        none: 'none'
      }, theme('colors'));
    },
    flex: {
      1: '1 1 0%',
      auto: '1 1 auto',
      initial: '0 1 auto',
      none: 'none'
    },
    flexBasis: function flexBasis(_ref23) {
      var theme = _ref23.theme;
      return _objectSpread(_objectSpread({
        auto: 'auto'
      }, theme('spacing')), {}, {
        '1/2': '50%',
        '1/3': '33.333333%',
        '2/3': '66.666667%',
        '1/4': '25%',
        '2/4': '50%',
        '3/4': '75%',
        '1/5': '20%',
        '2/5': '40%',
        '3/5': '60%',
        '4/5': '80%',
        '1/6': '16.666667%',
        '2/6': '33.333333%',
        '3/6': '50%',
        '4/6': '66.666667%',
        '5/6': '83.333333%',
        '1/12': '8.333333%',
        '2/12': '16.666667%',
        '3/12': '25%',
        '4/12': '33.333333%',
        '5/12': '41.666667%',
        '6/12': '50%',
        '7/12': '58.333333%',
        '8/12': '66.666667%',
        '9/12': '75%',
        '10/12': '83.333333%',
        '11/12': '91.666667%',
        full: '100%'
      });
    },
    flexGrow: {
      0: '0',
      DEFAULT: '1'
    },
    flexShrink: {
      0: '0',
      DEFAULT: '1'
    },
    fontFamily: {
      sans: ['ui-sans-serif', 'system-ui', 'sans-serif', '"Apple Color Emoji"', '"Segoe UI Emoji"', '"Segoe UI Symbol"', '"Noto Color Emoji"'],
      serif: ['ui-serif', 'Georgia', 'Cambria', '"Times New Roman"', 'Times', 'serif'],
      mono: ['ui-monospace', 'SFMono-Regular', 'Menlo', 'Monaco', 'Consolas', '"Liberation Mono"', '"Courier New"', 'monospace']
    },
    fontSize: {
      xs: ['0.75rem', {
        lineHeight: '1rem'
      }],
      sm: ['0.875rem', {
        lineHeight: '1.25rem'
      }],
      base: ['1rem', {
        lineHeight: '1.5rem'
      }],
      lg: ['1.125rem', {
        lineHeight: '1.75rem'
      }],
      xl: ['1.25rem', {
        lineHeight: '1.75rem'
      }],
      '2xl': ['1.5rem', {
        lineHeight: '2rem'
      }],
      '3xl': ['1.875rem', {
        lineHeight: '2.25rem'
      }],
      '4xl': ['2.25rem', {
        lineHeight: '2.5rem'
      }],
      '5xl': ['3rem', {
        lineHeight: '1'
      }],
      '6xl': ['3.75rem', {
        lineHeight: '1'
      }],
      '7xl': ['4.5rem', {
        lineHeight: '1'
      }],
      '8xl': ['6rem', {
        lineHeight: '1'
      }],
      '9xl': ['8rem', {
        lineHeight: '1'
      }]
    },
    fontWeight: {
      thin: '100',
      extralight: '200',
      light: '300',
      normal: '400',
      medium: '500',
      semibold: '600',
      bold: '700',
      extrabold: '800',
      black: '900'
    },
    gap: function gap(_ref24) {
      var theme = _ref24.theme;
      return theme('spacing');
    },
    gradientColorStops: function gradientColorStops(_ref25) {
      var theme = _ref25.theme;
      return theme('colors');
    },
    gradientColorStopPositions: {
      '0%': '0%',
      '5%': '5%',
      '10%': '10%',
      '15%': '15%',
      '20%': '20%',
      '25%': '25%',
      '30%': '30%',
      '35%': '35%',
      '40%': '40%',
      '45%': '45%',
      '50%': '50%',
      '55%': '55%',
      '60%': '60%',
      '65%': '65%',
      '70%': '70%',
      '75%': '75%',
      '80%': '80%',
      '85%': '85%',
      '90%': '90%',
      '95%': '95%',
      '100%': '100%'
    },
    grayscale: {
      0: '0',
      DEFAULT: '100%'
    },
    gridAutoColumns: {
      auto: 'auto',
      min: 'min-content',
      max: 'max-content',
      fr: 'minmax(0, 1fr)'
    },
    gridAutoRows: {
      auto: 'auto',
      min: 'min-content',
      max: 'max-content',
      fr: 'minmax(0, 1fr)'
    },
    gridColumn: {
      auto: 'auto',
      'span-1': 'span 1 / span 1',
      'span-2': 'span 2 / span 2',
      'span-3': 'span 3 / span 3',
      'span-4': 'span 4 / span 4',
      'span-5': 'span 5 / span 5',
      'span-6': 'span 6 / span 6',
      'span-7': 'span 7 / span 7',
      'span-8': 'span 8 / span 8',
      'span-9': 'span 9 / span 9',
      'span-10': 'span 10 / span 10',
      'span-11': 'span 11 / span 11',
      'span-12': 'span 12 / span 12',
      'span-full': '1 / -1'
    },
    gridColumnEnd: {
      auto: 'auto',
      1: '1',
      2: '2',
      3: '3',
      4: '4',
      5: '5',
      6: '6',
      7: '7',
      8: '8',
      9: '9',
      10: '10',
      11: '11',
      12: '12',
      13: '13'
    },
    gridColumnStart: {
      auto: 'auto',
      1: '1',
      2: '2',
      3: '3',
      4: '4',
      5: '5',
      6: '6',
      7: '7',
      8: '8',
      9: '9',
      10: '10',
      11: '11',
      12: '12',
      13: '13'
    },
    gridRow: {
      auto: 'auto',
      'span-1': 'span 1 / span 1',
      'span-2': 'span 2 / span 2',
      'span-3': 'span 3 / span 3',
      'span-4': 'span 4 / span 4',
      'span-5': 'span 5 / span 5',
      'span-6': 'span 6 / span 6',
      'span-7': 'span 7 / span 7',
      'span-8': 'span 8 / span 8',
      'span-9': 'span 9 / span 9',
      'span-10': 'span 10 / span 10',
      'span-11': 'span 11 / span 11',
      'span-12': 'span 12 / span 12',
      'span-full': '1 / -1'
    },
    gridRowEnd: {
      auto: 'auto',
      1: '1',
      2: '2',
      3: '3',
      4: '4',
      5: '5',
      6: '6',
      7: '7',
      8: '8',
      9: '9',
      10: '10',
      11: '11',
      12: '12',
      13: '13'
    },
    gridRowStart: {
      auto: 'auto',
      1: '1',
      2: '2',
      3: '3',
      4: '4',
      5: '5',
      6: '6',
      7: '7',
      8: '8',
      9: '9',
      10: '10',
      11: '11',
      12: '12',
      13: '13'
    },
    gridTemplateColumns: {
      none: 'none',
      subgrid: 'subgrid',
      1: 'repeat(1, minmax(0, 1fr))',
      2: 'repeat(2, minmax(0, 1fr))',
      3: 'repeat(3, minmax(0, 1fr))',
      4: 'repeat(4, minmax(0, 1fr))',
      5: 'repeat(5, minmax(0, 1fr))',
      6: 'repeat(6, minmax(0, 1fr))',
      7: 'repeat(7, minmax(0, 1fr))',
      8: 'repeat(8, minmax(0, 1fr))',
      9: 'repeat(9, minmax(0, 1fr))',
      10: 'repeat(10, minmax(0, 1fr))',
      11: 'repeat(11, minmax(0, 1fr))',
      12: 'repeat(12, minmax(0, 1fr))'
    },
    gridTemplateRows: {
      none: 'none',
      subgrid: 'subgrid',
      1: 'repeat(1, minmax(0, 1fr))',
      2: 'repeat(2, minmax(0, 1fr))',
      3: 'repeat(3, minmax(0, 1fr))',
      4: 'repeat(4, minmax(0, 1fr))',
      5: 'repeat(5, minmax(0, 1fr))',
      6: 'repeat(6, minmax(0, 1fr))',
      7: 'repeat(7, minmax(0, 1fr))',
      8: 'repeat(8, minmax(0, 1fr))',
      9: 'repeat(9, minmax(0, 1fr))',
      10: 'repeat(10, minmax(0, 1fr))',
      11: 'repeat(11, minmax(0, 1fr))',
      12: 'repeat(12, minmax(0, 1fr))'
    },
    height: function height(_ref26) {
      var theme = _ref26.theme;
      return _objectSpread(_objectSpread({
        auto: 'auto'
      }, theme('spacing')), {}, {
        '1/2': '50%',
        '1/3': '33.333333%',
        '2/3': '66.666667%',
        '1/4': '25%',
        '2/4': '50%',
        '3/4': '75%',
        '1/5': '20%',
        '2/5': '40%',
        '3/5': '60%',
        '4/5': '80%',
        '1/6': '16.666667%',
        '2/6': '33.333333%',
        '3/6': '50%',
        '4/6': '66.666667%',
        '5/6': '83.333333%',
        full: '100%',
        screen: '100vh',
        svh: '100svh',
        lvh: '100lvh',
        dvh: '100dvh',
        min: 'min-content',
        max: 'max-content',
        fit: 'fit-content'
      });
    },
    hueRotate: {
      0: '0deg',
      15: '15deg',
      30: '30deg',
      60: '60deg',
      90: '90deg',
      180: '180deg'
    },
    inset: function inset(_ref27) {
      var theme = _ref27.theme;
      return _objectSpread(_objectSpread({
        auto: 'auto'
      }, theme('spacing')), {}, {
        '1/2': '50%',
        '1/3': '33.333333%',
        '2/3': '66.666667%',
        '1/4': '25%',
        '2/4': '50%',
        '3/4': '75%',
        full: '100%'
      });
    },
    invert: {
      0: '0',
      DEFAULT: '100%'
    },
    keyframes: {
      spin: {
        to: {
          transform: 'rotate(360deg)'
        }
      },
      ping: {
        '75%, 100%': {
          transform: 'scale(2)',
          opacity: '0'
        }
      },
      pulse: {
        '50%': {
          opacity: '.5'
        }
      },
      bounce: {
        '0%, 100%': {
          transform: 'translateY(-25%)',
          animationTimingFunction: 'cubic-bezier(0.8,0,1,1)'
        },
        '50%': {
          transform: 'none',
          animationTimingFunction: 'cubic-bezier(0,0,0.2,1)'
        }
      }
    },
    letterSpacing: {
      tighter: '-0.05em',
      tight: '-0.025em',
      normal: '0em',
      wide: '0.025em',
      wider: '0.05em',
      widest: '0.1em'
    },
    lineHeight: {
      none: '1',
      tight: '1.25',
      snug: '1.375',
      normal: '1.5',
      relaxed: '1.625',
      loose: '2',
      3: '.75rem',
      4: '1rem',
      5: '1.25rem',
      6: '1.5rem',
      7: '1.75rem',
      8: '2rem',
      9: '2.25rem',
      10: '2.5rem'
    },
    listStyleType: {
      none: 'none',
      disc: 'disc',
      decimal: 'decimal'
    },
    listStyleImage: {
      none: 'none'
    },
    margin: function margin(_ref28) {
      var theme = _ref28.theme;
      return _objectSpread({
        auto: 'auto'
      }, theme('spacing'));
    },
    lineClamp: {
      1: '1',
      2: '2',
      3: '3',
      4: '4',
      5: '5',
      6: '6'
    },
    maxHeight: function maxHeight(_ref29) {
      var theme = _ref29.theme;
      return _objectSpread(_objectSpread({}, theme('spacing')), {}, {
        none: 'none',
        full: '100%',
        screen: '100vh',
        svh: '100svh',
        lvh: '100lvh',
        dvh: '100dvh',
        min: 'min-content',
        max: 'max-content',
        fit: 'fit-content'
      });
    },
    maxWidth: function maxWidth(_ref30) {
      var theme = _ref30.theme,
        breakpoints = _ref30.breakpoints;
      return _objectSpread(_objectSpread({}, theme('spacing')), {}, {
        none: 'none',
        xs: '20rem',
        sm: '24rem',
        md: '28rem',
        lg: '32rem',
        xl: '36rem',
        '2xl': '42rem',
        '3xl': '48rem',
        '4xl': '56rem',
        '5xl': '64rem',
        '6xl': '72rem',
        '7xl': '80rem',
        full: '100%',
        min: 'min-content',
        max: 'max-content',
        fit: 'fit-content',
        prose: '65ch'
      }, breakpoints(theme('screens')));
    },
    minHeight: function minHeight(_ref31) {
      var theme = _ref31.theme;
      return _objectSpread(_objectSpread({}, theme('spacing')), {}, {
        full: '100%',
        screen: '100vh',
        svh: '100svh',
        lvh: '100lvh',
        dvh: '100dvh',
        min: 'min-content',
        max: 'max-content',
        fit: 'fit-content'
      });
    },
    minWidth: function minWidth(_ref32) {
      var theme = _ref32.theme;
      return _objectSpread(_objectSpread({}, theme('spacing')), {}, {
        full: '100%',
        min: 'min-content',
        max: 'max-content',
        fit: 'fit-content'
      });
    },
    objectPosition: {
      bottom: 'bottom',
      center: 'center',
      left: 'left',
      'left-bottom': 'left bottom',
      'left-top': 'left top',
      right: 'right',
      'right-bottom': 'right bottom',
      'right-top': 'right top',
      top: 'top'
    },
    opacity: {
      0: '0',
      5: '0.05',
      10: '0.1',
      15: '0.15',
      20: '0.2',
      25: '0.25',
      30: '0.3',
      35: '0.35',
      40: '0.4',
      45: '0.45',
      50: '0.5',
      55: '0.55',
      60: '0.6',
      65: '0.65',
      70: '0.7',
      75: '0.75',
      80: '0.8',
      85: '0.85',
      90: '0.9',
      95: '0.95',
      100: '1'
    },
    order: {
      first: '-9999',
      last: '9999',
      none: '0',
      1: '1',
      2: '2',
      3: '3',
      4: '4',
      5: '5',
      6: '6',
      7: '7',
      8: '8',
      9: '9',
      10: '10',
      11: '11',
      12: '12'
    },
    outlineColor: function outlineColor(_ref33) {
      var theme = _ref33.theme;
      return theme('colors');
    },
    outlineOffset: {
      0: '0px',
      1: '1px',
      2: '2px',
      4: '4px',
      8: '8px'
    },
    outlineWidth: {
      0: '0px',
      1: '1px',
      2: '2px',
      4: '4px',
      8: '8px'
    },
    padding: function padding(_ref34) {
      var theme = _ref34.theme;
      return theme('spacing');
    },
    placeholderColor: function placeholderColor(_ref35) {
      var theme = _ref35.theme;
      return theme('colors');
    },
    placeholderOpacity: function placeholderOpacity(_ref36) {
      var theme = _ref36.theme;
      return theme('opacity');
    },
    ringColor: function ringColor(_ref37) {
      var theme = _ref37.theme;
      return _objectSpread({
        DEFAULT: theme('colors.blue.500', '#3b82f6')
      }, theme('colors'));
    },
    ringOffsetColor: function ringOffsetColor(_ref38) {
      var theme = _ref38.theme;
      return theme('colors');
    },
    ringOffsetWidth: {
      0: '0px',
      1: '1px',
      2: '2px',
      4: '4px',
      8: '8px'
    },
    ringOpacity: function ringOpacity(_ref39) {
      var theme = _ref39.theme;
      return _objectSpread({
        DEFAULT: '0.5'
      }, theme('opacity'));
    },
    ringWidth: {
      DEFAULT: '3px',
      0: '0px',
      1: '1px',
      2: '2px',
      4: '4px',
      8: '8px'
    },
    rotate: {
      0: '0deg',
      1: '1deg',
      2: '2deg',
      3: '3deg',
      6: '6deg',
      12: '12deg',
      45: '45deg',
      90: '90deg',
      180: '180deg'
    },
    saturate: {
      0: '0',
      50: '.5',
      100: '1',
      150: '1.5',
      200: '2'
    },
    scale: {
      0: '0',
      50: '.5',
      75: '.75',
      90: '.9',
      95: '.95',
      100: '1',
      105: '1.05',
      110: '1.1',
      125: '1.25',
      150: '1.5'
    },
    screens: {
      sm: '640px',
      md: '768px',
      lg: '1024px',
      xl: '1280px',
      '2xl': '1536px'
    },
    scrollMargin: function scrollMargin(_ref40) {
      var theme = _ref40.theme;
      return _objectSpread({}, theme('spacing'));
    },
    scrollPadding: function scrollPadding(_ref41) {
      var theme = _ref41.theme;
      return theme('spacing');
    },
    sepia: {
      0: '0',
      DEFAULT: '100%'
    },
    skew: {
      0: '0deg',
      1: '1deg',
      2: '2deg',
      3: '3deg',
      6: '6deg',
      12: '12deg'
    },
    space: function space(_ref42) {
      var theme = _ref42.theme;
      return _objectSpread({}, theme('spacing'));
    },
    spacing: {
      px: '1px',
      0: '0px',
      0.5: '0.125rem',
      1: '0.25rem',
      1.5: '0.375rem',
      2: '0.5rem',
      2.5: '0.625rem',
      3: '0.75rem',
      3.5: '0.875rem',
      4: '1rem',
      5: '1.25rem',
      6: '1.5rem',
      7: '1.75rem',
      8: '2rem',
      9: '2.25rem',
      10: '2.5rem',
      11: '2.75rem',
      12: '3rem',
      14: '3.5rem',
      16: '4rem',
      20: '5rem',
      24: '6rem',
      28: '7rem',
      32: '8rem',
      36: '9rem',
      40: '10rem',
      44: '11rem',
      48: '12rem',
      52: '13rem',
      56: '14rem',
      60: '15rem',
      64: '16rem',
      72: '18rem',
      80: '20rem',
      96: '24rem'
    },
    stroke: function stroke(_ref43) {
      var theme = _ref43.theme;
      return _objectSpread({
        none: 'none'
      }, theme('colors'));
    },
    strokeWidth: {
      0: '0',
      1: '1',
      2: '2'
    },
    supports: {},
    data: {},
    textColor: function textColor(_ref44) {
      var theme = _ref44.theme;
      return theme('colors');
    },
    textDecorationColor: function textDecorationColor(_ref45) {
      var theme = _ref45.theme;
      return theme('colors');
    },
    textDecorationThickness: {
      auto: 'auto',
      'from-font': 'from-font',
      0: '0px',
      1: '1px',
      2: '2px',
      4: '4px',
      8: '8px'
    },
    textIndent: function textIndent(_ref46) {
      var theme = _ref46.theme;
      return _objectSpread({}, theme('spacing'));
    },
    textOpacity: function textOpacity(_ref47) {
      var theme = _ref47.theme;
      return theme('opacity');
    },
    textUnderlineOffset: {
      auto: 'auto',
      0: '0px',
      1: '1px',
      2: '2px',
      4: '4px',
      8: '8px'
    },
    transformOrigin: {
      center: 'center',
      top: 'top',
      'top-right': 'top right',
      right: 'right',
      'bottom-right': 'bottom right',
      bottom: 'bottom',
      'bottom-left': 'bottom left',
      left: 'left',
      'top-left': 'top left'
    },
    transitionDelay: {
      0: '0s',
      75: '75ms',
      100: '100ms',
      150: '150ms',
      200: '200ms',
      300: '300ms',
      500: '500ms',
      700: '700ms',
      1000: '1000ms'
    },
    transitionDuration: {
      DEFAULT: '150ms',
      0: '0s',
      75: '75ms',
      100: '100ms',
      150: '150ms',
      200: '200ms',
      300: '300ms',
      500: '500ms',
      700: '700ms',
      1000: '1000ms'
    },
    transitionProperty: {
      none: 'none',
      all: 'all',
      DEFAULT: 'color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter',
      colors: 'color, background-color, border-color, text-decoration-color, fill, stroke',
      opacity: 'opacity',
      shadow: 'box-shadow',
      transform: 'transform'
    },
    transitionTimingFunction: {
      DEFAULT: 'cubic-bezier(0.4, 0, 0.2, 1)',
      linear: 'linear',
      "in": 'cubic-bezier(0.4, 0, 1, 1)',
      out: 'cubic-bezier(0, 0, 0.2, 1)',
      'in-out': 'cubic-bezier(0.4, 0, 0.2, 1)'
    },
    translate: function translate(_ref48) {
      var theme = _ref48.theme;
      return _objectSpread(_objectSpread({}, theme('spacing')), {}, {
        '1/2': '50%',
        '1/3': '33.333333%',
        '2/3': '66.666667%',
        '1/4': '25%',
        '2/4': '50%',
        '3/4': '75%',
        full: '100%'
      });
    },
    size: function size(_ref49) {
      var theme = _ref49.theme;
      return _objectSpread(_objectSpread({
        auto: 'auto'
      }, theme('spacing')), {}, {
        '1/2': '50%',
        '1/3': '33.333333%',
        '2/3': '66.666667%',
        '1/4': '25%',
        '2/4': '50%',
        '3/4': '75%',
        '1/5': '20%',
        '2/5': '40%',
        '3/5': '60%',
        '4/5': '80%',
        '1/6': '16.666667%',
        '2/6': '33.333333%',
        '3/6': '50%',
        '4/6': '66.666667%',
        '5/6': '83.333333%',
        '1/12': '8.333333%',
        '2/12': '16.666667%',
        '3/12': '25%',
        '4/12': '33.333333%',
        '5/12': '41.666667%',
        '6/12': '50%',
        '7/12': '58.333333%',
        '8/12': '66.666667%',
        '9/12': '75%',
        '10/12': '83.333333%',
        '11/12': '91.666667%',
        full: '100%',
        min: 'min-content',
        max: 'max-content',
        fit: 'fit-content'
      });
    },
    width: function width(_ref50) {
      var theme = _ref50.theme;
      return _objectSpread(_objectSpread({
        auto: 'auto'
      }, theme('spacing')), {}, {
        '1/2': '50%',
        '1/3': '33.333333%',
        '2/3': '66.666667%',
        '1/4': '25%',
        '2/4': '50%',
        '3/4': '75%',
        '1/5': '20%',
        '2/5': '40%',
        '3/5': '60%',
        '4/5': '80%',
        '1/6': '16.666667%',
        '2/6': '33.333333%',
        '3/6': '50%',
        '4/6': '66.666667%',
        '5/6': '83.333333%',
        '1/12': '8.333333%',
        '2/12': '16.666667%',
        '3/12': '25%',
        '4/12': '33.333333%',
        '5/12': '41.666667%',
        '6/12': '50%',
        '7/12': '58.333333%',
        '8/12': '66.666667%',
        '9/12': '75%',
        '10/12': '83.333333%',
        '11/12': '91.666667%',
        full: '100%',
        screen: '100vw',
        svw: '100svw',
        lvw: '100lvw',
        dvw: '100dvw',
        min: 'min-content',
        max: 'max-content',
        fit: 'fit-content'
      });
    },
    willChange: {
      auto: 'auto',
      scroll: 'scroll-position',
      contents: 'contents',
      transform: 'transform'
    },
    zIndex: {
      auto: 'auto',
      0: '0',
      10: '10',
      20: '20',
      30: '30',
      40: '40',
      50: '50'
    }
  },
  plugins: []
};

/***/ }),

/***/ "./gems/decidim-module-core/app/packs/stylesheets/decidim/editor.scss":
/*!****************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/stylesheets/decidim/editor.scss ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./gems/decidim-module-core/app/packs/images/decidim/remixicon.symbol.svg":
/*!********************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/images/decidim/remixicon.symbol.svg ***!
  \********************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
module.exports = __webpack_require__.p + "media/images/remixicon.symbol-e643e553623ffcd49f94.svg";

/***/ }),

/***/ "./node_modules/@picmo/popup-picker/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@picmo/popup-picker/dist/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PopupPickerController: function() { return /* binding */ ae; },
/* harmony export */   createPopup: function() { return /* binding */ pe; }
/* harmony export */ });
/* harmony import */ var picmo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! picmo */ "./node_modules/picmo/dist/index.js");
var _excluded = ["alignment", "allowedPlacements", "autoAlignment"],
  _excluded2 = ["mainAxis", "crossAxis", "fallbackPlacements", "fallbackStrategy", "flipAlignment"],
  _excluded3 = ["mainAxis", "crossAxis", "limiter"];
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _(t) {
  return t.split("-")[0];
}
function V(t) {
  return t.split("-")[1];
}
function K(t) {
  return ["top", "bottom"].includes(_(t)) ? "x" : "y";
}
function at(t) {
  return t === "y" ? "height" : "width";
}
function tt(t, e, n) {
  var i = t.reference,
    o = t.floating;
  var c = i.x + i.width / 2 - o.width / 2,
    r = i.y + i.height / 2 - o.height / 2,
    s = K(e),
    l = at(s),
    a = i[l] / 2 - o[l] / 2,
    d = _(e),
    f = s === "x";
  var u;
  switch (d) {
    case "top":
      u = {
        x: c,
        y: i.y - o.height
      };
      break;
    case "bottom":
      u = {
        x: c,
        y: i.y + i.height
      };
      break;
    case "right":
      u = {
        x: i.x + i.width,
        y: r
      };
      break;
    case "left":
      u = {
        x: i.x - o.width,
        y: r
      };
      break;
    default:
      u = {
        x: i.x,
        y: i.y
      };
  }
  switch (V(e)) {
    case "start":
      u[s] -= a * (n && f ? -1 : 1);
      break;
    case "end":
      u[s] += a * (n && f ? -1 : 1);
      break;
  }
  return u;
}
var At = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(t, e, n) {
    var _n$placement, i, _n$strategy, o, _n$middleware, c, r, s, l, _tt, a, d, f, u, h, m, _c$m, p, w, _yield$w, y, g, v, x, _tt2;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _n$placement = n.placement;
          i = _n$placement === void 0 ? "bottom" : _n$placement;
          _n$strategy = n.strategy;
          o = _n$strategy === void 0 ? "absolute" : _n$strategy;
          _n$middleware = n.middleware;
          c = _n$middleware === void 0 ? [] : _n$middleware;
          r = n.platform;
          _context.next = 9;
          return r.isRTL == null ? void 0 : r.isRTL(e);
        case 9:
          s = _context.sent;
          _context.next = 12;
          return r.getElementRects({
            reference: t,
            floating: e,
            strategy: o
          });
        case 12:
          l = _context.sent;
          _tt = tt(l, i, s);
          a = _tt.x;
          d = _tt.y;
          f = i;
          u = {};
          h = 0;
          m = 0;
        case 20:
          if (!(m < c.length)) {
            _context.next = 52;
            break;
          }
          _c$m = c[m];
          p = _c$m.name;
          w = _c$m.fn;
          _context.next = 26;
          return w({
            x: a,
            y: d,
            initialPlacement: i,
            placement: f,
            strategy: o,
            middlewareData: u,
            rects: l,
            platform: r,
            elements: {
              reference: t,
              floating: e
            }
          });
        case 26:
          _yield$w = _context.sent;
          y = _yield$w.x;
          g = _yield$w.y;
          v = _yield$w.data;
          x = _yield$w.reset;
          if (!(a = y != null ? y : a, d = g != null ? g : d, u = _objectSpread(_objectSpread({}, u), {}, _defineProperty({}, p, _objectSpread(_objectSpread({}, u[p]), v))), x && h <= 50)) {
            _context.next = 49;
            break;
          }
          h++;
          _context.t0 = _typeof(x) == "object";
          if (!_context.t0) {
            _context.next = 47;
            break;
          }
          x.placement && (f = x.placement);
          _context.t1 = x.rects;
          if (!_context.t1) {
            _context.next = 46;
            break;
          }
          if (!(x.rects === !0)) {
            _context.next = 44;
            break;
          }
          _context.next = 41;
          return r.getElementRects({
            reference: t,
            floating: e,
            strategy: o
          });
        case 41:
          _context.t2 = _context.sent;
          _context.next = 45;
          break;
        case 44:
          _context.t2 = x.rects;
        case 45:
          l = _context.t2;
        case 46:
          _tt2 = tt(l, f, s), a = _tt2.x, d = _tt2.y;
        case 47:
          m = -1;
          return _context.abrupt("continue", 49);
        case 49:
          m++;
          _context.next = 20;
          break;
        case 52:
          return _context.abrupt("return", {
            x: a,
            y: d,
            placement: f,
            strategy: o,
            middlewareData: u
          });
        case 53:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function At(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();
function Lt(t) {
  return _objectSpread({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, t);
}
function Ot(t) {
  return typeof t != "number" ? Lt(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function I(t) {
  return _objectSpread(_objectSpread({}, t), {}, {
    top: t.y,
    left: t.x,
    right: t.x + t.width,
    bottom: t.y + t.height
  });
}
function Q(_x4, _x5) {
  return _Q.apply(this, arguments);
}
function _Q() {
  _Q = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(t, e) {
    var n, i, o, c, r, s, l, _e, _e$boundary, a, _e$rootBoundary, d, _e$elementContext, f, _e$altBoundary, u, _e$padding, h, m, w, y, g;
    return _regeneratorRuntime().wrap(function _callee11$(_context11) {
      while (1) switch (_context11.prev = _context11.next) {
        case 0:
          e === void 0 && (e = {});
          i = t.x;
          o = t.y;
          c = t.platform;
          r = t.rects;
          s = t.elements;
          l = t.strategy;
          _e = e;
          _e$boundary = _e.boundary;
          a = _e$boundary === void 0 ? "clippingAncestors" : _e$boundary;
          _e$rootBoundary = _e.rootBoundary;
          d = _e$rootBoundary === void 0 ? "viewport" : _e$rootBoundary;
          _e$elementContext = _e.elementContext;
          f = _e$elementContext === void 0 ? "floating" : _e$elementContext;
          _e$altBoundary = _e.altBoundary;
          u = _e$altBoundary === void 0 ? !1 : _e$altBoundary;
          _e$padding = _e.padding;
          h = _e$padding === void 0 ? 0 : _e$padding;
          m = Ot(h);
          w = s[u ? f === "floating" ? "reference" : "floating" : f];
          _context11.t0 = I;
          _context11.t1 = c;
          _context11.next = 24;
          return c.isElement == null ? void 0 : c.isElement(w);
        case 24:
          _context11.t3 = n = _context11.sent;
          _context11.t2 = _context11.t3 == null;
          if (_context11.t2) {
            _context11.next = 28;
            break;
          }
          _context11.t2 = n;
        case 28:
          if (!_context11.t2) {
            _context11.next = 32;
            break;
          }
          _context11.t4 = w;
          _context11.next = 38;
          break;
        case 32:
          _context11.t5 = w.contextElement;
          if (_context11.t5) {
            _context11.next = 37;
            break;
          }
          _context11.next = 36;
          return c.getDocumentElement == null ? void 0 : c.getDocumentElement(s.floating);
        case 36:
          _context11.t5 = _context11.sent;
        case 37:
          _context11.t4 = _context11.t5;
        case 38:
          _context11.t6 = _context11.t4;
          _context11.t7 = a;
          _context11.t8 = d;
          _context11.t9 = l;
          _context11.t10 = {
            element: _context11.t6,
            boundary: _context11.t7,
            rootBoundary: _context11.t8,
            strategy: _context11.t9
          };
          _context11.next = 45;
          return _context11.t1.getClippingRect.call(_context11.t1, _context11.t10);
        case 45:
          _context11.t11 = _context11.sent;
          y = (0, _context11.t0)(_context11.t11);
          _context11.t12 = I;
          if (!c.convertOffsetParentRelativeRectToViewportRelativeRect) {
            _context11.next = 61;
            break;
          }
          _context11.t14 = c;
          _context11.t15 = f === "floating" ? _objectSpread(_objectSpread({}, r.floating), {}, {
            x: i,
            y: o
          }) : r.reference;
          _context11.next = 53;
          return c.getOffsetParent == null ? void 0 : c.getOffsetParent(s.floating);
        case 53:
          _context11.t16 = _context11.sent;
          _context11.t17 = l;
          _context11.t18 = {
            rect: _context11.t15,
            offsetParent: _context11.t16,
            strategy: _context11.t17
          };
          _context11.next = 58;
          return _context11.t14.convertOffsetParentRelativeRectToViewportRelativeRect.call(_context11.t14, _context11.t18);
        case 58:
          _context11.t13 = _context11.sent;
          _context11.next = 62;
          break;
        case 61:
          _context11.t13 = r[f];
        case 62:
          _context11.t19 = _context11.t13;
          g = (0, _context11.t12)(_context11.t19);
          return _context11.abrupt("return", {
            top: y.top - g.top + m.top,
            bottom: g.bottom - y.bottom + m.bottom,
            left: y.left - g.left + m.left,
            right: g.right - y.right + m.right
          });
        case 65:
        case "end":
          return _context11.stop();
      }
    }, _callee11);
  }));
  return _Q.apply(this, arguments);
}
var Rt = Math.min,
  kt = Math.max;
function et(t, e, n) {
  return kt(t, Rt(e, n));
}
var Tt = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function z(t) {
  return t.replace(/left|right|bottom|top/g, function (e) {
    return Tt[e];
  });
}
function ft(t, e, n) {
  n === void 0 && (n = !1);
  var i = V(t),
    o = K(t),
    c = at(o);
  var r = o === "x" ? i === (n ? "end" : "start") ? "right" : "left" : i === "start" ? "bottom" : "top";
  return e.reference[c] > e.floating[c] && (r = z(r)), {
    main: r,
    cross: z(r)
  };
}
var Bt = {
  start: "end",
  end: "start"
};
function G(t) {
  return t.replace(/start|end/g, function (e) {
    return Bt[e];
  });
}
var St = ["top", "right", "bottom", "left"],
  Dt = /* @__PURE__ */St.reduce(function (t, e) {
    return t.concat(e, e + "-start", e + "-end");
  }, []);
function _t(t, e, n) {
  return (t ? [].concat(_toConsumableArray(n.filter(function (o) {
    return V(o) === t;
  })), _toConsumableArray(n.filter(function (o) {
    return V(o) !== t;
  }))) : n.filter(function (o) {
    return _(o) === o;
  })).filter(function (o) {
    return t ? V(o) === t || (e ? G(o) !== o : !1) : !0;
  });
}
var Vt = function Vt(t) {
  return t === void 0 && (t = {}), {
    name: "autoPlacement",
    options: t,
    fn: function fn(e) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var n, i, o, c, r, s, l, a, d, f, u, h, _t2, _t2$alignment, m, _t2$allowedPlacements, p, _t2$autoAlignment, w, y, g, v, x, b, _ft, M, H, j, E, B, S, F, D;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              s = e.x;
              l = e.y;
              a = e.rects;
              d = e.middlewareData;
              f = e.placement;
              u = e.platform;
              h = e.elements;
              _t2 = t;
              _t2$alignment = _t2.alignment;
              m = _t2$alignment === void 0 ? null : _t2$alignment;
              _t2$allowedPlacements = _t2.allowedPlacements;
              p = _t2$allowedPlacements === void 0 ? Dt : _t2$allowedPlacements;
              _t2$autoAlignment = _t2.autoAlignment;
              w = _t2$autoAlignment === void 0 ? !0 : _t2$autoAlignment;
              y = _objectWithoutProperties(_t2, _excluded);
              g = _t(m, w, p);
              _context2.next = 18;
              return Q(e, y);
            case 18:
              v = _context2.sent;
              x = (n = (i = d.autoPlacement) == null ? void 0 : i.index) != null ? n : 0;
              b = g[x];
              if (!(b == null)) {
                _context2.next = 23;
                break;
              }
              return _context2.abrupt("return", {});
            case 23:
              _context2.t0 = ft;
              _context2.t1 = b;
              _context2.t2 = a;
              _context2.next = 28;
              return u.isRTL == null ? void 0 : u.isRTL(h.floating);
            case 28:
              _context2.t3 = _context2.sent;
              _ft = (0, _context2.t0)(_context2.t1, _context2.t2, _context2.t3);
              M = _ft.main;
              H = _ft.cross;
              if (!(f !== b)) {
                _context2.next = 34;
                break;
              }
              return _context2.abrupt("return", {
                x: s,
                y: l,
                reset: {
                  placement: g[0]
                }
              });
            case 34:
              j = [v[_(b)], v[M], v[H]], E = [].concat(_toConsumableArray((o = (c = d.autoPlacement) == null ? void 0 : c.overflows) != null ? o : []), [{
                placement: b,
                overflows: j
              }]), B = g[x + 1];
              if (!B) {
                _context2.next = 37;
                break;
              }
              return _context2.abrupt("return", {
                data: {
                  index: x + 1,
                  overflows: E
                },
                reset: {
                  placement: B
                }
              });
            case 37:
              S = E.slice().sort(function (A, $) {
                return A.overflows[0] - $.overflows[0];
              }), F = (r = S.find(function (A) {
                var $ = A.overflows;
                return $.every(function (yt) {
                  return yt <= 0;
                });
              })) == null ? void 0 : r.placement, D = F != null ? F : S[0].placement;
              return _context2.abrupt("return", D !== f ? {
                data: {
                  index: x + 1,
                  overflows: E
                },
                reset: {
                  placement: D
                }
              } : {});
            case 39:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }))();
    }
  };
};
function Nt(t) {
  var e = z(t);
  return [G(t), e, G(e)];
}
var Ft = function Ft(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    fn: function fn(e) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var n, i, o, c, r, s, l, _t3, _t3$mainAxis, a, _t3$crossAxis, d, f, _t3$fallbackStrategy, u, _t3$flipAlignment, h, m, p, y, g, v, x, b, _ft2, E, B, M, H, _E, _B, S, j, F;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              i = e.placement;
              o = e.middlewareData;
              c = e.rects;
              r = e.initialPlacement;
              s = e.platform;
              l = e.elements;
              _t3 = t;
              _t3$mainAxis = _t3.mainAxis;
              a = _t3$mainAxis === void 0 ? !0 : _t3$mainAxis;
              _t3$crossAxis = _t3.crossAxis;
              d = _t3$crossAxis === void 0 ? !0 : _t3$crossAxis;
              f = _t3.fallbackPlacements;
              _t3$fallbackStrategy = _t3.fallbackStrategy;
              u = _t3$fallbackStrategy === void 0 ? "bestFit" : _t3$fallbackStrategy;
              _t3$flipAlignment = _t3.flipAlignment;
              h = _t3$flipAlignment === void 0 ? !0 : _t3$flipAlignment;
              m = _objectWithoutProperties(_t3, _excluded2);
              p = _(i);
              y = f || (p === r || !h ? [z(r)] : Nt(r));
              g = [r].concat(_toConsumableArray(y));
              _context3.next = 22;
              return Q(e, m);
            case 22:
              v = _context3.sent;
              x = [];
              b = ((n = o.flip) == null ? void 0 : n.overflows) || [];
              if (!(a && x.push(v[p]), d)) {
                _context3.next = 36;
                break;
              }
              _context3.t0 = ft;
              _context3.t1 = i;
              _context3.t2 = c;
              _context3.next = 31;
              return s.isRTL == null ? void 0 : s.isRTL(l.floating);
            case 31:
              _context3.t3 = _context3.sent;
              _ft2 = (0, _context3.t0)(_context3.t1, _context3.t2, _context3.t3);
              E = _ft2.main;
              B = _ft2.cross;
              x.push(v[E], v[B]);
            case 36:
              if (!(b = [].concat(_toConsumableArray(b), [{
                placement: i,
                overflows: x
              }]), !x.every(function (E) {
                return E <= 0;
              }))) {
                _context3.next = 51;
                break;
              }
              _E = ((M = (H = o.flip) == null ? void 0 : H.index) != null ? M : 0) + 1, _B = g[_E];
              if (!_B) {
                _context3.next = 40;
                break;
              }
              return _context3.abrupt("return", {
                data: {
                  index: _E,
                  overflows: b
                },
                reset: {
                  placement: _B
                }
              });
            case 40:
              S = "bottom";
              _context3.t4 = u;
              _context3.next = _context3.t4 === "bestFit" ? 44 : _context3.t4 === "initialPlacement" ? 47 : 49;
              break;
            case 44:
              F = (j = b.map(function (D) {
                return [D, D.overflows.filter(function (A) {
                  return A > 0;
                }).reduce(function (A, $) {
                  return A + $;
                }, 0)];
              }).sort(function (D, A) {
                return D[1] - A[1];
              })[0]) == null ? void 0 : j[0].placement;
              F && (S = F);
              return _context3.abrupt("break", 49);
            case 47:
              S = r;
              return _context3.abrupt("break", 49);
            case 49:
              if (!(i !== S)) {
                _context3.next = 51;
                break;
              }
              return _context3.abrupt("return", {
                reset: {
                  placement: S
                }
              });
            case 51:
              return _context3.abrupt("return", {});
            case 52:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }))();
    }
  };
};
function $t(_x6, _x7) {
  return _$t.apply(this, arguments);
}
function _$t() {
  _$t = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(t, e) {
    var n, i, o, c, r, s, l, a, d, f, _ref5, u, h, m;
    return _regeneratorRuntime().wrap(function _callee12$(_context12) {
      while (1) switch (_context12.prev = _context12.next) {
        case 0:
          n = t.placement;
          i = t.platform;
          o = t.elements;
          _context12.next = 5;
          return i.isRTL == null ? void 0 : i.isRTL(o.floating);
        case 5:
          c = _context12.sent;
          r = _(n);
          s = V(n);
          l = K(n) === "x";
          a = ["left", "top"].includes(r) ? -1 : 1;
          d = c && l ? -1 : 1;
          f = typeof e == "function" ? e(t) : e;
          _ref5 = typeof f == "number" ? {
            mainAxis: f,
            crossAxis: 0,
            alignmentAxis: null
          } : _objectSpread({
            mainAxis: 0,
            crossAxis: 0,
            alignmentAxis: null
          }, f), u = _ref5.mainAxis, h = _ref5.crossAxis, m = _ref5.alignmentAxis;
          return _context12.abrupt("return", (s && typeof m == "number" && (h = s === "end" ? m * -1 : m), l ? {
            x: h * d,
            y: u * a
          } : {
            x: u * a,
            y: h * d
          }));
        case 14:
        case "end":
          return _context12.stop();
      }
    }, _callee12);
  }));
  return _$t.apply(this, arguments);
}
var nt = function nt(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    fn: function fn(e) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        var n, i, o;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              n = e.x;
              i = e.y;
              _context4.next = 4;
              return $t(e, t);
            case 4:
              o = _context4.sent;
              return _context4.abrupt("return", {
                x: n + o.x,
                y: i + o.y,
                data: o
              });
            case 6:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }))();
    }
  };
};
function Wt(t) {
  return t === "x" ? "y" : "x";
}
var ot = function ot(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    fn: function fn(e) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var n, i, o, _t4, _t4$mainAxis, c, _t4$crossAxis, r, _t4$limiter, s, l, a, d, f, u, h, m, w, y, g, v, _w, _y, _g, _v, p;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              n = e.x;
              i = e.y;
              o = e.placement;
              _t4 = t;
              _t4$mainAxis = _t4.mainAxis;
              c = _t4$mainAxis === void 0 ? !0 : _t4$mainAxis;
              _t4$crossAxis = _t4.crossAxis;
              r = _t4$crossAxis === void 0 ? !1 : _t4$crossAxis;
              _t4$limiter = _t4.limiter;
              s = _t4$limiter === void 0 ? {
                fn: function fn(w) {
                  var y = w.x,
                    g = w.y;
                  return {
                    x: y,
                    y: g
                  };
                }
              } : _t4$limiter;
              l = _objectWithoutProperties(_t4, _excluded3);
              a = {
                x: n,
                y: i
              };
              _context5.next = 14;
              return Q(e, l);
            case 14:
              d = _context5.sent;
              f = K(_(o));
              u = Wt(f);
              h = a[f], m = a[u];
              if (c) {
                w = f === "y" ? "top" : "left", y = f === "y" ? "bottom" : "right", g = h + d[w], v = h - d[y];
                h = et(g, h, v);
              }
              if (r) {
                _w = u === "y" ? "top" : "left", _y = u === "y" ? "bottom" : "right", _g = m + d[_w], _v = m - d[_y];
                m = et(_g, m, _v);
              }
              p = s.fn(_objectSpread(_objectSpread({}, e), {}, _defineProperty(_defineProperty({}, f, h), u, m)));
              return _context5.abrupt("return", _objectSpread(_objectSpread({}, p), {}, {
                data: {
                  x: p.x - n,
                  y: p.y - i
                }
              }));
            case 22:
            case "end":
              return _context5.stop();
          }
        }, _callee5);
      }))();
    }
  };
};
function ut(t) {
  return t && t.document && t.location && t.alert && t.setInterval;
}
function R(t) {
  if (t == null) return window;
  if (!ut(t)) {
    var e = t.ownerDocument;
    return e && e.defaultView || window;
  }
  return t;
}
function C(t) {
  return R(t).getComputedStyle(t);
}
function L(t) {
  return ut(t) ? "" : t ? (t.nodeName || "").toLowerCase() : "";
}
function dt() {
  var t = navigator.userAgentData;
  return t != null && t.brands ? t.brands.map(function (e) {
    return e.brand + "/" + e.version;
  }).join(" ") : navigator.userAgent;
}
function P(t) {
  return t instanceof R(t).HTMLElement;
}
function k(t) {
  return t instanceof R(t).Element;
}
function Mt(t) {
  return t instanceof R(t).Node;
}
function N(t) {
  if ((typeof ShadowRoot === "undefined" ? "undefined" : _typeof(ShadowRoot)) > "u") return !1;
  var e = R(t).ShadowRoot;
  return t instanceof e || t instanceof ShadowRoot;
}
function U(t) {
  var _C = C(t),
    e = _C.overflow,
    n = _C.overflowX,
    i = _C.overflowY;
  return /auto|scroll|overlay|hidden/.test(e + i + n);
}
function Ht(t) {
  return ["table", "td", "th"].includes(L(t));
}
function pt(t) {
  var e = /firefox/i.test(dt()),
    n = C(t);
  return n.transform !== "none" || n.perspective !== "none" || n.contain === "paint" || ["transform", "perspective"].includes(n.willChange) || e && n.willChange === "filter" || e && (n.filter ? n.filter !== "none" : !1);
}
function ht() {
  return !/^((?!chrome|android).)*safari/i.test(dt());
}
var it = Math.min,
  W = Math.max,
  X = Math.round;
function O(t, e, n) {
  var i, o, c, r;
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  var s = t.getBoundingClientRect();
  var l = 1,
    a = 1;
  e && P(t) && (l = t.offsetWidth > 0 && X(s.width) / t.offsetWidth || 1, a = t.offsetHeight > 0 && X(s.height) / t.offsetHeight || 1);
  var d = k(t) ? R(t) : window,
    f = !ht() && n,
    u = (s.left + (f && (i = (o = d.visualViewport) == null ? void 0 : o.offsetLeft) != null ? i : 0)) / l,
    h = (s.top + (f && (c = (r = d.visualViewport) == null ? void 0 : r.offsetTop) != null ? c : 0)) / a,
    m = s.width / l,
    p = s.height / a;
  return {
    width: m,
    height: p,
    top: h,
    right: u + m,
    bottom: h + p,
    left: u,
    x: u,
    y: h
  };
}
function T(t) {
  return ((Mt(t) ? t.ownerDocument : t.document) || window.document).documentElement;
}
function q(t) {
  return k(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.pageXOffset,
    scrollTop: t.pageYOffset
  };
}
function mt(t) {
  return O(T(t)).left + q(t).scrollLeft;
}
function jt(t) {
  var e = O(t);
  return X(e.width) !== t.offsetWidth || X(e.height) !== t.offsetHeight;
}
function It(t, e, n) {
  var i = P(e),
    o = T(e),
    c = O(t, i && jt(e), n === "fixed");
  var r = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var s = {
    x: 0,
    y: 0
  };
  if (i || !i && n !== "fixed") if ((L(e) !== "body" || U(o)) && (r = q(e)), P(e)) {
    var l = O(e, !0);
    s.x = l.x + e.clientLeft, s.y = l.y + e.clientTop;
  } else o && (s.x = mt(o));
  return {
    x: c.left + r.scrollLeft - s.x,
    y: c.top + r.scrollTop - s.y,
    width: c.width,
    height: c.height
  };
}
function gt(t) {
  return L(t) === "html" ? t : t.assignedSlot || t.parentNode || (N(t) ? t.host : null) || T(t);
}
function st(t) {
  return !P(t) || C(t).position === "fixed" ? null : zt(t);
}
function zt(t) {
  var e = t.offsetParent,
    n = t,
    i = !1;
  for (; n && n !== e;) {
    var _n = n,
      o = _n.assignedSlot;
    if (o) {
      var c = o.offsetParent;
      if (C(o).display === "contents") {
        var r = o.hasAttribute("style"),
          s = o.style.display;
        o.style.display = C(n).display, c = o.offsetParent, o.style.display = s, r || o.removeAttribute("style");
      }
      n = o, e !== c && (e = c, i = !0);
    } else if (N(n) && n.host && i) break;
    n = N(n) && n.host || n.parentNode;
  }
  return e;
}
function Xt(t) {
  var e = gt(t);
  for (N(e) && (e = e.host); P(e) && !["html", "body"].includes(L(e));) {
    if (pt(e)) return e;
    {
      var n = e.parentNode;
      e = N(n) ? n.host : n;
    }
  }
  return null;
}
function J(t) {
  var e = R(t);
  var n = st(t);
  for (; n && Ht(n) && C(n).position === "static";) n = st(n);
  return n && (L(n) === "html" || L(n) === "body" && C(n).position === "static" && !pt(n)) ? e : n || Xt(t) || e;
}
function rt(t) {
  if (P(t)) return {
    width: t.offsetWidth,
    height: t.offsetHeight
  };
  var e = O(t);
  return {
    width: e.width,
    height: e.height
  };
}
function Yt(t) {
  var e = t.rect,
    n = t.offsetParent,
    i = t.strategy;
  var o = P(n),
    c = T(n);
  if (n === c) return e;
  var r = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var s = {
    x: 0,
    y: 0
  };
  if ((o || !o && i !== "fixed") && ((L(n) !== "body" || U(c)) && (r = q(n)), P(n))) {
    var l = O(n, !0);
    s.x = l.x + n.clientLeft, s.y = l.y + n.clientTop;
  }
  return _objectSpread(_objectSpread({}, e), {}, {
    x: e.x - r.scrollLeft + s.x,
    y: e.y - r.scrollTop + s.y
  });
}
function Kt(t, e) {
  var n = R(t),
    i = T(t),
    o = n.visualViewport;
  var c = i.clientWidth,
    r = i.clientHeight,
    s = 0,
    l = 0;
  if (o) {
    c = o.width, r = o.height;
    var a = ht();
    (a || !a && e === "fixed") && (s = o.offsetLeft, l = o.offsetTop);
  }
  return {
    width: c,
    height: r,
    x: s,
    y: l
  };
}
function Ut(t) {
  var e;
  var n = T(t),
    i = q(t),
    o = (e = t.ownerDocument) == null ? void 0 : e.body,
    c = W(n.scrollWidth, n.clientWidth, o ? o.scrollWidth : 0, o ? o.clientWidth : 0),
    r = W(n.scrollHeight, n.clientHeight, o ? o.scrollHeight : 0, o ? o.clientHeight : 0);
  var s = -i.scrollLeft + mt(t);
  var l = -i.scrollTop;
  return C(o || n).direction === "rtl" && (s += W(n.clientWidth, o ? o.clientWidth : 0) - c), {
    width: c,
    height: r,
    x: s,
    y: l
  };
}
function wt(t) {
  var e = gt(t);
  return ["html", "body", "#document"].includes(L(e)) ? t.ownerDocument.body : P(e) && U(e) ? e : wt(e);
}
function Y(t, e) {
  var n;
  e === void 0 && (e = []);
  var i = wt(t),
    o = i === ((n = t.ownerDocument) == null ? void 0 : n.body),
    c = R(i),
    r = o ? [c].concat(c.visualViewport || [], U(i) ? i : []) : i,
    s = e.concat(r);
  return o ? s : s.concat(Y(r));
}
function qt(t, e) {
  var n = e.getRootNode == null ? void 0 : e.getRootNode();
  if (t.contains(e)) return !0;
  if (n && N(n)) {
    var i = e;
    do {
      if (i && t === i) return !0;
      i = i.parentNode || i.host;
    } while (i);
  }
  return !1;
}
function Gt(t, e) {
  var n = O(t, !1, e === "fixed"),
    i = n.top + t.clientTop,
    o = n.left + t.clientLeft;
  return {
    top: i,
    left: o,
    x: o,
    y: i,
    right: o + t.clientWidth,
    bottom: i + t.clientHeight,
    width: t.clientWidth,
    height: t.clientHeight
  };
}
function ct(t, e, n) {
  return e === "viewport" ? I(Kt(t, n)) : k(e) ? Gt(e, n) : I(Ut(T(t)));
}
function Jt(t) {
  var e = Y(t),
    i = ["absolute", "fixed"].includes(C(t).position) && P(t) ? J(t) : t;
  return k(i) ? e.filter(function (o) {
    return k(o) && qt(o, i) && L(o) !== "body";
  }) : [];
}
function Qt(t) {
  var e = t.element,
    n = t.boundary,
    i = t.rootBoundary,
    o = t.strategy;
  var r = [].concat(_toConsumableArray(n === "clippingAncestors" ? Jt(e) : [].concat(n)), [i]),
    s = r[0],
    l = r.reduce(function (a, d) {
      var f = ct(e, d, o);
      return a.top = W(f.top, a.top), a.right = it(f.right, a.right), a.bottom = it(f.bottom, a.bottom), a.left = W(f.left, a.left), a;
    }, ct(e, s, o));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
var Zt = {
  getClippingRect: Qt,
  convertOffsetParentRelativeRectToViewportRelativeRect: Yt,
  isElement: k,
  getDimensions: rt,
  getOffsetParent: J,
  getDocumentElement: T,
  getElementRects: function getElementRects(t) {
    var e = t.reference,
      n = t.floating,
      i = t.strategy;
    return {
      reference: It(e, J(n), i),
      floating: _objectSpread(_objectSpread({}, rt(n)), {}, {
        x: 0,
        y: 0
      })
    };
  },
  getClientRects: function getClientRects(t) {
    return Array.from(t.getClientRects());
  },
  isRTL: function isRTL(t) {
    return C(t).direction === "rtl";
  }
};
function te(t, e, n, i) {
  i === void 0 && (i = {});
  var _i = i,
    _i$ancestorScroll = _i.ancestorScroll,
    o = _i$ancestorScroll === void 0 ? !0 : _i$ancestorScroll,
    _i$ancestorResize = _i.ancestorResize,
    c = _i$ancestorResize === void 0 ? !0 : _i$ancestorResize,
    _i$elementResize = _i.elementResize,
    r = _i$elementResize === void 0 ? !0 : _i$elementResize,
    _i$animationFrame = _i.animationFrame,
    s = _i$animationFrame === void 0 ? !1 : _i$animationFrame,
    l = o && !s,
    a = c && !s,
    d = l || a ? [].concat(_toConsumableArray(k(t) ? Y(t) : []), _toConsumableArray(Y(e))) : [];
  d.forEach(function (p) {
    l && p.addEventListener("scroll", n, {
      passive: !0
    }), a && p.addEventListener("resize", n);
  });
  var f = null;
  if (r) {
    var p = !0;
    f = new ResizeObserver(function () {
      p || n(), p = !1;
    }), k(t) && !s && f.observe(t), f.observe(e);
  }
  var u,
    h = s ? O(t) : null;
  s && m();
  function m() {
    var p = O(t);
    h && (p.x !== h.x || p.y !== h.y || p.width !== h.width || p.height !== h.height) && n(), h = p, u = requestAnimationFrame(m);
  }
  return n(), function () {
    var p;
    d.forEach(function (w) {
      l && w.removeEventListener("scroll", n), a && w.removeEventListener("resize", n);
    }), (p = f) == null || p.disconnect(), f = null, s && cancelAnimationFrame(u);
  };
}
var ee = function ee(t, e, n) {
  return At(t, e, _objectSpread({
    platform: Zt
  }, n));
};
function ne(_x8, _x9, _x10, _x11) {
  return _ne.apply(this, arguments);
}
function _ne() {
  _ne = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(t, e, n, i) {
    return _regeneratorRuntime().wrap(function _callee13$(_context13) {
      while (1) switch (_context13.prev = _context13.next) {
        case 0:
          if (i) {
            _context13.next = 2;
            break;
          }
          throw new Error("Must provide a positioning option");
        case 2:
          _context13.next = 4;
          return typeof i == "string" ? oe(t, e, n, i) : ie(e, i);
        case 4:
          return _context13.abrupt("return", _context13.sent);
        case 5:
        case "end":
          return _context13.stop();
      }
    }, _callee13);
  }));
  return _ne.apply(this, arguments);
}
function oe(_x12, _x13, _x14, _x15) {
  return _oe.apply(this, arguments);
}
function _oe() {
  _oe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(t, e, n, i) {
    var o;
    return _regeneratorRuntime().wrap(function _callee15$(_context15) {
      while (1) switch (_context15.prev = _context15.next) {
        case 0:
          if (n) {
            _context15.next = 2;
            break;
          }
          throw new Error("Reference element is required for relative positioning");
        case 2:
          return _context15.abrupt("return", (i === "auto" ? o = {
            middleware: [Vt(), ot(), nt({
              mainAxis: 5,
              crossAxis: 12
            })]
          } : o = {
            placement: i,
            middleware: [Ft(), ot(), nt(5)]
          }, te(n, e, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
            var _yield$ee, c, r;
            return _regeneratorRuntime().wrap(function _callee14$(_context14) {
              while (1) switch (_context14.prev = _context14.next) {
                case 0:
                  if (!((!n.isConnected || !n.offsetParent) && se(t))) {
                    _context14.next = 2;
                    break;
                  }
                  return _context14.abrupt("return");
                case 2:
                  _context14.next = 4;
                  return ee(n, e, o);
                case 4:
                  _yield$ee = _context14.sent;
                  c = _yield$ee.x;
                  r = _yield$ee.y;
                  Object.assign(e.style, {
                    position: "absolute",
                    left: "".concat(c, "px"),
                    top: "".concat(r, "px")
                  });
                case 8:
                case "end":
                  return _context14.stop();
              }
            }, _callee14);
          })))));
        case 3:
        case "end":
          return _context15.stop();
      }
    }, _callee15);
  }));
  return _oe.apply(this, arguments);
}
function ie(t, e) {
  return t.style.position = "fixed", Object.entries(e).forEach(function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
      n = _ref3[0],
      i = _ref3[1];
    t.style[n] = i;
  }), function () {};
}
function se(t) {
  switch (t.options.onPositionLost) {
    case "close":
      return t.close(), !0;
    case "destroy":
      return t.destroy(), !0;
    case "hold":
      return !0;
  }
}
var re = {
  hideOnClickOutside: !0,
  hideOnEmojiSelect: !0,
  hideOnEscape: !0,
  position: "auto",
  showCloseButton: !0,
  onPositionLost: "none"
};
function ce() {
  var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return _objectSpread(_objectSpread({}, re), {}, {
    rootElement: document.body
  }, t);
}
var le = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>',
  lt = (0,picmo__WEBPACK_IMPORTED_MODULE_0__.getPrefixedClasses)("popupContainer", "closeButton");
var ae = /*#__PURE__*/function () {
  function ae(e, n) {
    var _this = this;
    _classCallCheck(this, ae);
    this.isOpen = !1, this.externalEvents = new picmo__WEBPACK_IMPORTED_MODULE_0__.Events(), this.options = _objectSpread(_objectSpread({}, ce(n)), (0,picmo__WEBPACK_IMPORTED_MODULE_0__.getOptions)(e)), this.popupEl = document.createElement("div"), this.popupEl.classList.add(lt.popupContainer), this.popupEl.classList.add(this.options.theme), n.className && this.popupEl.classList.add(n.className), this.options.showCloseButton && (this.closeButton = document.createElement("button"), this.closeButton.type = "button", this.closeButton.classList.add(lt.closeButton), this.closeButton.innerHTML = le, this.closeButton.addEventListener("click", function () {
      _this.close();
    }), this.popupEl.appendChild(this.closeButton));
    var i = document.createElement("div");
    this.popupEl.appendChild(i), this.picker = (0,picmo__WEBPACK_IMPORTED_MODULE_0__.createPicker)(_objectSpread(_objectSpread({}, this.options), {}, {
      rootElement: i
    })), this.focusTrap = new picmo__WEBPACK_IMPORTED_MODULE_0__.FocusTrap(), this.picker.addEventListener("data:ready", function () {
      _this.focusTrap.activate(_this.picker.el), _this.picker.setInitialFocus();
    }), this.options.hideOnEmojiSelect && this.picker.addEventListener("emoji:select", function () {
      var o;
      _this.close(), (o = _this.triggerElement) == null || o.focus();
    }), this.options.hideOnClickOutside && (this.onDocumentClick = this.onDocumentClick.bind(this), document.addEventListener("click", this.onDocumentClick)), this.options.hideOnEscape && (this.handleKeydown = this.handleKeydown.bind(this), this.popupEl.addEventListener("keydown", this.handleKeydown)), this.referenceElement = this.options.referenceElement, this.triggerElement = this.options.triggerElement;
  }
  _createClass(ae, [{
    key: "addEventListener",
    value: function addEventListener(e, n) {
      this.externalEvents.on(e, n), this.picker.addEventListener(e, n);
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(e, n) {
      this.externalEvents.off(e, n), this.picker.removeEventListener(e, n);
    }
  }, {
    key: "handleKeydown",
    value: function handleKeydown(e) {
      var n;
      e.key === "Escape" && (this.close(), (n = this.triggerElement) == null || n.focus());
    }
  }, {
    key: "destroy",
    value: function () {
      var _destroy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.t0 = this.isOpen;
              if (!_context6.t0) {
                _context6.next = 4;
                break;
              }
              _context6.next = 4;
              return this.close();
            case 4:
              document.removeEventListener("click", this.onDocumentClick);
              this.picker.destroy();
              this.externalEvents.removeAll();
            case 7:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function destroy() {
        return _destroy.apply(this, arguments);
      }
      return destroy;
    }()
  }, {
    key: "toggle",
    value: function toggle(e) {
      return this.isOpen ? this.close() : this.open(e);
    }
  }, {
    key: "open",
    value: function () {
      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        var _ref4,
          e,
          n,
          _args7 = arguments;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _ref4 = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {}, e = _ref4.triggerElement, n = _ref4.referenceElement;
              _context7.t0 = this.isOpen;
              if (_context7.t0) {
                _context7.next = 18;
                break;
              }
              e && (this.triggerElement = e);
              n && (this.referenceElement = n);
              _context7.next = 7;
              return this.initiateOpenStateChange(!0);
            case 7:
              this.popupEl.style.opacity = "0";
              this.options.rootElement.appendChild(this.popupEl);
              _context7.next = 11;
              return this.setPosition();
            case 11:
              this.picker.reset(!1);
              _context7.next = 14;
              return this.animatePopup(!0);
            case 14:
              _context7.next = 16;
              return this.animateCloseButton(!0);
            case 16:
              this.picker.setInitialFocus();
              this.externalEvents.emit("picker:open");
            case 18:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function open() {
        return _open.apply(this, arguments);
      }
      return open;
    }()
  }, {
    key: "close",
    value: function () {
      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        var e;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.t0 = !this.isOpen;
              if (_context8.t0) {
                _context8.next = 13;
                break;
              }
              _context8.next = 4;
              return this.initiateOpenStateChange(!1);
            case 4:
              _context8.next = 6;
              return this.animateCloseButton(!1);
            case 6:
              _context8.next = 8;
              return this.animatePopup(!1);
            case 8:
              this.popupEl.remove();
              this.picker.reset();
              (e = this.positionCleanup) == null || e.call(this);
              this.focusTrap.deactivate();
              this.externalEvents.emit("picker:close");
            case 13:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function close() {
        return _close.apply(this, arguments);
      }
      return close;
    }()
  }, {
    key: "getRunningAnimations",
    value: function getRunningAnimations() {
      return this.picker.el.getAnimations().filter(function (e) {
        return e.playState === "running";
      });
    }
  }, {
    key: "setPosition",
    value: function () {
      var _setPosition = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        var e;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              (e = this.positionCleanup) == null || e.call(this);
              _context9.next = 3;
              return ne(this, this.popupEl, this.referenceElement, this.options.position);
            case 3:
              this.positionCleanup = _context9.sent;
            case 4:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function setPosition() {
        return _setPosition.apply(this, arguments);
      }
      return setPosition;
    }()
  }, {
    key: "awaitPendingAnimations",
    value: function awaitPendingAnimations() {
      return Promise.all(this.getRunningAnimations().map(function (e) {
        return e.finished;
      }));
    }
  }, {
    key: "onDocumentClick",
    value: function onDocumentClick(e) {
      var o;
      var n = e.target,
        i = (o = this.triggerElement) == null ? void 0 : o.contains(n);
      this.isOpen && !this.picker.isPickerClick(e) && !i && this.close();
    }
  }, {
    key: "animatePopup",
    value: function animatePopup(e) {
      return (0,picmo__WEBPACK_IMPORTED_MODULE_0__.animate)(this.popupEl, {
        opacity: [0, 1],
        transform: ["scale(0.9)", "scale(1)"]
      }, {
        duration: 150,
        id: e ? "show-picker" : "hide-picker",
        easing: "ease-in-out",
        direction: e ? "normal" : "reverse",
        fill: "both"
      }, this.options);
    }
  }, {
    key: "animateCloseButton",
    value: function animateCloseButton(e) {
      if (this.closeButton) return (0,picmo__WEBPACK_IMPORTED_MODULE_0__.animate)(this.closeButton, {
        opacity: [0, 1]
      }, {
        duration: 25,
        id: e ? "show-close" : "hide-close",
        easing: "ease-in-out",
        direction: e ? "normal" : "reverse",
        fill: "both"
      }, this.options);
    }
  }, {
    key: "initiateOpenStateChange",
    value: function () {
      var _initiateOpenStateChange = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(e) {
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              this.isOpen = e;
              _context10.next = 3;
              return this.awaitPendingAnimations();
            case 3:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function initiateOpenStateChange(_x16) {
        return _initiateOpenStateChange.apply(this, arguments);
      }
      return initiateOpenStateChange;
    }()
  }]);
  return ae;
}();
var fe = ".picmo__popupContainer{display:flex;flex-direction:column;position:absolute}.picmo__popupContainer .picmo__closeButton{position:absolute;opacity:0;background:transparent;border:none;z-index:1;right:0;top:0;cursor:pointer;padding:4px;align-self:flex-end;transform:translate(50%,-50%);background:#999999;width:1.5rem;height:1.5rem;display:flex;align-items:center;justify-content:center;border-radius:50%}.picmo__popupContainer .picmo__closeButton:hover{background:var(--accent-color)}.picmo__popupContainer .picmo__closeButton svg{fill:#fff;width:1.25rem;height:1.25rem}\n",
  ue = (0,picmo__WEBPACK_IMPORTED_MODULE_0__.createStyleInjector)();
function pe(t, e) {
  return ue(fe), new ae(_objectSpread({
    autoFocus: "auto"
  }, t), e);
}


/***/ }),

/***/ "./node_modules/@tiptap/core/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@tiptap/core/dist/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CommandManager: function() { return /* binding */ CommandManager; },
/* harmony export */   Editor: function() { return /* binding */ Editor; },
/* harmony export */   Extension: function() { return /* binding */ Extension; },
/* harmony export */   InputRule: function() { return /* binding */ InputRule; },
/* harmony export */   Mark: function() { return /* binding */ Mark; },
/* harmony export */   Node: function() { return /* binding */ Node; },
/* harmony export */   NodeView: function() { return /* binding */ NodeView; },
/* harmony export */   PasteRule: function() { return /* binding */ PasteRule; },
/* harmony export */   Tracker: function() { return /* binding */ Tracker; },
/* harmony export */   callOrReturn: function() { return /* binding */ callOrReturn; },
/* harmony export */   combineTransactionSteps: function() { return /* binding */ combineTransactionSteps; },
/* harmony export */   createChainableState: function() { return /* binding */ createChainableState; },
/* harmony export */   createDocument: function() { return /* binding */ createDocument; },
/* harmony export */   createNodeFromContent: function() { return /* binding */ createNodeFromContent; },
/* harmony export */   createStyleTag: function() { return /* binding */ createStyleTag; },
/* harmony export */   defaultBlockAt: function() { return /* binding */ defaultBlockAt; },
/* harmony export */   deleteProps: function() { return /* binding */ deleteProps; },
/* harmony export */   elementFromString: function() { return /* binding */ elementFromString; },
/* harmony export */   escapeForRegEx: function() { return /* binding */ escapeForRegEx; },
/* harmony export */   extensions: function() { return /* binding */ extensions; },
/* harmony export */   findChildren: function() { return /* binding */ findChildren; },
/* harmony export */   findChildrenInRange: function() { return /* binding */ findChildrenInRange; },
/* harmony export */   findDuplicates: function() { return /* binding */ findDuplicates; },
/* harmony export */   findParentNode: function() { return /* binding */ findParentNode; },
/* harmony export */   findParentNodeClosestToPos: function() { return /* binding */ findParentNodeClosestToPos; },
/* harmony export */   fromString: function() { return /* binding */ fromString; },
/* harmony export */   generateHTML: function() { return /* binding */ generateHTML; },
/* harmony export */   generateJSON: function() { return /* binding */ generateJSON; },
/* harmony export */   generateText: function() { return /* binding */ generateText; },
/* harmony export */   getAttributes: function() { return /* binding */ _getAttributes; },
/* harmony export */   getAttributesFromExtensions: function() { return /* binding */ getAttributesFromExtensions; },
/* harmony export */   getChangedRanges: function() { return /* binding */ getChangedRanges; },
/* harmony export */   getDebugJSON: function() { return /* binding */ getDebugJSON; },
/* harmony export */   getExtensionField: function() { return /* binding */ getExtensionField; },
/* harmony export */   getHTMLFromFragment: function() { return /* binding */ getHTMLFromFragment; },
/* harmony export */   getMarkAttributes: function() { return /* binding */ getMarkAttributes; },
/* harmony export */   getMarkRange: function() { return /* binding */ getMarkRange; },
/* harmony export */   getMarkType: function() { return /* binding */ getMarkType; },
/* harmony export */   getMarksBetween: function() { return /* binding */ getMarksBetween; },
/* harmony export */   getNodeAtPosition: function() { return /* binding */ getNodeAtPosition; },
/* harmony export */   getNodeAttributes: function() { return /* binding */ getNodeAttributes; },
/* harmony export */   getNodeType: function() { return /* binding */ getNodeType; },
/* harmony export */   getRenderedAttributes: function() { return /* binding */ getRenderedAttributes; },
/* harmony export */   getSchema: function() { return /* binding */ getSchema; },
/* harmony export */   getSchemaByResolvedExtensions: function() { return /* binding */ getSchemaByResolvedExtensions; },
/* harmony export */   getSchemaTypeByName: function() { return /* binding */ getSchemaTypeByName; },
/* harmony export */   getSchemaTypeNameByName: function() { return /* binding */ getSchemaTypeNameByName; },
/* harmony export */   getSplittedAttributes: function() { return /* binding */ getSplittedAttributes; },
/* harmony export */   getText: function() { return /* binding */ _getText; },
/* harmony export */   getTextBetween: function() { return /* binding */ getTextBetween; },
/* harmony export */   getTextContentFromNodes: function() { return /* binding */ getTextContentFromNodes; },
/* harmony export */   getTextSerializersFromSchema: function() { return /* binding */ getTextSerializersFromSchema; },
/* harmony export */   injectExtensionAttributesToParseRule: function() { return /* binding */ injectExtensionAttributesToParseRule; },
/* harmony export */   inputRulesPlugin: function() { return /* binding */ inputRulesPlugin; },
/* harmony export */   isActive: function() { return /* binding */ _isActive; },
/* harmony export */   isAtEndOfNode: function() { return /* binding */ isAtEndOfNode; },
/* harmony export */   isAtStartOfNode: function() { return /* binding */ isAtStartOfNode; },
/* harmony export */   isEmptyObject: function() { return /* binding */ isEmptyObject; },
/* harmony export */   isExtensionRulesEnabled: function() { return /* binding */ isExtensionRulesEnabled; },
/* harmony export */   isFunction: function() { return /* binding */ isFunction; },
/* harmony export */   isList: function() { return /* binding */ isList; },
/* harmony export */   isMacOS: function() { return /* binding */ isMacOS; },
/* harmony export */   isMarkActive: function() { return /* binding */ isMarkActive; },
/* harmony export */   isNodeActive: function() { return /* binding */ isNodeActive; },
/* harmony export */   isNodeEmpty: function() { return /* binding */ isNodeEmpty; },
/* harmony export */   isNodeSelection: function() { return /* binding */ isNodeSelection; },
/* harmony export */   isNumber: function() { return /* binding */ isNumber; },
/* harmony export */   isPlainObject: function() { return /* binding */ isPlainObject; },
/* harmony export */   isRegExp: function() { return /* binding */ isRegExp; },
/* harmony export */   isString: function() { return /* binding */ isString; },
/* harmony export */   isTextSelection: function() { return /* binding */ isTextSelection; },
/* harmony export */   isiOS: function() { return /* binding */ isiOS; },
/* harmony export */   markInputRule: function() { return /* binding */ markInputRule; },
/* harmony export */   markPasteRule: function() { return /* binding */ markPasteRule; },
/* harmony export */   mergeAttributes: function() { return /* binding */ mergeAttributes; },
/* harmony export */   mergeDeep: function() { return /* binding */ mergeDeep; },
/* harmony export */   minMax: function() { return /* binding */ minMax; },
/* harmony export */   nodeInputRule: function() { return /* binding */ nodeInputRule; },
/* harmony export */   nodePasteRule: function() { return /* binding */ nodePasteRule; },
/* harmony export */   objectIncludes: function() { return /* binding */ objectIncludes; },
/* harmony export */   pasteRulesPlugin: function() { return /* binding */ pasteRulesPlugin; },
/* harmony export */   posToDOMRect: function() { return /* binding */ posToDOMRect; },
/* harmony export */   removeDuplicates: function() { return /* binding */ removeDuplicates; },
/* harmony export */   resolveFocusPosition: function() { return /* binding */ resolveFocusPosition; },
/* harmony export */   selectionToInsertionEnd: function() { return /* binding */ selectionToInsertionEnd; },
/* harmony export */   splitExtensions: function() { return /* binding */ splitExtensions; },
/* harmony export */   textInputRule: function() { return /* binding */ textInputRule; },
/* harmony export */   textPasteRule: function() { return /* binding */ textPasteRule; },
/* harmony export */   textblockTypeInputRule: function() { return /* binding */ textblockTypeInputRule; },
/* harmony export */   wrappingInputRule: function() { return /* binding */ wrappingInputRule; }
/* harmony export */ });
/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ "./node_modules/@tiptap/pm/state/dist/index.js");
/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/view */ "./node_modules/@tiptap/pm/view/dist/index.js");
/* harmony import */ var _tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/pm/keymap */ "./node_modules/@tiptap/pm/keymap/dist/index.js");
/* harmony import */ var _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/pm/model */ "./node_modules/@tiptap/pm/model/dist/index.js");
/* harmony import */ var _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/pm/transform */ "./node_modules/@tiptap/pm/transform/dist/index.js");
/* harmony import */ var _tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/pm/commands */ "./node_modules/@tiptap/pm/commands/dist/index.js");
/* harmony import */ var _tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/pm/schema-list */ "./node_modules/@tiptap/pm/schema-list/dist/index.js");
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }







function createChainableState(config) {
  var state = config.state,
    transaction = config.transaction;
  var selection = transaction.selection;
  var doc = transaction.doc;
  var storedMarks = transaction.storedMarks;
  return _objectSpread(_objectSpread({}, state), {}, {
    apply: state.apply.bind(state),
    applyTransaction: state.applyTransaction.bind(state),
    filterTransaction: state.filterTransaction,
    plugins: state.plugins,
    schema: state.schema,
    reconfigure: state.reconfigure.bind(state),
    toJSON: state.toJSON.bind(state),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc;
    },
    get tr() {
      selection = transaction.selection;
      doc = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  });
}
var CommandManager = /*#__PURE__*/function () {
  function CommandManager(props) {
    _classCallCheck(this, CommandManager);
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionManager.commands;
    this.customState = props.state;
  }
  _createClass(CommandManager, [{
    key: "hasCustomState",
    get: function get() {
      return !!this.customState;
    }
  }, {
    key: "state",
    get: function get() {
      return this.customState || this.editor.state;
    }
  }, {
    key: "commands",
    get: function get() {
      var _this = this;
      var rawCommands = this.rawCommands,
        editor = this.editor,
        state = this.state;
      var view = editor.view;
      var tr = state.tr;
      var props = this.buildProps(tr);
      return Object.fromEntries(Object.entries(rawCommands).map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          name = _ref2[0],
          command = _ref2[1];
        var method = function method() {
          var callback = command.apply(void 0, arguments)(props);
          if (!tr.getMeta('preventDispatch') && !_this.hasCustomState) {
            view.dispatch(tr);
          }
          return callback;
        };
        return [name, method];
      }));
    }
  }, {
    key: "chain",
    get: function get() {
      var _this2 = this;
      return function () {
        return _this2.createChain();
      };
    }
  }, {
    key: "can",
    get: function get() {
      var _this3 = this;
      return function () {
        return _this3.createCan();
      };
    }
  }, {
    key: "createChain",
    value: function createChain(startTr) {
      var _this4 = this;
      var shouldDispatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var rawCommands = this.rawCommands,
        editor = this.editor,
        state = this.state;
      var view = editor.view;
      var callbacks = [];
      var hasStartTransaction = !!startTr;
      var tr = startTr || state.tr;
      var run = function run() {
        if (!hasStartTransaction && shouldDispatch && !tr.getMeta('preventDispatch') && !_this4.hasCustomState) {
          view.dispatch(tr);
        }
        return callbacks.every(function (callback) {
          return callback === true;
        });
      };
      var chain = _objectSpread(_objectSpread({}, Object.fromEntries(Object.entries(rawCommands).map(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
          name = _ref4[0],
          command = _ref4[1];
        var chainedCommand = function chainedCommand() {
          var props = _this4.buildProps(tr, shouldDispatch);
          var callback = command.apply(void 0, arguments)(props);
          callbacks.push(callback);
          return chain;
        };
        return [name, chainedCommand];
      }))), {}, {
        run: run
      });
      return chain;
    }
  }, {
    key: "createCan",
    value: function createCan(startTr) {
      var _this5 = this;
      var rawCommands = this.rawCommands,
        state = this.state;
      var dispatch = false;
      var tr = startTr || state.tr;
      var props = this.buildProps(tr, dispatch);
      var formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(function (_ref5) {
        var _ref6 = _slicedToArray(_ref5, 2),
          name = _ref6[0],
          command = _ref6[1];
        return [name, function () {
          return command.apply(void 0, arguments)(_objectSpread(_objectSpread({}, props), {}, {
            dispatch: undefined
          }));
        }];
      }));
      return _objectSpread(_objectSpread({}, formattedCommands), {}, {
        chain: function chain() {
          return _this5.createChain(tr, dispatch);
        }
      });
    }
  }, {
    key: "buildProps",
    value: function buildProps(tr) {
      var _this6 = this;
      var shouldDispatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var rawCommands = this.rawCommands,
        editor = this.editor,
        state = this.state;
      var view = editor.view;
      var props = {
        tr: tr,
        editor: editor,
        view: view,
        state: createChainableState({
          state: state,
          transaction: tr
        }),
        dispatch: shouldDispatch ? function () {
          return undefined;
        } : undefined,
        chain: function chain() {
          return _this6.createChain(tr, shouldDispatch);
        },
        can: function can() {
          return _this6.createCan(tr);
        },
        get commands() {
          return Object.fromEntries(Object.entries(rawCommands).map(function (_ref7) {
            var _ref8 = _slicedToArray(_ref7, 2),
              name = _ref8[0],
              command = _ref8[1];
            return [name, function () {
              return command.apply(void 0, arguments)(props);
            }];
          }));
        }
      };
      return props;
    }
  }]);
  return CommandManager;
}();
var EventEmitter = /*#__PURE__*/function () {
  function EventEmitter() {
    _classCallCheck(this, EventEmitter);
    this.callbacks = {};
  }
  _createClass(EventEmitter, [{
    key: "on",
    value: function on(event, fn) {
      if (!this.callbacks[event]) {
        this.callbacks[event] = [];
      }
      this.callbacks[event].push(fn);
      return this;
    }
  }, {
    key: "emit",
    value: function emit(event) {
      var _this7 = this;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var callbacks = this.callbacks[event];
      if (callbacks) {
        callbacks.forEach(function (callback) {
          return callback.apply(_this7, args);
        });
      }
      return this;
    }
  }, {
    key: "off",
    value: function off(event, fn) {
      var callbacks = this.callbacks[event];
      if (callbacks) {
        if (fn) {
          this.callbacks[event] = callbacks.filter(function (callback) {
            return callback !== fn;
          });
        } else {
          delete this.callbacks[event];
        }
      }
      return this;
    }
  }, {
    key: "removeAllListeners",
    value: function removeAllListeners() {
      this.callbacks = {};
    }
  }]);
  return EventEmitter;
}();
function getExtensionField(extension, field, context) {
  if (extension.config[field] === undefined && extension.parent) {
    return getExtensionField(extension.parent, field, context);
  }
  if (typeof extension.config[field] === 'function') {
    var value = extension.config[field].bind(_objectSpread(_objectSpread({}, context), {}, {
      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null
    }));
    return value;
  }
  return extension.config[field];
}
function splitExtensions(extensions) {
  var baseExtensions = extensions.filter(function (extension) {
    return extension.type === 'extension';
  });
  var nodeExtensions = extensions.filter(function (extension) {
    return extension.type === 'node';
  });
  var markExtensions = extensions.filter(function (extension) {
    return extension.type === 'mark';
  });
  return {
    baseExtensions: baseExtensions,
    nodeExtensions: nodeExtensions,
    markExtensions: markExtensions
  };
}

/**
 * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.
 * @param extensions List of extensions
 */
function getAttributesFromExtensions(extensions) {
  var extensionAttributes = [];
  var _splitExtensions = splitExtensions(extensions),
    nodeExtensions = _splitExtensions.nodeExtensions,
    markExtensions = _splitExtensions.markExtensions;
  var nodeAndMarkExtensions = [].concat(_toConsumableArray(nodeExtensions), _toConsumableArray(markExtensions));
  var defaultAttribute = {
    "default": null,
    rendered: true,
    renderHTML: null,
    parseHTML: null,
    keepOnSplit: true,
    isRequired: false
  };
  extensions.forEach(function (extension) {
    var context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    var addGlobalAttributes = getExtensionField(extension, 'addGlobalAttributes', context);
    if (!addGlobalAttributes) {
      return;
    }
    // TODO: remove `as GlobalAttributes`
    var globalAttributes = addGlobalAttributes();
    globalAttributes.forEach(function (globalAttribute) {
      globalAttribute.types.forEach(function (type) {
        Object.entries(globalAttribute.attributes).forEach(function (_ref9) {
          var _ref10 = _slicedToArray(_ref9, 2),
            name = _ref10[0],
            attribute = _ref10[1];
          extensionAttributes.push({
            type: type,
            name: name,
            attribute: _objectSpread(_objectSpread({}, defaultAttribute), attribute)
          });
        });
      });
    });
  });
  nodeAndMarkExtensions.forEach(function (extension) {
    var context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    var addAttributes = getExtensionField(extension, 'addAttributes', context);
    if (!addAttributes) {
      return;
    }
    // TODO: remove `as Attributes`
    var attributes = addAttributes();
    Object.entries(attributes).forEach(function (_ref11) {
      var _ref12 = _slicedToArray(_ref11, 2),
        name = _ref12[0],
        attribute = _ref12[1];
      var mergedAttr = _objectSpread(_objectSpread({}, defaultAttribute), attribute);
      if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr["default"]) === 'function') {
        mergedAttr["default"] = mergedAttr["default"]();
      }
      if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr["default"]) === undefined) {
        delete mergedAttr["default"];
      }
      extensionAttributes.push({
        type: extension.name,
        name: name,
        attribute: mergedAttr
      });
    });
  });
  return extensionAttributes;
}
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === 'string') {
    if (!schema.nodes[nameOrType]) {
      throw Error("There is no node type named '".concat(nameOrType, "'. Maybe you forgot to add the extension?"));
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function mergeAttributes() {
  for (var _len2 = arguments.length, objects = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    objects[_key2] = arguments[_key2];
  }
  return objects.filter(function (item) {
    return !!item;
  }).reduce(function (items, item) {
    var mergedAttributes = _objectSpread({}, items);
    Object.entries(item).forEach(function (_ref13) {
      var _ref14 = _slicedToArray(_ref13, 2),
        key = _ref14[0],
        value = _ref14[1];
      var exists = mergedAttributes[key];
      if (!exists) {
        mergedAttributes[key] = value;
        return;
      }
      if (key === 'class') {
        var valueClasses = value ? value.split(' ') : [];
        var existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(' ') : [];
        var insertClasses = valueClasses.filter(function (valueClass) {
          return !existingClasses.includes(valueClass);
        });
        mergedAttributes[key] = [].concat(_toConsumableArray(existingClasses), _toConsumableArray(insertClasses)).join(' ');
      } else if (key === 'style') {
        mergedAttributes[key] = [mergedAttributes[key], value].join('; ');
      } else {
        mergedAttributes[key] = value;
      }
    });
    return mergedAttributes;
  }, {});
}
function getRenderedAttributes(nodeOrMark, extensionAttributes) {
  return extensionAttributes.filter(function (item) {
    return item.attribute.rendered;
  }).map(function (item) {
    if (!item.attribute.renderHTML) {
      return _defineProperty({}, item.name, nodeOrMark.attrs[item.name]);
    }
    return item.attribute.renderHTML(nodeOrMark.attrs) || {};
  }).reduce(function (attributes, attribute) {
    return mergeAttributes(attributes, attribute);
  }, {});
}
function isFunction(value) {
  return typeof value === 'function';
}

/**
 * Optionally calls `value` as a function.
 * Otherwise it is returned directly.
 * @param value Function or any value.
 * @param context Optional context to bind to function.
 * @param props Optional props to pass to function.
 */
function callOrReturn(value) {
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  if (isFunction(value)) {
    for (var _len3 = arguments.length, props = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
      props[_key3 - 2] = arguments[_key3];
    }
    if (context) {
      return value.bind(context).apply(void 0, props);
    }
    return value.apply(void 0, props);
  }
  return value;
}
function isEmptyObject() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return Object.keys(value).length === 0 && value.constructor === Object;
}
function fromString(value) {
  if (typeof value !== 'string') {
    return value;
  }
  if (value.match(/^[+-]?(?:\d*\.)?\d+$/)) {
    return Number(value);
  }
  if (value === 'true') {
    return true;
  }
  if (value === 'false') {
    return false;
  }
  return value;
}

/**
 * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).
 * Cancels when `getAttrs` returned `false`.
 * @param parseRule ProseMirror ParseRule
 * @param extensionAttributes List of attributes to inject
 */
function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {
  if (parseRule.style) {
    return parseRule;
  }
  return _objectSpread(_objectSpread({}, parseRule), {}, {
    getAttrs: function getAttrs(node) {
      var oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
      if (oldAttributes === false) {
        return false;
      }
      var newAttributes = extensionAttributes.reduce(function (items, item) {
        var value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));
        if (value === null || value === undefined) {
          return items;
        }
        return _objectSpread(_objectSpread({}, items), {}, _defineProperty({}, item.name, value));
      }, {});
      return _objectSpread(_objectSpread({}, oldAttributes), newAttributes);
    }
  });
}
function cleanUpSchemaItem(data) {
  return Object.fromEntries(
  // @ts-ignore
  Object.entries(data).filter(function (_ref16) {
    var _ref17 = _slicedToArray(_ref16, 2),
      key = _ref17[0],
      value = _ref17[1];
    if (key === 'attrs' && isEmptyObject(value)) {
      return false;
    }
    return value !== null && value !== undefined;
  }));
}
function getSchemaByResolvedExtensions(extensions, editor) {
  var _a;
  var allAttributes = getAttributesFromExtensions(extensions);
  var _splitExtensions2 = splitExtensions(extensions),
    nodeExtensions = _splitExtensions2.nodeExtensions,
    markExtensions = _splitExtensions2.markExtensions;
  var topNode = (_a = nodeExtensions.find(function (extension) {
    return getExtensionField(extension, 'topNode');
  })) === null || _a === void 0 ? void 0 : _a.name;
  var nodes = Object.fromEntries(nodeExtensions.map(function (extension) {
    var extensionAttributes = allAttributes.filter(function (attribute) {
      return attribute.type === extension.name;
    });
    var context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor: editor
    };
    var extraNodeFields = extensions.reduce(function (fields, e) {
      var extendNodeSchema = getExtensionField(e, 'extendNodeSchema', context);
      return _objectSpread(_objectSpread({}, fields), extendNodeSchema ? extendNodeSchema(extension) : {});
    }, {});
    var schema = cleanUpSchemaItem(_objectSpread(_objectSpread({}, extraNodeFields), {}, {
      content: callOrReturn(getExtensionField(extension, 'content', context)),
      marks: callOrReturn(getExtensionField(extension, 'marks', context)),
      group: callOrReturn(getExtensionField(extension, 'group', context)),
      inline: callOrReturn(getExtensionField(extension, 'inline', context)),
      atom: callOrReturn(getExtensionField(extension, 'atom', context)),
      selectable: callOrReturn(getExtensionField(extension, 'selectable', context)),
      draggable: callOrReturn(getExtensionField(extension, 'draggable', context)),
      code: callOrReturn(getExtensionField(extension, 'code', context)),
      defining: callOrReturn(getExtensionField(extension, 'defining', context)),
      isolating: callOrReturn(getExtensionField(extension, 'isolating', context)),
      attrs: Object.fromEntries(extensionAttributes.map(function (extensionAttribute) {
        var _a;
        return [extensionAttribute.name, {
          "default": (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a["default"]
        }];
      }))
    }));
    var parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map(function (parseRule) {
        return injectExtensionAttributesToParseRule(parseRule, extensionAttributes);
      });
    }
    var renderHTML = getExtensionField(extension, 'renderHTML', context);
    if (renderHTML) {
      schema.toDOM = function (node) {
        return renderHTML({
          node: node,
          HTMLAttributes: getRenderedAttributes(node, extensionAttributes)
        });
      };
    }
    var renderText = getExtensionField(extension, 'renderText', context);
    if (renderText) {
      schema.toText = renderText;
    }
    return [extension.name, schema];
  }));
  var marks = Object.fromEntries(markExtensions.map(function (extension) {
    var extensionAttributes = allAttributes.filter(function (attribute) {
      return attribute.type === extension.name;
    });
    var context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor: editor
    };
    var extraMarkFields = extensions.reduce(function (fields, e) {
      var extendMarkSchema = getExtensionField(e, 'extendMarkSchema', context);
      return _objectSpread(_objectSpread({}, fields), extendMarkSchema ? extendMarkSchema(extension) : {});
    }, {});
    var schema = cleanUpSchemaItem(_objectSpread(_objectSpread({}, extraMarkFields), {}, {
      inclusive: callOrReturn(getExtensionField(extension, 'inclusive', context)),
      excludes: callOrReturn(getExtensionField(extension, 'excludes', context)),
      group: callOrReturn(getExtensionField(extension, 'group', context)),
      spanning: callOrReturn(getExtensionField(extension, 'spanning', context)),
      code: callOrReturn(getExtensionField(extension, 'code', context)),
      attrs: Object.fromEntries(extensionAttributes.map(function (extensionAttribute) {
        var _a;
        return [extensionAttribute.name, {
          "default": (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a["default"]
        }];
      }))
    }));
    var parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));
    if (parseHTML) {
      schema.parseDOM = parseHTML.map(function (parseRule) {
        return injectExtensionAttributesToParseRule(parseRule, extensionAttributes);
      });
    }
    var renderHTML = getExtensionField(extension, 'renderHTML', context);
    if (renderHTML) {
      schema.toDOM = function (mark) {
        return renderHTML({
          mark: mark,
          HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)
        });
      };
    }
    return [extension.name, schema];
  }));
  return new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Schema({
    topNode: topNode,
    nodes: nodes,
    marks: marks
  });
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some(function (enabledExtension) {
      var name = typeof enabledExtension === 'string' ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
var getTextContentFromNodes = function getTextContentFromNodes($from) {
  var maxMatch = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;
  var textBefore = '';
  var sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, function (node, pos, parent, index) {
    var _a, _b;
    var chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {
      node: node,
      pos: pos,
      parent: parent,
      index: index
    })) || node.textContent || '%leaf%';
    textBefore += chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
function isRegExp(value) {
  return Object.prototype.toString.call(value) === '[object RegExp]';
}
var InputRule = /*#__PURE__*/_createClass(function InputRule(config) {
  _classCallCheck(this, InputRule);
  this.find = config.find;
  this.handler = config.handler;
});
var inputRuleMatcherHandler = function inputRuleMatcherHandler(text, find) {
  if (isRegExp(find)) {
    return find.exec(text);
  }
  var inputRuleMatch = find(text);
  if (!inputRuleMatch) {
    return null;
  }
  var result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
function run$1(config) {
  var _a;
  var editor = config.editor,
    from = config.from,
    to = config.to,
    text = config.text,
    rules = config.rules,
    plugin = config.plugin;
  var view = editor.view;
  if (view.composing) {
    return false;
  }
  var $from = view.state.doc.resolve(from);
  if (
  // check for code node
  $from.parent.type.spec.code
  // check for code mark
  || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find(function (mark) {
    return mark.type.spec.code;
  }))) {
    return false;
  }
  var matched = false;
  var textBefore = getTextContentFromNodes($from) + text;
  rules.forEach(function (rule) {
    if (matched) {
      return;
    }
    var match = inputRuleMatcherHandler(textBefore, rule.find);
    if (!match) {
      return;
    }
    var tr = view.state.tr;
    var state = createChainableState({
      state: view.state,
      transaction: tr
    });
    var range = {
      from: from - (match[0].length - text.length),
      to: to
    };
    var _CommandManager = new CommandManager({
        editor: editor,
        state: state
      }),
      commands = _CommandManager.commands,
      chain = _CommandManager.chain,
      can = _CommandManager.can;
    var handler = rule.handler({
      state: state,
      range: range,
      match: match,
      commands: commands,
      chain: chain,
      can: can
    });
    // stop if there are no changes
    if (handler === null || !tr.steps.length) {
      return;
    }
    // store transform as meta data
    // so we can undo input rules within the `undoInputRules` command
    tr.setMeta(plugin, {
      transform: tr,
      from: from,
      to: to,
      text: text
    });
    view.dispatch(tr);
    matched = true;
  });
  return matched;
}
/**
 * Create an input rules plugin. When enabled, it will cause text
 * input that matches any of the given rules to trigger the rules
 * action.
 */
function inputRulesPlugin(props) {
  var editor = props.editor,
    rules = props.rules;
  var plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({
    state: {
      init: function init() {
        return null;
      },
      apply: function apply(tr, prev) {
        var stored = tr.getMeta(plugin);
        if (stored) {
          return stored;
        }
        return tr.selectionSet || tr.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput: function handleTextInput(view, from, to, text) {
        return run$1({
          editor: editor,
          from: from,
          to: to,
          text: text,
          rules: rules,
          plugin: plugin
        });
      },
      handleDOMEvents: {
        compositionend: function compositionend(view) {
          setTimeout(function () {
            var $cursor = view.state.selection.$cursor;
            if ($cursor) {
              run$1({
                editor: editor,
                from: $cursor.pos,
                to: $cursor.pos,
                text: '',
                rules: rules,
                plugin: plugin
              });
            }
          });
          return false;
        }
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown: function handleKeyDown(view, event) {
        if (event.key !== 'Enter') {
          return false;
        }
        var $cursor = view.state.selection.$cursor;
        if ($cursor) {
          return run$1({
            editor: editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: '\n',
            rules: rules,
            plugin: plugin
          });
        }
        return false;
      }
    },
    // @ts-ignore
    isInputRules: true
  });
  return plugin;
}
function isNumber(value) {
  return typeof value === 'number';
}
var PasteRule = /*#__PURE__*/_createClass(function PasteRule(config) {
  _classCallCheck(this, PasteRule);
  this.find = config.find;
  this.handler = config.handler;
});
var pasteRuleMatcherHandler = function pasteRuleMatcherHandler(text, find, event) {
  if (isRegExp(find)) {
    return _toConsumableArray(text.matchAll(find));
  }
  var matches = find(text, event);
  if (!matches) {
    return [];
  }
  return matches.map(function (pasteRuleMatch) {
    var result = [pasteRuleMatch.text];
    result.index = pasteRuleMatch.index;
    result.input = text;
    result.data = pasteRuleMatch.data;
    if (pasteRuleMatch.replaceWith) {
      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {
        console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".');
      }
      result.push(pasteRuleMatch.replaceWith);
    }
    return result;
  });
};
function run(config) {
  var editor = config.editor,
    state = config.state,
    from = config.from,
    to = config.to,
    rule = config.rule,
    pasteEvent = config.pasteEvent,
    dropEvent = config.dropEvent;
  var _CommandManager2 = new CommandManager({
      editor: editor,
      state: state
    }),
    commands = _CommandManager2.commands,
    chain = _CommandManager2.chain,
    can = _CommandManager2.can;
  var handlers = [];
  state.doc.nodesBetween(from, to, function (node, pos) {
    if (!node.isTextblock || node.type.spec.code) {
      return;
    }
    var resolvedFrom = Math.max(from, pos);
    var resolvedTo = Math.min(to, pos + node.content.size);
    var textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, "\uFFFC");
    var matches = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);
    matches.forEach(function (match) {
      if (match.index === undefined) {
        return;
      }
      var start = resolvedFrom + match.index + 1;
      var end = start + match[0].length;
      var range = {
        from: state.tr.mapping.map(start),
        to: state.tr.mapping.map(end)
      };
      var handler = rule.handler({
        state: state,
        range: range,
        match: match,
        commands: commands,
        chain: chain,
        can: can,
        pasteEvent: pasteEvent,
        dropEvent: dropEvent
      });
      handlers.push(handler);
    });
  });
  var success = handlers.every(function (handler) {
    return handler !== null;
  });
  return success;
}
/**
 * Create an paste rules plugin. When enabled, it will cause pasted
 * text that matches any of the given rules to trigger the rules
 * action.
 */
function pasteRulesPlugin(props) {
  var editor = props.editor,
    rules = props.rules;
  var dragSourceElement = null;
  var isPastedFromProseMirror = false;
  var isDroppedFromProseMirror = false;
  var pasteEvent = new ClipboardEvent('paste');
  var dropEvent = new DragEvent('drop');
  var plugins = rules.map(function (rule) {
    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({
      // we register a global drag handler to track the current drag source element
      view: function view(_view2) {
        var handleDragstart = function handleDragstart(event) {
          var _a;
          dragSourceElement = ((_a = _view2.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? _view2.dom.parentElement : null;
        };
        window.addEventListener('dragstart', handleDragstart);
        return {
          destroy: function destroy() {
            window.removeEventListener('dragstart', handleDragstart);
          }
        };
      },
      props: {
        handleDOMEvents: {
          drop: function drop(view, event) {
            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;
            dropEvent = event;
            return false;
          },
          paste: function paste(_view, event) {
            var _a;
            var html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/html');
            pasteEvent = event;
            isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes('data-pm-slice'));
            return false;
          }
        }
      },
      appendTransaction: function appendTransaction(transactions, oldState, state) {
        var transaction = transactions[0];
        var isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror;
        var isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror;
        if (!isPaste && !isDrop) {
          return;
        }
        // stop if there is no changed range
        var from = oldState.doc.content.findDiffStart(state.doc.content);
        var to = oldState.doc.content.findDiffEnd(state.doc.content);
        if (!isNumber(from) || !to || from === to.b) {
          return;
        }
        // build a chainable state
        // so we can use a single transaction for all paste rules
        var tr = state.tr;
        var chainableState = createChainableState({
          state: state,
          transaction: tr
        });
        var handler = run({
          editor: editor,
          state: chainableState,
          from: Math.max(from - 1, 0),
          to: to.b - 1,
          rule: rule,
          pasteEvent: pasteEvent,
          dropEvent: dropEvent
        });
        // stop if there are no changes
        if (!handler || !tr.steps.length) {
          return;
        }
        dropEvent = new DragEvent('drop');
        pasteEvent = new ClipboardEvent('paste');
        return tr;
      }
    });
  });
  return plugins;
}
function findDuplicates(items) {
  var filtered = items.filter(function (el, index) {
    return items.indexOf(el) !== index;
  });
  return _toConsumableArray(new Set(filtered));
}
var ExtensionManager = /*#__PURE__*/function () {
  function ExtensionManager(extensions, editor) {
    var _this8 = this;
    _classCallCheck(this, ExtensionManager);
    this.splittableMarks = [];
    this.editor = editor;
    this.extensions = ExtensionManager.resolve(extensions);
    this.schema = getSchemaByResolvedExtensions(this.extensions, editor);
    this.extensions.forEach(function (extension) {
      var _a;
      // store extension storage in editor
      _this8.editor.extensionStorage[extension.name] = extension.storage;
      var context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: _this8.editor,
        type: getSchemaTypeByName(extension.name, _this8.schema)
      };
      if (extension.type === 'mark') {
        var keepOnSplit = (_a = callOrReturn(getExtensionField(extension, 'keepOnSplit', context))) !== null && _a !== void 0 ? _a : true;
        if (keepOnSplit) {
          _this8.splittableMarks.push(extension.name);
        }
      }
      var onBeforeCreate = getExtensionField(extension, 'onBeforeCreate', context);
      if (onBeforeCreate) {
        _this8.editor.on('beforeCreate', onBeforeCreate);
      }
      var onCreate = getExtensionField(extension, 'onCreate', context);
      if (onCreate) {
        _this8.editor.on('create', onCreate);
      }
      var onUpdate = getExtensionField(extension, 'onUpdate', context);
      if (onUpdate) {
        _this8.editor.on('update', onUpdate);
      }
      var onSelectionUpdate = getExtensionField(extension, 'onSelectionUpdate', context);
      if (onSelectionUpdate) {
        _this8.editor.on('selectionUpdate', onSelectionUpdate);
      }
      var onTransaction = getExtensionField(extension, 'onTransaction', context);
      if (onTransaction) {
        _this8.editor.on('transaction', onTransaction);
      }
      var onFocus = getExtensionField(extension, 'onFocus', context);
      if (onFocus) {
        _this8.editor.on('focus', onFocus);
      }
      var onBlur = getExtensionField(extension, 'onBlur', context);
      if (onBlur) {
        _this8.editor.on('blur', onBlur);
      }
      var onDestroy = getExtensionField(extension, 'onDestroy', context);
      if (onDestroy) {
        _this8.editor.on('destroy', onDestroy);
      }
    });
  }
  _createClass(ExtensionManager, [{
    key: "commands",
    get: function get() {
      var _this9 = this;
      return this.extensions.reduce(function (commands, extension) {
        var context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor: _this9.editor,
          type: getSchemaTypeByName(extension.name, _this9.schema)
        };
        var addCommands = getExtensionField(extension, 'addCommands', context);
        if (!addCommands) {
          return commands;
        }
        return _objectSpread(_objectSpread({}, commands), addCommands());
      }, {});
    }
  }, {
    key: "plugins",
    get: function get() {
      var _this10 = this;
      var editor = this.editor;
      // With ProseMirror, first plugins within an array are executed first.
      // In Tiptap, we provide the ability to override plugins,
      // so it feels more natural to run plugins at the end of an array first.
      // Thats why we have to reverse the `extensions` array and sort again
      // based on the `priority` option.
      var extensions = ExtensionManager.sort(_toConsumableArray(this.extensions).reverse());
      var inputRules = [];
      var pasteRules = [];
      var allPlugins = extensions.map(function (extension) {
        var context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor: editor,
          type: getSchemaTypeByName(extension.name, _this10.schema)
        };
        var plugins = [];
        var addKeyboardShortcuts = getExtensionField(extension, 'addKeyboardShortcuts', context);
        var defaultBindings = {};
        // bind exit handling
        if (extension.type === 'mark' && extension.config.exitable) {
          defaultBindings.ArrowRight = function () {
            return Mark.handleExit({
              editor: editor,
              mark: extension
            });
          };
        }
        if (addKeyboardShortcuts) {
          var bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(function (_ref18) {
            var _ref19 = _slicedToArray(_ref18, 2),
              shortcut = _ref19[0],
              method = _ref19[1];
            return [shortcut, function () {
              return method({
                editor: editor
              });
            }];
          }));
          defaultBindings = _objectSpread(_objectSpread({}, defaultBindings), bindings);
        }
        var keyMapPlugin = (0,_tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_2__.keymap)(defaultBindings);
        plugins.push(keyMapPlugin);
        var addInputRules = getExtensionField(extension, 'addInputRules', context);
        if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
          inputRules.push.apply(inputRules, _toConsumableArray(addInputRules()));
        }
        var addPasteRules = getExtensionField(extension, 'addPasteRules', context);
        if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {
          pasteRules.push.apply(pasteRules, _toConsumableArray(addPasteRules()));
        }
        var addProseMirrorPlugins = getExtensionField(extension, 'addProseMirrorPlugins', context);
        if (addProseMirrorPlugins) {
          var proseMirrorPlugins = addProseMirrorPlugins();
          plugins.push.apply(plugins, _toConsumableArray(proseMirrorPlugins));
        }
        return plugins;
      }).flat();
      return [inputRulesPlugin({
        editor: editor,
        rules: inputRules
      })].concat(_toConsumableArray(pasteRulesPlugin({
        editor: editor,
        rules: pasteRules
      })), _toConsumableArray(allPlugins));
    }
  }, {
    key: "attributes",
    get: function get() {
      return getAttributesFromExtensions(this.extensions);
    }
  }, {
    key: "nodeViews",
    get: function get() {
      var _this11 = this;
      var editor = this.editor;
      var _splitExtensions3 = splitExtensions(this.extensions),
        nodeExtensions = _splitExtensions3.nodeExtensions;
      return Object.fromEntries(nodeExtensions.filter(function (extension) {
        return !!getExtensionField(extension, 'addNodeView');
      }).map(function (extension) {
        var extensionAttributes = _this11.attributes.filter(function (attribute) {
          return attribute.type === extension.name;
        });
        var context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage,
          editor: editor,
          type: getNodeType(extension.name, _this11.schema)
        };
        var addNodeView = getExtensionField(extension, 'addNodeView', context);
        if (!addNodeView) {
          return [];
        }
        var nodeview = function nodeview(node, view, getPos, decorations) {
          var HTMLAttributes = getRenderedAttributes(node, extensionAttributes);
          return addNodeView()({
            editor: editor,
            node: node,
            getPos: getPos,
            decorations: decorations,
            HTMLAttributes: HTMLAttributes,
            extension: extension
          });
        };
        return [extension.name, nodeview];
      }));
    }
  }], [{
    key: "resolve",
    value: function resolve(extensions) {
      var resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));
      var duplicatedNames = findDuplicates(resolvedExtensions.map(function (extension) {
        return extension.name;
      }));
      if (duplicatedNames.length) {
        console.warn("[tiptap warn]: Duplicate extension names found: [".concat(duplicatedNames.map(function (item) {
          return "'".concat(item, "'");
        }).join(', '), "]. This can lead to issues."));
      }
      return resolvedExtensions;
    }
  }, {
    key: "flatten",
    value: function flatten(extensions) {
      var _this12 = this;
      return extensions.map(function (extension) {
        var context = {
          name: extension.name,
          options: extension.options,
          storage: extension.storage
        };
        var addExtensions = getExtensionField(extension, 'addExtensions', context);
        if (addExtensions) {
          return [extension].concat(_toConsumableArray(_this12.flatten(addExtensions())));
        }
        return extension;
      })
      // `Infinity` will break TypeScript so we set a number that is probably high enough
      .flat(10);
    }
  }, {
    key: "sort",
    value: function sort(extensions) {
      var defaultPriority = 100;
      return extensions.sort(function (a, b) {
        var priorityA = getExtensionField(a, 'priority') || defaultPriority;
        var priorityB = getExtensionField(b, 'priority') || defaultPriority;
        if (priorityA > priorityB) {
          return -1;
        }
        if (priorityA < priorityB) {
          return 1;
        }
        return 0;
      });
    }
  }]);
  return ExtensionManager;
}(); // see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts
function getType(value) {
  return Object.prototype.toString.call(value).slice(8, -1);
}
function isPlainObject(value) {
  if (getType(value) !== 'Object') {
    return false;
  }
  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;
}
function mergeDeep(target, source) {
  var output = _objectSpread({}, target);
  if (isPlainObject(target) && isPlainObject(source)) {
    Object.keys(source).forEach(function (key) {
      if (isPlainObject(source[key])) {
        if (!(key in target)) {
          Object.assign(output, _defineProperty({}, key, source[key]));
        } else {
          output[key] = mergeDeep(target[key], source[key]);
        }
      } else {
        Object.assign(output, _defineProperty({}, key, source[key]));
      }
    });
  }
  return output;
}
var Extension = /*#__PURE__*/function () {
  function Extension() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, Extension);
    this.type = 'extension';
    this.name = 'extension';
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = _objectSpread(_objectSpread({}, this.config), config);
    this.name = this.config.name;
    if (config.defaultOptions) {
      console.warn("[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"".concat(this.name, "\"."));
    }
    // TODO: remove `addOptions` fallback
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, 'addOptions', {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {
      name: this.name,
      options: this.options
    })) || {};
  }
  _createClass(Extension, [{
    key: "configure",
    value: function configure() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // return a new instance so we can use the same extension
      // with different calls of `configure`
      var extension = this.extend();
      extension.options = mergeDeep(this.options, options);
      extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
  }, {
    key: "extend",
    value: function extend() {
      var extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var extension = new Extension(extendedConfig);
      extension.parent = this;
      this.child = extension;
      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
      if (extendedConfig.defaultOptions) {
        console.warn("[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"".concat(extension.name, "\"."));
      }
      extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {
        name: extension.name
      }));
      extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
  }], [{
    key: "create",
    value: function create() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new Extension(config);
    }
  }]);
  return Extension;
}();
function getTextBetween(startNode, range, options) {
  var from = range.from,
    to = range.to;
  var _ref20 = options || {},
    _ref20$blockSeparator = _ref20.blockSeparator,
    blockSeparator = _ref20$blockSeparator === void 0 ? '\n\n' : _ref20$blockSeparator,
    _ref20$textSerializer = _ref20.textSerializers,
    textSerializers = _ref20$textSerializer === void 0 ? {} : _ref20$textSerializer;
  var text = '';
  var separated = true;
  startNode.nodesBetween(from, to, function (node, pos, parent, index) {
    var _a;
    var textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];
    if (textSerializer) {
      if (node.isBlock && !separated) {
        text += blockSeparator;
        separated = true;
      }
      if (parent) {
        text += textSerializer({
          node: node,
          pos: pos,
          parent: parent,
          index: index,
          range: range
        });
      }
    } else if (node.isText) {
      text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos); // eslint-disable-line
      separated = false;
    } else if (node.isBlock && !separated) {
      text += blockSeparator;
      separated = true;
    }
  });
  return text;
}
function getTextSerializersFromSchema(schema) {
  return Object.fromEntries(Object.entries(schema.nodes).filter(function (_ref21) {
    var _ref22 = _slicedToArray(_ref21, 2),
      node = _ref22[1];
    return node.spec.toText;
  }).map(function (_ref23) {
    var _ref24 = _slicedToArray(_ref23, 2),
      name = _ref24[0],
      node = _ref24[1];
    return [name, node.spec.toText];
  }));
}
var ClipboardTextSerializer = Extension.create({
  name: 'clipboardTextSerializer',
  addProseMirrorPlugins: function addProseMirrorPlugins() {
    var _this13 = this;
    return [new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({
      key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('clipboardTextSerializer'),
      props: {
        clipboardTextSerializer: function clipboardTextSerializer() {
          var editor = _this13.editor;
          var state = editor.state,
            schema = editor.schema;
          var doc = state.doc,
            selection = state.selection;
          var ranges = selection.ranges;
          var from = Math.min.apply(Math, _toConsumableArray(ranges.map(function (range) {
            return range.$from.pos;
          })));
          var to = Math.max.apply(Math, _toConsumableArray(ranges.map(function (range) {
            return range.$to.pos;
          })));
          var textSerializers = getTextSerializersFromSchema(schema);
          var range = {
            from: from,
            to: to
          };
          return getTextBetween(doc, range, {
            textSerializers: textSerializers
          });
        }
      }
    })];
  }
});
var blur = function blur() {
  return function (_ref25) {
    var editor = _ref25.editor,
      view = _ref25.view;
    requestAnimationFrame(function () {
      var _a;
      if (!editor.isDestroyed) {
        view.dom.blur();
        // Browsers should remove the caret on blur but safari does not.
        // See: https://github.com/ueberdosis/tiptap/issues/2405
        (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();
      }
    });
    return true;
  };
};
var clearContent = function clearContent() {
  var emitUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  return function (_ref26) {
    var commands = _ref26.commands;
    return commands.setContent('', emitUpdate);
  };
};
var clearNodes = function clearNodes() {
  return function (_ref27) {
    var state = _ref27.state,
      tr = _ref27.tr,
      dispatch = _ref27.dispatch;
    var selection = tr.selection;
    var ranges = selection.ranges;
    if (!dispatch) {
      return true;
    }
    ranges.forEach(function (_ref28) {
      var $from = _ref28.$from,
        $to = _ref28.$to;
      state.doc.nodesBetween($from.pos, $to.pos, function (node, pos) {
        if (node.type.isText) {
          return;
        }
        var doc = tr.doc,
          mapping = tr.mapping;
        var $mappedFrom = doc.resolve(mapping.map(pos));
        var $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));
        var nodeRange = $mappedFrom.blockRange($mappedTo);
        if (!nodeRange) {
          return;
        }
        var targetLiftDepth = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.liftTarget)(nodeRange);
        if (node.type.isTextblock) {
          var _$mappedFrom$parent$c = $mappedFrom.parent.contentMatchAt($mappedFrom.index()),
            defaultType = _$mappedFrom$parent$c.defaultType;
          tr.setNodeMarkup(nodeRange.start, defaultType);
        }
        if (targetLiftDepth || targetLiftDepth === 0) {
          tr.lift(nodeRange, targetLiftDepth);
        }
      });
    });
    return true;
  };
};
var command = function command(fn) {
  return function (props) {
    return fn(props);
  };
};
var createParagraphNear = function createParagraphNear() {
  return function (_ref29) {
    var state = _ref29.state,
      dispatch = _ref29.dispatch;
    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.createParagraphNear)(state, dispatch);
  };
};
var cut = function cut(originRange, targetPos) {
  return function (_ref30) {
    var editor = _ref30.editor,
      tr = _ref30.tr;
    var state = editor.state;
    var contentSlice = state.doc.slice(originRange.from, originRange.to);
    tr.deleteRange(originRange.from, originRange.to);
    var newPos = tr.mapping.map(targetPos);
    tr.insert(newPos, contentSlice.content);
    tr.setSelection(new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection(tr.doc.resolve(newPos - 1)));
    return true;
  };
};
var deleteCurrentNode = function deleteCurrentNode() {
  return function (_ref31) {
    var tr = _ref31.tr,
      dispatch = _ref31.dispatch;
    var selection = tr.selection;
    var currentNode = selection.$anchor.node();
    // if there is content inside the current node, break out of this command
    if (currentNode.content.size > 0) {
      return false;
    }
    var $pos = tr.selection.$anchor;
    for (var depth = $pos.depth; depth > 0; depth -= 1) {
      var node = $pos.node(depth);
      if (node.type === currentNode.type) {
        if (dispatch) {
          var from = $pos.before(depth);
          var to = $pos.after(depth);
          tr["delete"](from, to).scrollIntoView();
        }
        return true;
      }
    }
    return false;
  };
};
var deleteNode = function deleteNode(typeOrName) {
  return function (_ref32) {
    var tr = _ref32.tr,
      state = _ref32.state,
      dispatch = _ref32.dispatch;
    var type = getNodeType(typeOrName, state.schema);
    var $pos = tr.selection.$anchor;
    for (var depth = $pos.depth; depth > 0; depth -= 1) {
      var node = $pos.node(depth);
      if (node.type === type) {
        if (dispatch) {
          var from = $pos.before(depth);
          var to = $pos.after(depth);
          tr["delete"](from, to).scrollIntoView();
        }
        return true;
      }
    }
    return false;
  };
};
var deleteRange = function deleteRange(range) {
  return function (_ref33) {
    var tr = _ref33.tr,
      dispatch = _ref33.dispatch;
    var from = range.from,
      to = range.to;
    if (dispatch) {
      tr["delete"](from, to);
    }
    return true;
  };
};
var deleteSelection = function deleteSelection() {
  return function (_ref34) {
    var state = _ref34.state,
      dispatch = _ref34.dispatch;
    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.deleteSelection)(state, dispatch);
  };
};
var enter = function enter() {
  return function (_ref35) {
    var commands = _ref35.commands;
    return commands.keyboardShortcut('Enter');
  };
};
var exitCode = function exitCode() {
  return function (_ref36) {
    var state = _ref36.state,
      dispatch = _ref36.dispatch;
    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.exitCode)(state, dispatch);
  };
};

/**
 * Check if object1 includes object2
 * @param object1 Object
 * @param object2 Object
 */
function objectIncludes(object1, object2) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    strict: true
  };
  var keys = Object.keys(object2);
  if (!keys.length) {
    return true;
  }
  return keys.every(function (key) {
    if (options.strict) {
      return object2[key] === object1[key];
    }
    if (isRegExp(object2[key])) {
      return object2[key].test(object1[key]);
    }
    return object2[key] === object1[key];
  });
}
function findMarkInSet(marks, type) {
  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return marks.find(function (item) {
    return item.type === type && objectIncludes(item.attrs, attributes);
  });
}
function isMarkInSet(marks, type) {
  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return !!findMarkInSet(marks, type, attributes);
}
function getMarkRange($pos, type) {
  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (!$pos || !type) {
    return;
  }
  var start = $pos.parent.childAfter($pos.parentOffset);
  if ($pos.parentOffset === start.offset && start.offset !== 0) {
    start = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start.node) {
    return;
  }
  var mark = findMarkInSet(_toConsumableArray(start.node.marks), type, attributes);
  if (!mark) {
    return;
  }
  var startIndex = start.index;
  var startPos = $pos.start() + start.offset;
  var endIndex = startIndex + 1;
  var endPos = startPos + start.node.nodeSize;
  findMarkInSet(_toConsumableArray(start.node.marks), type, attributes);
  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet(_toConsumableArray($pos.parent.child(endIndex).marks), type, attributes)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return {
    from: startPos,
    to: endPos
  };
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === 'string') {
    if (!schema.marks[nameOrType]) {
      throw Error("There is no mark type named '".concat(nameOrType, "'. Maybe you forgot to add the extension?"));
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
var extendMarkRange = function extendMarkRange(typeOrName) {
  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function (_ref37) {
    var tr = _ref37.tr,
      state = _ref37.state,
      dispatch = _ref37.dispatch;
    var type = getMarkType(typeOrName, state.schema);
    var doc = tr.doc,
      selection = tr.selection;
    var $from = selection.$from,
      from = selection.from,
      to = selection.to;
    if (dispatch) {
      var range = getMarkRange($from, type, attributes);
      if (range && range.from <= from && range.to >= to) {
        var newSelection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, range.from, range.to);
        tr.setSelection(newSelection);
      }
    }
    return true;
  };
};
var first = function first(commands) {
  return function (props) {
    var items = typeof commands === 'function' ? commands(props) : commands;
    for (var i = 0; i < items.length; i += 1) {
      if (items[i](props)) {
        return true;
      }
    }
    return false;
  };
};
function isTextSelection(value) {
  return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection;
}
function minMax() {
  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return Math.min(Math.max(value, min), max);
}
function resolveFocusPosition(doc) {
  var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  if (!position) {
    return null;
  }
  var selectionAtStart = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(doc);
  var selectionAtEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atEnd(doc);
  if (position === 'start' || position === true) {
    return selectionAtStart;
  }
  if (position === 'end') {
    return selectionAtEnd;
  }
  var minPos = selectionAtStart.from;
  var maxPos = selectionAtEnd.to;
  if (position === 'all') {
    return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));
  }
  return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));
}
function isiOS() {
  return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(navigator.platform)
  // iPad on iOS 13 detection
  || navigator.userAgent.includes('Mac') && 'ontouchend' in document;
}
var focus = function focus() {
  var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function (_ref38) {
    var editor = _ref38.editor,
      view = _ref38.view,
      tr = _ref38.tr,
      dispatch = _ref38.dispatch;
    options = _objectSpread({
      scrollIntoView: true
    }, options);
    var delayedFocus = function delayedFocus() {
      // focus within `requestAnimationFrame` breaks focus on iOS
      // so we have to call this
      if (isiOS()) {
        view.dom.focus();
      }
      // For React we have to focus asynchronously. Otherwise wild things happen.
      // see: https://github.com/ueberdosis/tiptap/issues/1520
      requestAnimationFrame(function () {
        if (!editor.isDestroyed) {
          view.focus();
          if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {
            editor.commands.scrollIntoView();
          }
        }
      });
    };
    if (view.hasFocus() && position === null || position === false) {
      return true;
    }
    // we dont try to resolve a NodeSelection or CellSelection
    if (dispatch && position === null && !isTextSelection(editor.state.selection)) {
      delayedFocus();
      return true;
    }
    // pass through tr.doc instead of editor.state.doc
    // since transactions could change the editors state before this command has been run
    var selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;
    var isSameSelection = editor.state.selection.eq(selection);
    if (dispatch) {
      if (!isSameSelection) {
        tr.setSelection(selection);
      }
      // `tr.setSelection` resets the stored marks
      // so well restore them if the selection is the same as before
      if (isSameSelection && tr.storedMarks) {
        tr.setStoredMarks(tr.storedMarks);
      }
      delayedFocus();
    }
    return true;
  };
};
var forEach = function forEach(items, fn) {
  return function (props) {
    return items.every(function (item, index) {
      return fn(item, _objectSpread(_objectSpread({}, props), {}, {
        index: index
      }));
    });
  };
};
var insertContent = function insertContent(value, options) {
  return function (_ref39) {
    var tr = _ref39.tr,
      commands = _ref39.commands;
    return commands.insertContentAt({
      from: tr.selection.from,
      to: tr.selection.to
    }, value, options);
  };
};
var removeWhitespaces = function removeWhitespaces(node) {
  var children = node.childNodes;
  for (var i = children.length - 1; i >= 0; i -= 1) {
    var child = children[i];
    if (child.nodeType === 3 && child.nodeValue && !/\S/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node;
};
function elementFromString(value) {
  // add a wrapper to preserve leading and trailing whitespace
  var wrappedValue = "<body>".concat(value, "</body>");
  var html = new window.DOMParser().parseFromString(wrappedValue, 'text/html').body;
  removeWhitespaces(html);
  return removeWhitespaces(html);
}
function createNodeFromContent(content, schema, options) {
  options = _objectSpread({
    slice: true,
    parseOptions: {}
  }, options);
  if (_typeof(content) === 'object' && content !== null) {
    try {
      if (Array.isArray(content) && content.length > 0) {
        return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.fromArray(content.map(function (item) {
          return schema.nodeFromJSON(item);
        }));
      }
      return schema.nodeFromJSON(content);
    } catch (error) {
      console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error);
      return createNodeFromContent('', schema, options);
    }
  }
  if (typeof content === 'string') {
    var parser = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema);
    return options.slice ? parser.parseSlice(elementFromString(content), options.parseOptions).content : parser.parse(elementFromString(content), options.parseOptions);
  }
  return createNodeFromContent('', schema, options);
}

// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466
function selectionToInsertionEnd(tr, startLen, bias) {
  var last = tr.steps.length - 1;
  if (last < startLen) {
    return;
  }
  var step = tr.steps[last];
  if (!(step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.ReplaceStep || step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.ReplaceAroundStep)) {
    return;
  }
  var map = tr.mapping.maps[last];
  var end = 0;
  map.forEach(function (_from, _to, _newFrom, newTo) {
    if (end === 0) {
      end = newTo;
    }
  });
  tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tr.doc.resolve(end), bias));
}
var isFragment = function isFragment(nodeOrFragment) {
  return nodeOrFragment.toString().startsWith('<');
};
var insertContentAt = function insertContentAt(position, value, options) {
  return function (_ref40) {
    var tr = _ref40.tr,
      dispatch = _ref40.dispatch,
      editor = _ref40.editor;
    if (dispatch) {
      options = _objectSpread({
        parseOptions: {},
        updateSelection: true
      }, options);
      var content = createNodeFromContent(value, editor.schema, {
        parseOptions: _objectSpread({
          preserveWhitespace: 'full'
        }, options.parseOptions)
      });
      // dont dispatch an empty fragment because this can lead to strange errors
      if (content.toString() === '<>') {
        return true;
      }
      var _ref41 = typeof position === 'number' ? {
          from: position,
          to: position
        } : {
          from: position.from,
          to: position.to
        },
        from = _ref41.from,
        to = _ref41.to;
      var isOnlyTextContent = true;
      var isOnlyBlockContent = true;
      var nodes = isFragment(content) ? content : [content];
      nodes.forEach(function (node) {
        // check if added node is valid
        node.check();
        isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
        isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
      });
      // check if we can replace the wrapping node by
      // the newly inserted content
      // example:
      // replace an empty paragraph by an inserted image
      // instead of inserting the image below the paragraph
      if (from === to && isOnlyBlockContent) {
        var _tr$doc$resolve = tr.doc.resolve(from),
          parent = _tr$doc$resolve.parent;
        var isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
        if (isEmptyTextBlock) {
          from -= 1;
          to += 1;
        }
      }
      // if there is only plain text we have to use `insertText`
      // because this will keep the current marks
      if (isOnlyTextContent) {
        // if value is string, we can use it directly
        // otherwise if it is an array, we have to join it
        if (Array.isArray(value)) {
          tr.insertText(value.map(function (v) {
            return v.text || '';
          }).join(''), from, to);
        } else if (_typeof(value) === 'object' && !!value && !!value.text) {
          tr.insertText(value.text, from, to);
        } else {
          tr.insertText(value, from, to);
        }
      } else {
        tr.replaceWith(from, to, content);
      }
      // set cursor at end of inserted content
      if (options.updateSelection) {
        selectionToInsertionEnd(tr, tr.steps.length - 1, -1);
      }
    }
    return true;
  };
};
var joinUp = function joinUp() {
  return function (_ref42) {
    var state = _ref42.state,
      dispatch = _ref42.dispatch;
    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinUp)(state, dispatch);
  };
};
var joinDown = function joinDown() {
  return function (_ref43) {
    var state = _ref43.state,
      dispatch = _ref43.dispatch;
    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinDown)(state, dispatch);
  };
};
var joinBackward = function joinBackward() {
  return function (_ref44) {
    var state = _ref44.state,
      dispatch = _ref44.dispatch;
    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinBackward)(state, dispatch);
  };
};
var joinForward = function joinForward() {
  return function (_ref45) {
    var state = _ref45.state,
      dispatch = _ref45.dispatch;
    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinForward)(state, dispatch);
  };
};
var joinItemBackward = function joinItemBackward() {
  return function (_ref46) {
    var tr = _ref46.tr,
      state = _ref46.state,
      dispatch = _ref46.dispatch;
    try {
      var point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.joinPoint)(state.doc, state.selection.$from.pos, -1);
      if (point === null || point === undefined) {
        return false;
      }
      tr.join(point, 2);
      if (dispatch) {
        dispatch(tr);
      }
      return true;
    } catch (_unused) {
      return false;
    }
  };
};
var joinItemForward = function joinItemForward() {
  return function (_ref47) {
    var state = _ref47.state,
      dispatch = _ref47.dispatch,
      tr = _ref47.tr;
    try {
      var point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.joinPoint)(state.doc, state.selection.$from.pos, +1);
      if (point === null || point === undefined) {
        return false;
      }
      tr.join(point, 2);
      if (dispatch) {
        dispatch(tr);
      }
      return true;
    } catch (e) {
      return false;
    }
  };
};
function isMacOS() {
  return typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;
}
function normalizeKeyName(name) {
  var parts = name.split(/-(?!$)/);
  var result = parts[parts.length - 1];
  if (result === 'Space') {
    result = ' ';
  }
  var alt;
  var ctrl;
  var shift;
  var meta;
  for (var i = 0; i < parts.length - 1; i += 1) {
    var mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) {
      meta = true;
    } else if (/^a(lt)?$/i.test(mod)) {
      alt = true;
    } else if (/^(c|ctrl|control)$/i.test(mod)) {
      ctrl = true;
    } else if (/^s(hift)?$/i.test(mod)) {
      shift = true;
    } else if (/^mod$/i.test(mod)) {
      if (isiOS() || isMacOS()) {
        meta = true;
      } else {
        ctrl = true;
      }
    } else {
      throw new Error("Unrecognized modifier name: ".concat(mod));
    }
  }
  if (alt) {
    result = "Alt-".concat(result);
  }
  if (ctrl) {
    result = "Ctrl-".concat(result);
  }
  if (meta) {
    result = "Meta-".concat(result);
  }
  if (shift) {
    result = "Shift-".concat(result);
  }
  return result;
}
var keyboardShortcut = function keyboardShortcut(name) {
  return function (_ref48) {
    var editor = _ref48.editor,
      view = _ref48.view,
      tr = _ref48.tr,
      dispatch = _ref48.dispatch;
    var keys = normalizeKeyName(name).split(/-(?!$)/);
    var key = keys.find(function (item) {
      return !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item);
    });
    var event = new KeyboardEvent('keydown', {
      key: key === 'Space' ? ' ' : key,
      altKey: keys.includes('Alt'),
      ctrlKey: keys.includes('Ctrl'),
      metaKey: keys.includes('Meta'),
      shiftKey: keys.includes('Shift'),
      bubbles: true,
      cancelable: true
    });
    var capturedTransaction = editor.captureTransaction(function () {
      view.someProp('handleKeyDown', function (f) {
        return f(view, event);
      });
    });
    capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach(function (step) {
      var newStep = step.map(tr.mapping);
      if (newStep && dispatch) {
        tr.maybeStep(newStep);
      }
    });
    return true;
  };
};
function isNodeActive(state, typeOrName) {
  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _state$selection = state.selection,
    from = _state$selection.from,
    to = _state$selection.to,
    empty = _state$selection.empty;
  var type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  var nodeRanges = [];
  state.doc.nodesBetween(from, to, function (node, pos) {
    if (node.isText) {
      return;
    }
    var relativeFrom = Math.max(from, pos);
    var relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node: node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  var selectionRange = to - from;
  var matchedNodeRanges = nodeRanges.filter(function (nodeRange) {
    if (!type) {
      return true;
    }
    return type.name === nodeRange.node.type.name;
  }).filter(function (nodeRange) {
    return objectIncludes(nodeRange.node.attrs, attributes, {
      strict: false
    });
  });
  if (empty) {
    return !!matchedNodeRanges.length;
  }
  var range = matchedNodeRanges.reduce(function (sum, nodeRange) {
    return sum + nodeRange.to - nodeRange.from;
  }, 0);
  return range >= selectionRange;
}
var lift = function lift(typeOrName) {
  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function (_ref49) {
    var state = _ref49.state,
      dispatch = _ref49.dispatch;
    var type = getNodeType(typeOrName, state.schema);
    var isActive = isNodeActive(state, type, attributes);
    if (!isActive) {
      return false;
    }
    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.lift)(state, dispatch);
  };
};
var liftEmptyBlock = function liftEmptyBlock() {
  return function (_ref50) {
    var state = _ref50.state,
      dispatch = _ref50.dispatch;
    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.liftEmptyBlock)(state, dispatch);
  };
};
var liftListItem = function liftListItem(typeOrName) {
  return function (_ref51) {
    var state = _ref51.state,
      dispatch = _ref51.dispatch;
    var type = getNodeType(typeOrName, state.schema);
    return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.liftListItem)(type)(state, dispatch);
  };
};
var newlineInCode = function newlineInCode() {
  return function (_ref52) {
    var state = _ref52.state,
      dispatch = _ref52.dispatch;
    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.newlineInCode)(state, dispatch);
  };
};
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) {
    return 'node';
  }
  if (schema.marks[name]) {
    return 'mark';
  }
  return null;
}

/**
 * Remove a property or an array of properties from an object
 * @param obj Object
 * @param key Key to remove
 */
function deleteProps(obj, propOrProps) {
  var props = typeof propOrProps === 'string' ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce(function (newObj, prop) {
    if (!props.includes(prop)) {
      newObj[prop] = obj[prop];
    }
    return newObj;
  }, {});
}
var resetAttributes = function resetAttributes(typeOrName, attributes) {
  return function (_ref53) {
    var tr = _ref53.tr,
      state = _ref53.state,
      dispatch = _ref53.dispatch;
    var nodeType = null;
    var markType = null;
    var schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);
    if (!schemaType) {
      return false;
    }
    if (schemaType === 'node') {
      nodeType = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === 'mark') {
      markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch) {
      tr.selection.ranges.forEach(function (range) {
        state.doc.nodesBetween(range.$from.pos, range.$to.pos, function (node, pos) {
          if (nodeType && nodeType === node.type) {
            tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));
          }
          if (markType && node.marks.length) {
            node.marks.forEach(function (mark) {
              if (markType === mark.type) {
                tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));
              }
            });
          }
        });
      });
    }
    return true;
  };
};
var scrollIntoView = function scrollIntoView() {
  return function (_ref54) {
    var tr = _ref54.tr,
      dispatch = _ref54.dispatch;
    if (dispatch) {
      tr.scrollIntoView();
    }
    return true;
  };
};
var selectAll = function selectAll() {
  return function (_ref55) {
    var tr = _ref55.tr,
      commands = _ref55.commands;
    return commands.setTextSelection({
      from: 0,
      to: tr.doc.content.size
    });
  };
};
var selectNodeBackward = function selectNodeBackward() {
  return function (_ref56) {
    var state = _ref56.state,
      dispatch = _ref56.dispatch;
    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectNodeBackward)(state, dispatch);
  };
};
var selectNodeForward = function selectNodeForward() {
  return function (_ref57) {
    var state = _ref57.state,
      dispatch = _ref57.dispatch;
    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectNodeForward)(state, dispatch);
  };
};
var selectParentNode = function selectParentNode() {
  return function (_ref58) {
    var state = _ref58.state,
      dispatch = _ref58.dispatch;
    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectParentNode)(state, dispatch);
  };
};

// @ts-ignore
var selectTextblockEnd = function selectTextblockEnd() {
  return function (_ref59) {
    var state = _ref59.state,
      dispatch = _ref59.dispatch;
    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectTextblockEnd)(state, dispatch);
  };
};

// @ts-ignore
var selectTextblockStart = function selectTextblockStart() {
  return function (_ref60) {
    var state = _ref60.state,
      dispatch = _ref60.dispatch;
    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectTextblockStart)(state, dispatch);
  };
};
function createDocument(content, schema) {
  var parseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return createNodeFromContent(content, schema, {
    slice: false,
    parseOptions: parseOptions
  });
}
var setContent = function setContent(content) {
  var emitUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var parseOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return function (_ref61) {
    var tr = _ref61.tr,
      editor = _ref61.editor,
      dispatch = _ref61.dispatch;
    var doc = tr.doc;
    var document = createDocument(content, editor.schema, parseOptions);
    if (dispatch) {
      tr.replaceWith(0, doc.content.size, document).setMeta('preventUpdate', !emitUpdate);
    }
    return true;
  };
};
function getMarkAttributes(state, typeOrName) {
  var type = getMarkType(typeOrName, state.schema);
  var _state$selection2 = state.selection,
    from = _state$selection2.from,
    to = _state$selection2.to,
    empty = _state$selection2.empty;
  var marks = [];
  if (empty) {
    if (state.storedMarks) {
      marks.push.apply(marks, _toConsumableArray(state.storedMarks));
    }
    marks.push.apply(marks, _toConsumableArray(state.selection.$head.marks()));
  } else {
    state.doc.nodesBetween(from, to, function (node) {
      marks.push.apply(marks, _toConsumableArray(node.marks));
    });
  }
  var mark = marks.find(function (markItem) {
    return markItem.type.name === type.name;
  });
  if (!mark) {
    return {};
  }
  return _objectSpread({}, mark.attrs);
}

/**
 * Returns a new `Transform` based on all steps of the passed transactions.
 */
function combineTransactionSteps(oldDoc, transactions) {
  var transform = new _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.Transform(oldDoc);
  transactions.forEach(function (transaction) {
    transaction.steps.forEach(function (step) {
      transform.step(step);
    });
  });
  return transform;
}
function defaultBlockAt(match) {
  for (var i = 0; i < match.edgeCount; i += 1) {
    var _match$edge = match.edge(i),
      type = _match$edge.type;
    if (type.isTextblock && !type.hasRequiredAttrs()) {
      return type;
    }
  }
  return null;
}
function findChildren(node, predicate) {
  var nodesWithPos = [];
  node.descendants(function (child, pos) {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos: pos
      });
    }
  });
  return nodesWithPos;
}

/**
 * Same as `findChildren` but searches only within a `range`.
 */
function findChildrenInRange(node, range, predicate) {
  var nodesWithPos = [];
  // if (range.from === range.to) {
  //   const nodeAt = node.nodeAt(range.from)
  //   if (nodeAt) {
  //     nodesWithPos.push({
  //       node: nodeAt,
  //       pos: range.from,
  //     })
  //   }
  // }
  node.nodesBetween(range.from, range.to, function (child, pos) {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos: pos
      });
    }
  });
  return nodesWithPos;
}
function findParentNodeClosestToPos($pos, predicate) {
  for (var i = $pos.depth; i > 0; i -= 1) {
    var node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node: node
      };
    }
  }
}
function findParentNode(predicate) {
  return function (selection) {
    return findParentNodeClosestToPos(selection.$from, predicate);
  };
}
function getHTMLFromFragment(fragment, schema) {
  var documentFragment = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  var temporaryDocument = document.implementation.createHTMLDocument();
  var container = temporaryDocument.createElement('div');
  container.appendChild(documentFragment);
  return container.innerHTML;
}
function getSchema(extensions, editor) {
  var resolvedExtensions = ExtensionManager.resolve(extensions);
  return getSchemaByResolvedExtensions(resolvedExtensions, editor);
}
function generateHTML(doc, extensions) {
  var schema = getSchema(extensions);
  var contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);
  return getHTMLFromFragment(contentNode.content, schema);
}
function generateJSON(html, extensions) {
  var schema = getSchema(extensions);
  var dom = elementFromString(html);
  return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema).parse(dom).toJSON();
}
function _getText(node, options) {
  var range = {
    from: 0,
    to: node.content.size
  };
  return getTextBetween(node, range, options);
}
function generateText(doc, extensions, options) {
  var _ref62 = options || {},
    _ref62$blockSeparator = _ref62.blockSeparator,
    blockSeparator = _ref62$blockSeparator === void 0 ? '\n\n' : _ref62$blockSeparator,
    _ref62$textSerializer = _ref62.textSerializers,
    textSerializers = _ref62$textSerializer === void 0 ? {} : _ref62$textSerializer;
  var schema = getSchema(extensions);
  var contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);
  return _getText(contentNode, {
    blockSeparator: blockSeparator,
    textSerializers: _objectSpread(_objectSpread({}, getTextSerializersFromSchema(schema)), textSerializers)
  });
}
function getNodeAttributes(state, typeOrName) {
  var type = getNodeType(typeOrName, state.schema);
  var _state$selection3 = state.selection,
    from = _state$selection3.from,
    to = _state$selection3.to;
  var nodes = [];
  state.doc.nodesBetween(from, to, function (node) {
    nodes.push(node);
  });
  var node = nodes.reverse().find(function (nodeItem) {
    return nodeItem.type.name === type.name;
  });
  if (!node) {
    return {};
  }
  return _objectSpread({}, node.attrs);
}
function _getAttributes(state, typeOrName) {
  var schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);
  if (schemaType === 'node') {
    return getNodeAttributes(state, typeOrName);
  }
  if (schemaType === 'mark') {
    return getMarkAttributes(state, typeOrName);
  }
  return {};
}

/**
 * Removes duplicated values within an array.
 * Supports numbers, strings and objects.
 */
function removeDuplicates(array) {
  var by = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : JSON.stringify;
  var seen = {};
  return array.filter(function (item) {
    var key = by(item);
    return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;
  });
}

/**
 * Removes duplicated ranges and ranges that are
 * fully captured by other ranges.
 */
function simplifyChangedRanges(changes) {
  var uniqueChanges = removeDuplicates(changes);
  return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter(function (change, index) {
    var rest = uniqueChanges.filter(function (_, i) {
      return i !== index;
    });
    return !rest.some(function (otherChange) {
      return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;
    });
  });
}
/**
 * Returns a list of changed ranges
 * based on the first and last state of all steps.
 */
function getChangedRanges(transform) {
  var mapping = transform.mapping,
    steps = transform.steps;
  var changes = [];
  mapping.maps.forEach(function (stepMap, index) {
    var ranges = [];
    // This accounts for step changes where no range was actually altered
    // e.g. when setting a mark, node attribute, etc.
    // @ts-ignore
    if (!stepMap.ranges.length) {
      var _steps$index = steps[index],
        from = _steps$index.from,
        to = _steps$index.to;
      if (from === undefined || to === undefined) {
        return;
      }
      ranges.push({
        from: from,
        to: to
      });
    } else {
      stepMap.forEach(function (from, to) {
        ranges.push({
          from: from,
          to: to
        });
      });
    }
    ranges.forEach(function (_ref63) {
      var from = _ref63.from,
        to = _ref63.to;
      var newStart = mapping.slice(index).map(from, -1);
      var newEnd = mapping.slice(index).map(to);
      var oldStart = mapping.invert().map(newStart, -1);
      var oldEnd = mapping.invert().map(newEnd);
      changes.push({
        oldRange: {
          from: oldStart,
          to: oldEnd
        },
        newRange: {
          from: newStart,
          to: newEnd
        }
      });
    });
  });
  return simplifyChangedRanges(changes);
}
function getDebugJSON(node) {
  var startOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var isTopNode = node.type === node.type.schema.topNodeType;
  var increment = isTopNode ? 0 : 1;
  var from = startOffset;
  var to = from + node.nodeSize;
  var marks = node.marks.map(function (mark) {
    var output = {
      type: mark.type.name
    };
    if (Object.keys(mark.attrs).length) {
      output.attrs = _objectSpread({}, mark.attrs);
    }
    return output;
  });
  var attrs = _objectSpread({}, node.attrs);
  var output = {
    type: node.type.name,
    from: from,
    to: to
  };
  if (Object.keys(attrs).length) {
    output.attrs = attrs;
  }
  if (marks.length) {
    output.marks = marks;
  }
  if (node.content.childCount) {
    output.content = [];
    node.forEach(function (child, offset) {
      var _a;
      (_a = output.content) === null || _a === void 0 ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));
    });
  }
  if (node.text) {
    output.text = node.text;
  }
  return output;
}
function getMarksBetween(from, to, doc) {
  var marks = [];
  // get all inclusive marks on empty selection
  if (from === to) {
    doc.resolve(from).marks().forEach(function (mark) {
      var $pos = doc.resolve(from - 1);
      var range = getMarkRange($pos, mark.type);
      if (!range) {
        return;
      }
      marks.push(_objectSpread({
        mark: mark
      }, range));
    });
  } else {
    doc.nodesBetween(from, to, function (node, pos) {
      if (!node || node.nodeSize === undefined) {
        return;
      }
      marks.push.apply(marks, _toConsumableArray(node.marks.map(function (mark) {
        return {
          from: pos,
          to: pos + node.nodeSize,
          mark: mark
        };
      })));
    });
  }
  return marks;
}

/**
 * Finds the first node of a given type or name in the current selection.
 * @param state The editor state.
 * @param typeOrName The node type or name.
 * @param pos The position to start searching from.
 * @param maxDepth The maximum depth to search.
 * @returns The node and the depth as an array.
 */
var getNodeAtPosition = function getNodeAtPosition(state, typeOrName, pos) {
  var maxDepth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 20;
  var $pos = state.doc.resolve(pos);
  var currentDepth = maxDepth;
  var node = null;
  while (currentDepth > 0 && node === null) {
    var currentNode = $pos.node(currentDepth);
    if ((currentNode === null || currentNode === void 0 ? void 0 : currentNode.type.name) === typeOrName) {
      node = currentNode;
    } else {
      currentDepth -= 1;
    }
  }
  return [node, currentDepth];
};
function getSplittedAttributes(extensionAttributes, typeName, attributes) {
  return Object.fromEntries(Object.entries(attributes).filter(function (_ref64) {
    var _ref65 = _slicedToArray(_ref64, 1),
      name = _ref65[0];
    var extensionAttribute = extensionAttributes.find(function (item) {
      return item.type === typeName && item.name === name;
    });
    if (!extensionAttribute) {
      return false;
    }
    return extensionAttribute.attribute.keepOnSplit;
  }));
}
function isMarkActive(state, typeOrName) {
  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _state$selection4 = state.selection,
    empty = _state$selection4.empty,
    ranges = _state$selection4.ranges;
  var type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter(function (mark) {
      if (!type) {
        return true;
      }
      return type.name === mark.type.name;
    }).find(function (mark) {
      return objectIncludes(mark.attrs, attributes, {
        strict: false
      });
    });
  }
  var selectionRange = 0;
  var markRanges = [];
  ranges.forEach(function (_ref66) {
    var $from = _ref66.$from,
      $to = _ref66.$to;
    var from = $from.pos;
    var to = $to.pos;
    state.doc.nodesBetween(from, to, function (node, pos) {
      if (!node.isText && !node.marks.length) {
        return;
      }
      var relativeFrom = Math.max(from, pos);
      var relativeTo = Math.min(to, pos + node.nodeSize);
      var range = relativeTo - relativeFrom;
      selectionRange += range;
      markRanges.push.apply(markRanges, _toConsumableArray(node.marks.map(function (mark) {
        return {
          mark: mark,
          from: relativeFrom,
          to: relativeTo
        };
      })));
    });
  });
  if (selectionRange === 0) {
    return false;
  }
  // calculate range of matched mark
  var matchedRange = markRanges.filter(function (markRange) {
    if (!type) {
      return true;
    }
    return type.name === markRange.mark.type.name;
  }).filter(function (markRange) {
    return objectIncludes(markRange.mark.attrs, attributes, {
      strict: false
    });
  }).reduce(function (sum, markRange) {
    return sum + markRange.to - markRange.from;
  }, 0);
  // calculate range of marks that excludes the searched mark
  // for example `code` doesnt allow any other marks
  var excludedRange = markRanges.filter(function (markRange) {
    if (!type) {
      return true;
    }
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce(function (sum, markRange) {
    return sum + markRange.to - markRange.from;
  }, 0);
  // we only include the result of `excludedRange`
  // if there is a match at all
  var range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function _isActive(state, name) {
  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  if (!name) {
    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);
  }
  var schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === 'node') {
    return isNodeActive(state, name, attributes);
  }
  if (schemaType === 'mark') {
    return isMarkActive(state, name, attributes);
  }
  return false;
}
var isAtEndOfNode = function isAtEndOfNode(state, nodeType) {
  var _state$selection5 = state.selection,
    $from = _state$selection5.$from,
    $to = _state$selection5.$to,
    $anchor = _state$selection5.$anchor;
  if (nodeType) {
    var parentNode = findParentNode(function (node) {
      return node.type.name === nodeType;
    })(state.selection);
    if (!parentNode) {
      return false;
    }
    var $parentPos = state.doc.resolve(parentNode.pos + 1);
    if ($anchor.pos + 1 === $parentPos.end()) {
      return true;
    }
    return false;
  }
  if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {
    return false;
  }
  return true;
};
var isAtStartOfNode = function isAtStartOfNode(state) {
  var _state$selection6 = state.selection,
    $from = _state$selection6.$from,
    $to = _state$selection6.$to;
  if ($from.parentOffset > 0 || $from.pos !== $to.pos) {
    return false;
  }
  return true;
};
function isList(name, extensions) {
  var _splitExtensions4 = splitExtensions(extensions),
    nodeExtensions = _splitExtensions4.nodeExtensions;
  var extension = nodeExtensions.find(function (item) {
    return item.name === name;
  });
  if (!extension) {
    return false;
  }
  var context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  var group = callOrReturn(getExtensionField(extension, 'group', context));
  if (typeof group !== 'string') {
    return false;
  }
  return group.split(' ').includes('list');
}
function isNodeEmpty(node) {
  var _a;
  var defaultContent = (_a = node.type.createAndFill()) === null || _a === void 0 ? void 0 : _a.toJSON();
  var content = node.toJSON();
  return JSON.stringify(defaultContent) === JSON.stringify(content);
}
function isNodeSelection(value) {
  return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection;
}
function posToDOMRect(view, from, to) {
  var minPos = 0;
  var maxPos = view.state.doc.content.size;
  var resolvedFrom = minMax(from, minPos, maxPos);
  var resolvedEnd = minMax(to, minPos, maxPos);
  var start = view.coordsAtPos(resolvedFrom);
  var end = view.coordsAtPos(resolvedEnd, -1);
  var top = Math.min(start.top, end.top);
  var bottom = Math.max(start.bottom, end.bottom);
  var left = Math.min(start.left, end.left);
  var right = Math.max(start.right, end.right);
  var width = right - left;
  var height = bottom - top;
  var x = left;
  var y = top;
  var data = {
    top: top,
    bottom: bottom,
    left: left,
    right: right,
    width: width,
    height: height,
    x: x,
    y: y
  };
  return _objectSpread(_objectSpread({}, data), {}, {
    toJSON: function toJSON() {
      return data;
    }
  });
}
function canSetMark(state, tr, newMarkType) {
  var _a;
  var selection = tr.selection;
  var cursor = null;
  if (isTextSelection(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    var currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();
    // There can be no current marks that exclude the new mark
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some(function (mark) {
      return mark.type.excludes(newMarkType);
    });
  }
  var ranges = selection.ranges;
  return ranges.some(function (_ref67) {
    var $from = _ref67.$from,
      $to = _ref67.$to;
    var someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, function (node, _pos, parent) {
      // If we already found a mark that we can enable, return false to bypass the remaining search
      if (someNodeSupportsMark) {
        return false;
      }
      if (node.isInline) {
        var parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        var currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some(function (otherMark) {
          return otherMark.type.excludes(newMarkType);
        });
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
var setMark = function setMark(typeOrName) {
  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function (_ref68) {
    var tr = _ref68.tr,
      state = _ref68.state,
      dispatch = _ref68.dispatch;
    var selection = tr.selection;
    var empty = selection.empty,
      ranges = selection.ranges;
    var type = getMarkType(typeOrName, state.schema);
    if (dispatch) {
      if (empty) {
        var oldAttributes = getMarkAttributes(state, type);
        tr.addStoredMark(type.create(_objectSpread(_objectSpread({}, oldAttributes), attributes)));
      } else {
        ranges.forEach(function (range) {
          var from = range.$from.pos;
          var to = range.$to.pos;
          state.doc.nodesBetween(from, to, function (node, pos) {
            var trimmedFrom = Math.max(pos, from);
            var trimmedTo = Math.min(pos + node.nodeSize, to);
            var someHasMark = node.marks.find(function (mark) {
              return mark.type === type;
            });
            // if there is already a mark of this type
            // we know that we have to merge its attributes
            // otherwise we add a fresh new mark
            if (someHasMark) {
              node.marks.forEach(function (mark) {
                if (type === mark.type) {
                  tr.addMark(trimmedFrom, trimmedTo, type.create(_objectSpread(_objectSpread({}, mark.attrs), attributes)));
                }
              });
            } else {
              tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
            }
          });
        });
      }
    }
    return canSetMark(state, tr, type);
  };
};
var setMeta = function setMeta(key, value) {
  return function (_ref69) {
    var tr = _ref69.tr;
    tr.setMeta(key, value);
    return true;
  };
};
var setNode = function setNode(typeOrName) {
  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function (_ref70) {
    var state = _ref70.state,
      dispatch = _ref70.dispatch,
      chain = _ref70.chain;
    var type = getNodeType(typeOrName, state.schema);
    // TODO: use a fallback like insertContent?
    if (!type.isTextblock) {
      console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.');
      return false;
    }
    return chain()
    // try to convert node to default node if needed
    .command(function (_ref71) {
      var commands = _ref71.commands;
      var canSetBlock = (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.setBlockType)(type, attributes)(state);
      if (canSetBlock) {
        return true;
      }
      return commands.clearNodes();
    }).command(function (_ref72) {
      var updatedState = _ref72.state;
      return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.setBlockType)(type, attributes)(updatedState, dispatch);
    }).run();
  };
};
var setNodeSelection = function setNodeSelection(position) {
  return function (_ref73) {
    var tr = _ref73.tr,
      dispatch = _ref73.dispatch;
    if (dispatch) {
      var doc = tr.doc;
      var from = minMax(position, 0, doc.content.size);
      var selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(doc, from);
      tr.setSelection(selection);
    }
    return true;
  };
};
var setTextSelection = function setTextSelection(position) {
  return function (_ref74) {
    var tr = _ref74.tr,
      dispatch = _ref74.dispatch;
    if (dispatch) {
      var doc = tr.doc;
      var _ref75 = typeof position === 'number' ? {
          from: position,
          to: position
        } : position,
        from = _ref75.from,
        to = _ref75.to;
      var minPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.atStart(doc).from;
      var maxPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.atEnd(doc).to;
      var resolvedFrom = minMax(from, minPos, maxPos);
      var resolvedEnd = minMax(to, minPos, maxPos);
      var selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, resolvedFrom, resolvedEnd);
      tr.setSelection(selection);
    }
    return true;
  };
};
var sinkListItem = function sinkListItem(typeOrName) {
  return function (_ref76) {
    var state = _ref76.state,
      dispatch = _ref76.dispatch;
    var type = getNodeType(typeOrName, state.schema);
    return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.sinkListItem)(type)(state, dispatch);
  };
};
function ensureMarks(state, splittableMarks) {
  var marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    var filteredMarks = marks.filter(function (mark) {
      return splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name);
    });
    state.tr.ensureMarks(filteredMarks);
  }
}
var splitBlock = function splitBlock() {
  var _ref77 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
    _ref77$keepMarks = _ref77.keepMarks,
    keepMarks = _ref77$keepMarks === void 0 ? true : _ref77$keepMarks;
  return function (_ref78) {
    var tr = _ref78.tr,
      state = _ref78.state,
      dispatch = _ref78.dispatch,
      editor = _ref78.editor;
    var selection = tr.selection,
      doc = tr.doc;
    var $from = selection.$from,
      $to = selection.$to;
    var extensionAttributes = editor.extensionManager.attributes;
    var newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
    if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection && selection.node.isBlock) {
      if (!$from.parentOffset || !(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(doc, $from.pos)) {
        return false;
      }
      if (dispatch) {
        if (keepMarks) {
          ensureMarks(state, editor.extensionManager.splittableMarks);
        }
        tr.split($from.pos).scrollIntoView();
      }
      return true;
    }
    if (!$from.parent.isBlock) {
      return false;
    }
    if (dispatch) {
      var atEnd = $to.parentOffset === $to.parent.content.size;
      if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {
        tr.deleteSelection();
      }
      var deflt = $from.depth === 0 ? undefined : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      var types = atEnd && deflt ? [{
        type: deflt,
        attrs: newAttributes
      }] : undefined;
      var can = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);
      if (!types && !can && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{
        type: deflt
      }] : undefined)) {
        can = true;
        types = deflt ? [{
          type: deflt,
          attrs: newAttributes
        }] : undefined;
      }
      if (can) {
        tr.split(tr.mapping.map($from.pos), 1, types);
        if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
          var _first = tr.mapping.map($from.before());
          var $first = tr.doc.resolve(_first);
          if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
            tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
          }
        }
      }
      if (keepMarks) {
        ensureMarks(state, editor.extensionManager.splittableMarks);
      }
      tr.scrollIntoView();
    }
    return true;
  };
};
var splitListItem = function splitListItem(typeOrName) {
  return function (_ref79) {
    var tr = _ref79.tr,
      state = _ref79.state,
      dispatch = _ref79.dispatch,
      editor = _ref79.editor;
    var _a;
    var type = getNodeType(typeOrName, state.schema);
    var _state$selection7 = state.selection,
      $from = _state$selection7.$from,
      $to = _state$selection7.$to;
    // @ts-ignore
    // eslint-disable-next-line
    var node = state.selection.node;
    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
      return false;
    }
    var grandParent = $from.node(-1);
    if (grandParent.type !== type) {
      return false;
    }
    var extensionAttributes = editor.extensionManager.attributes;
    if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
      // In an empty block. If this is a nested list, the wrapping
      // list item should be split. Otherwise, bail out and let next
      // command handle lifting.
      if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {
        return false;
      }
      if (dispatch) {
        var wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.empty;
        // eslint-disable-next-line
        var depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
        // Build a fragment containing empty versions of the structure
        // from the outer list item to the parent node of the cursor
        for (var d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {
          wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from($from.node(d).copy(wrap));
        }
        // eslint-disable-next-line
        var depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
        // Add a second list item with an empty default start node
        var _newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
        var _nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(_newNextTypeAttributes)) || undefined;
        wrap = wrap.append(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(type.createAndFill(null, _nextType) || undefined));
        var start = $from.before($from.depth - (depthBefore - 1));
        tr.replace(start, $from.after(-depthAfter), new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Slice(wrap, 4 - depthBefore, 0));
        var sel = -1;
        tr.doc.nodesBetween(start, tr.doc.content.size, function (n, pos) {
          if (sel > -1) {
            return false;
          }
          if (n.isTextblock && n.content.size === 0) {
            sel = pos + 1;
          }
        });
        if (sel > -1) {
          tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve(sel)));
        }
        tr.scrollIntoView();
      }
      return true;
    }
    var nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    var newTypeAttributes = getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs);
    var newNextTypeAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);
    tr["delete"]($from.pos, $to.pos);
    var types = nextType ? [{
      type: type,
      attrs: newTypeAttributes
    }, {
      type: nextType,
      attrs: newNextTypeAttributes
    }] : [{
      type: type,
      attrs: newTypeAttributes
    }];
    if (!(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, $from.pos, 2)) {
      return false;
    }
    if (dispatch) {
      var selection = state.selection,
        storedMarks = state.storedMarks;
      var splittableMarks = editor.extensionManager.splittableMarks;
      var marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
      tr.split($from.pos, 2, types).scrollIntoView();
      if (!marks || !dispatch) {
        return true;
      }
      var filteredMarks = marks.filter(function (mark) {
        return splittableMarks.includes(mark.type.name);
      });
      tr.ensureMarks(filteredMarks);
    }
    return true;
  };
};
var joinListBackwards = function joinListBackwards(tr, listType) {
  var list = findParentNode(function (node) {
    return node.type === listType;
  })(tr.selection);
  if (!list) {
    return true;
  }
  var before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);
  if (before === undefined) {
    return true;
  }
  var nodeBefore = tr.doc.nodeAt(before);
  var canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, list.pos);
  if (!canJoinBackwards) {
    return true;
  }
  tr.join(list.pos);
  return true;
};
var joinListForwards = function joinListForwards(tr, listType) {
  var list = findParentNode(function (node) {
    return node.type === listType;
  })(tr.selection);
  if (!list) {
    return true;
  }
  var after = tr.doc.resolve(list.start).after(list.depth);
  if (after === undefined) {
    return true;
  }
  var nodeAfter = tr.doc.nodeAt(after);
  var canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, after);
  if (!canJoinForwards) {
    return true;
  }
  tr.join(after);
  return true;
};
var toggleList = function toggleList(listTypeOrName, itemTypeOrName, keepMarks) {
  var attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  return function (_ref80) {
    var editor = _ref80.editor,
      tr = _ref80.tr,
      state = _ref80.state,
      dispatch = _ref80.dispatch,
      chain = _ref80.chain,
      commands = _ref80.commands,
      can = _ref80.can;
    var _editor$extensionMana = editor.extensionManager,
      extensions = _editor$extensionMana.extensions,
      splittableMarks = _editor$extensionMana.splittableMarks;
    var listType = getNodeType(listTypeOrName, state.schema);
    var itemType = getNodeType(itemTypeOrName, state.schema);
    var selection = state.selection,
      storedMarks = state.storedMarks;
    var $from = selection.$from,
      $to = selection.$to;
    var range = $from.blockRange($to);
    var marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
    if (!range) {
      return false;
    }
    var parentList = findParentNode(function (node) {
      return isList(node.type.name, extensions);
    })(selection);
    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {
      // remove list
      if (parentList.node.type === listType) {
        return commands.liftListItem(itemType);
      }
      // change list type
      if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {
        return chain().command(function () {
          tr.setNodeMarkup(parentList.pos, listType);
          return true;
        }).command(function () {
          return joinListBackwards(tr, listType);
        }).command(function () {
          return joinListForwards(tr, listType);
        }).run();
      }
    }
    if (!keepMarks || !marks || !dispatch) {
      return chain()
      // try to convert node to default node if needed
      .command(function () {
        var canWrapInList = can().wrapInList(listType, attributes);
        if (canWrapInList) {
          return true;
        }
        return commands.clearNodes();
      }).wrapInList(listType, attributes).command(function () {
        return joinListBackwards(tr, listType);
      }).command(function () {
        return joinListForwards(tr, listType);
      }).run();
    }
    return chain()
    // try to convert node to default node if needed
    .command(function () {
      var canWrapInList = can().wrapInList(listType, attributes);
      var filteredMarks = marks.filter(function (mark) {
        return splittableMarks.includes(mark.type.name);
      });
      tr.ensureMarks(filteredMarks);
      if (canWrapInList) {
        return true;
      }
      return commands.clearNodes();
    }).wrapInList(listType, attributes).command(function () {
      return joinListBackwards(tr, listType);
    }).command(function () {
      return joinListForwards(tr, listType);
    }).run();
  };
};
var toggleMark = function toggleMark(typeOrName) {
  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return function (_ref81) {
    var state = _ref81.state,
      commands = _ref81.commands;
    var _options$extendEmptyM = options.extendEmptyMarkRange,
      extendEmptyMarkRange = _options$extendEmptyM === void 0 ? false : _options$extendEmptyM;
    var type = getMarkType(typeOrName, state.schema);
    var isActive = isMarkActive(state, type, attributes);
    if (isActive) {
      return commands.unsetMark(type, {
        extendEmptyMarkRange: extendEmptyMarkRange
      });
    }
    return commands.setMark(type, attributes);
  };
};
var toggleNode = function toggleNode(typeOrName, toggleTypeOrName) {
  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return function (_ref82) {
    var state = _ref82.state,
      commands = _ref82.commands;
    var type = getNodeType(typeOrName, state.schema);
    var toggleType = getNodeType(toggleTypeOrName, state.schema);
    var isActive = isNodeActive(state, type, attributes);
    if (isActive) {
      return commands.setNode(toggleType);
    }
    return commands.setNode(type, attributes);
  };
};
var toggleWrap = function toggleWrap(typeOrName) {
  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function (_ref83) {
    var state = _ref83.state,
      commands = _ref83.commands;
    var type = getNodeType(typeOrName, state.schema);
    var isActive = isNodeActive(state, type, attributes);
    if (isActive) {
      return commands.lift(type);
    }
    return commands.wrapIn(type, attributes);
  };
};
var undoInputRule = function undoInputRule() {
  return function (_ref84) {
    var state = _ref84.state,
      dispatch = _ref84.dispatch;
    var plugins = state.plugins;
    for (var i = 0; i < plugins.length; i += 1) {
      var plugin = plugins[i];
      var undoable = void 0;
      // @ts-ignore
      // eslint-disable-next-line
      if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
        if (dispatch) {
          var tr = state.tr;
          var toUndo = undoable.transform;
          for (var j = toUndo.steps.length - 1; j >= 0; j -= 1) {
            tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
          }
          if (undoable.text) {
            var marks = tr.doc.resolve(undoable.from).marks();
            tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
          } else {
            tr["delete"](undoable.from, undoable.to);
          }
        }
        return true;
      }
    }
    return false;
  };
};
var unsetAllMarks = function unsetAllMarks() {
  return function (_ref85) {
    var tr = _ref85.tr,
      dispatch = _ref85.dispatch;
    var selection = tr.selection;
    var empty = selection.empty,
      ranges = selection.ranges;
    if (empty) {
      return true;
    }
    if (dispatch) {
      ranges.forEach(function (range) {
        tr.removeMark(range.$from.pos, range.$to.pos);
      });
    }
    return true;
  };
};
var unsetMark = function unsetMark(typeOrName) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function (_ref86) {
    var tr = _ref86.tr,
      state = _ref86.state,
      dispatch = _ref86.dispatch;
    var _a;
    var _options$extendEmptyM2 = options.extendEmptyMarkRange,
      extendEmptyMarkRange = _options$extendEmptyM2 === void 0 ? false : _options$extendEmptyM2;
    var selection = tr.selection;
    var type = getMarkType(typeOrName, state.schema);
    var $from = selection.$from,
      empty = selection.empty,
      ranges = selection.ranges;
    if (!dispatch) {
      return true;
    }
    if (empty && extendEmptyMarkRange) {
      var from = selection.from,
        to = selection.to;
      var attrs = (_a = $from.marks().find(function (mark) {
        return mark.type === type;
      })) === null || _a === void 0 ? void 0 : _a.attrs;
      var range = getMarkRange($from, type, attrs);
      if (range) {
        from = range.from;
        to = range.to;
      }
      tr.removeMark(from, to, type);
    } else {
      ranges.forEach(function (range) {
        tr.removeMark(range.$from.pos, range.$to.pos, type);
      });
    }
    tr.removeStoredMark(type);
    return true;
  };
};
var updateAttributes = function updateAttributes(typeOrName) {
  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function (_ref87) {
    var tr = _ref87.tr,
      state = _ref87.state,
      dispatch = _ref87.dispatch;
    var nodeType = null;
    var markType = null;
    var schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);
    if (!schemaType) {
      return false;
    }
    if (schemaType === 'node') {
      nodeType = getNodeType(typeOrName, state.schema);
    }
    if (schemaType === 'mark') {
      markType = getMarkType(typeOrName, state.schema);
    }
    if (dispatch) {
      tr.selection.ranges.forEach(function (range) {
        var from = range.$from.pos;
        var to = range.$to.pos;
        state.doc.nodesBetween(from, to, function (node, pos) {
          if (nodeType && nodeType === node.type) {
            tr.setNodeMarkup(pos, undefined, _objectSpread(_objectSpread({}, node.attrs), attributes));
          }
          if (markType && node.marks.length) {
            node.marks.forEach(function (mark) {
              if (markType === mark.type) {
                var trimmedFrom = Math.max(pos, from);
                var trimmedTo = Math.min(pos + node.nodeSize, to);
                tr.addMark(trimmedFrom, trimmedTo, markType.create(_objectSpread(_objectSpread({}, mark.attrs), attributes)));
              }
            });
          }
        });
      });
    }
    return true;
  };
};
var wrapIn = function wrapIn(typeOrName) {
  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function (_ref88) {
    var state = _ref88.state,
      dispatch = _ref88.dispatch;
    var type = getNodeType(typeOrName, state.schema);
    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.wrapIn)(type, attributes)(state, dispatch);
  };
};
var wrapInList = function wrapInList(typeOrName) {
  var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return function (_ref89) {
    var state = _ref89.state,
      dispatch = _ref89.dispatch;
    var type = getNodeType(typeOrName, state.schema);
    return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.wrapInList)(type, attributes)(state, dispatch);
  };
};
var commands = /*#__PURE__*/Object.freeze({
  __proto__: null,
  blur: blur,
  clearContent: clearContent,
  clearNodes: clearNodes,
  command: command,
  createParagraphNear: createParagraphNear,
  cut: cut,
  deleteCurrentNode: deleteCurrentNode,
  deleteNode: deleteNode,
  deleteRange: deleteRange,
  deleteSelection: deleteSelection,
  enter: enter,
  exitCode: exitCode,
  extendMarkRange: extendMarkRange,
  first: first,
  focus: focus,
  forEach: forEach,
  insertContent: insertContent,
  insertContentAt: insertContentAt,
  joinUp: joinUp,
  joinDown: joinDown,
  joinBackward: joinBackward,
  joinForward: joinForward,
  joinItemBackward: joinItemBackward,
  joinItemForward: joinItemForward,
  keyboardShortcut: keyboardShortcut,
  lift: lift,
  liftEmptyBlock: liftEmptyBlock,
  liftListItem: liftListItem,
  newlineInCode: newlineInCode,
  resetAttributes: resetAttributes,
  scrollIntoView: scrollIntoView,
  selectAll: selectAll,
  selectNodeBackward: selectNodeBackward,
  selectNodeForward: selectNodeForward,
  selectParentNode: selectParentNode,
  selectTextblockEnd: selectTextblockEnd,
  selectTextblockStart: selectTextblockStart,
  setContent: setContent,
  setMark: setMark,
  setMeta: setMeta,
  setNode: setNode,
  setNodeSelection: setNodeSelection,
  setTextSelection: setTextSelection,
  sinkListItem: sinkListItem,
  splitBlock: splitBlock,
  splitListItem: splitListItem,
  toggleList: toggleList,
  toggleMark: toggleMark,
  toggleNode: toggleNode,
  toggleWrap: toggleWrap,
  undoInputRule: undoInputRule,
  unsetAllMarks: unsetAllMarks,
  unsetMark: unsetMark,
  updateAttributes: updateAttributes,
  wrapIn: wrapIn,
  wrapInList: wrapInList
});
var Commands = Extension.create({
  name: 'commands',
  addCommands: function addCommands() {
    return _objectSpread({}, commands);
  }
});
var Editable = Extension.create({
  name: 'editable',
  addProseMirrorPlugins: function addProseMirrorPlugins() {
    var _this14 = this;
    return [new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({
      key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('editable'),
      props: {
        editable: function editable() {
          return _this14.editor.options.editable;
        }
      }
    })];
  }
});
var FocusEvents = Extension.create({
  name: 'focusEvents',
  addProseMirrorPlugins: function addProseMirrorPlugins() {
    var editor = this.editor;
    return [new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({
      key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('focusEvents'),
      props: {
        handleDOMEvents: {
          focus: function focus(view, event) {
            editor.isFocused = true;
            var transaction = editor.state.tr.setMeta('focus', {
              event: event
            }).setMeta('addToHistory', false);
            view.dispatch(transaction);
            return false;
          },
          blur: function blur(view, event) {
            editor.isFocused = false;
            var transaction = editor.state.tr.setMeta('blur', {
              event: event
            }).setMeta('addToHistory', false);
            view.dispatch(transaction);
            return false;
          }
        }
      }
    })];
  }
});
var Keymap = Extension.create({
  name: 'keymap',
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this15 = this;
    var handleBackspace = function handleBackspace() {
      return _this15.editor.commands.first(function (_ref90) {
        var commands = _ref90.commands;
        return [function () {
          return commands.undoInputRule();
        },
        // maybe convert first text block node to default node
        function () {
          return commands.command(function (_ref91) {
            var tr = _ref91.tr;
            var selection = tr.selection,
              doc = tr.doc;
            var empty = selection.empty,
              $anchor = selection.$anchor;
            var pos = $anchor.pos,
              parent = $anchor.parent;
            var $parentPos = $anchor.parent.isTextblock ? tr.doc.resolve(pos - 1) : $anchor;
            var parentIsIsolating = $parentPos.parent.type.spec.isolating;
            var parentPos = $anchor.pos - $anchor.parentOffset;
            var isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(doc).from === pos;
            if (!empty || !isAtStart || !parent.type.isTextblock || parent.textContent.length) {
              return false;
            }
            return commands.clearNodes();
          });
        }, function () {
          return commands.deleteSelection();
        }, function () {
          return commands.joinBackward();
        }, function () {
          return commands.selectNodeBackward();
        }];
      });
    };
    var handleDelete = function handleDelete() {
      return _this15.editor.commands.first(function (_ref92) {
        var commands = _ref92.commands;
        return [function () {
          return commands.deleteSelection();
        }, function () {
          return commands.deleteCurrentNode();
        }, function () {
          return commands.joinForward();
        }, function () {
          return commands.selectNodeForward();
        }];
      });
    };
    var handleEnter = function handleEnter() {
      return _this15.editor.commands.first(function (_ref93) {
        var commands = _ref93.commands;
        return [function () {
          return commands.newlineInCode();
        }, function () {
          return commands.createParagraphNear();
        }, function () {
          return commands.liftEmptyBlock();
        }, function () {
          return commands.splitBlock();
        }];
      });
    };
    var baseKeymap = {
      Enter: handleEnter,
      'Mod-Enter': function ModEnter() {
        return _this15.editor.commands.exitCode();
      },
      Backspace: handleBackspace,
      'Mod-Backspace': handleBackspace,
      'Shift-Backspace': handleBackspace,
      Delete: handleDelete,
      'Mod-Delete': handleDelete,
      'Mod-a': function ModA() {
        return _this15.editor.commands.selectAll();
      }
    };
    var pcKeymap = _objectSpread({}, baseKeymap);
    var macKeymap = _objectSpread(_objectSpread({}, baseKeymap), {}, {
      'Ctrl-h': handleBackspace,
      'Alt-Backspace': handleBackspace,
      'Ctrl-d': handleDelete,
      'Ctrl-Alt-Backspace': handleDelete,
      'Alt-Delete': handleDelete,
      'Alt-d': handleDelete,
      'Ctrl-a': function CtrlA() {
        return _this15.editor.commands.selectTextblockStart();
      },
      'Ctrl-e': function CtrlE() {
        return _this15.editor.commands.selectTextblockEnd();
      }
    });
    if (isiOS() || isMacOS()) {
      return macKeymap;
    }
    return pcKeymap;
  },
  addProseMirrorPlugins: function addProseMirrorPlugins() {
    var _this16 = this;
    return [
    // With this plugin we check if the whole document was selected and deleted.
    // In this case we will additionally call `clearNodes()` to convert e.g. a heading
    // to a paragraph if necessary.
    // This is an alternative to ProseMirror's `AllSelection`, which doesnt work well
    // with many other commands.
    new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({
      key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('clearDocument'),
      appendTransaction: function appendTransaction(transactions, oldState, newState) {
        var docChanges = transactions.some(function (transaction) {
          return transaction.docChanged;
        }) && !oldState.doc.eq(newState.doc);
        if (!docChanges) {
          return;
        }
        var _oldState$selection = oldState.selection,
          empty = _oldState$selection.empty,
          from = _oldState$selection.from,
          to = _oldState$selection.to;
        var allFrom = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(oldState.doc).from;
        var allEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atEnd(oldState.doc).to;
        var allWasSelected = from === allFrom && to === allEnd;
        if (empty || !allWasSelected) {
          return;
        }
        var isEmpty = newState.doc.textBetween(0, newState.doc.content.size, ' ', ' ').length === 0;
        if (!isEmpty) {
          return;
        }
        var tr = newState.tr;
        var state = createChainableState({
          state: newState,
          transaction: tr
        });
        var _CommandManager3 = new CommandManager({
            editor: _this16.editor,
            state: state
          }),
          commands = _CommandManager3.commands;
        commands.clearNodes();
        if (!tr.steps.length) {
          return;
        }
        return tr;
      }
    })];
  }
});
var Tabindex = Extension.create({
  name: 'tabindex',
  addProseMirrorPlugins: function addProseMirrorPlugins() {
    return [new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({
      key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('tabindex'),
      props: {
        attributes: this.editor.isEditable ? {
          tabindex: '0'
        } : {}
      }
    })];
  }
});
var extensions = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ClipboardTextSerializer: ClipboardTextSerializer,
  Commands: Commands,
  Editable: Editable,
  FocusEvents: FocusEvents,
  Keymap: Keymap,
  Tabindex: Tabindex
});
var style = ".ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}";
function createStyleTag(style, nonce, suffix) {
  var tiptapStyleTag = document.querySelector("style[data-tiptap-style".concat(suffix ? "-".concat(suffix) : '', "]"));
  if (tiptapStyleTag !== null) {
    return tiptapStyleTag;
  }
  var styleNode = document.createElement('style');
  if (nonce) {
    styleNode.setAttribute('nonce', nonce);
  }
  styleNode.setAttribute("data-tiptap-style".concat(suffix ? "-".concat(suffix) : ''), '');
  styleNode.innerHTML = style;
  document.getElementsByTagName('head')[0].appendChild(styleNode);
  return styleNode;
}
var Editor = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Editor, _EventEmitter);
  function Editor() {
    var _this17;
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, Editor);
    _this17 = _callSuper(this, Editor);
    _this17.isFocused = false;
    _this17.extensionStorage = {};
    _this17.options = {
      element: document.createElement('div'),
      content: '',
      injectCSS: true,
      injectNonce: undefined,
      extensions: [],
      autofocus: false,
      editable: true,
      editorProps: {},
      parseOptions: {},
      enableInputRules: true,
      enablePasteRules: true,
      enableCoreExtensions: true,
      onBeforeCreate: function onBeforeCreate() {
        return null;
      },
      onCreate: function onCreate() {
        return null;
      },
      onUpdate: function onUpdate() {
        return null;
      },
      onSelectionUpdate: function onSelectionUpdate() {
        return null;
      },
      onTransaction: function onTransaction() {
        return null;
      },
      onFocus: function onFocus() {
        return null;
      },
      onBlur: function onBlur() {
        return null;
      },
      onDestroy: function onDestroy() {
        return null;
      }
    };
    _this17.isCapturingTransaction = false;
    _this17.capturedTransaction = null;
    _this17.setOptions(options);
    _this17.createExtensionManager();
    _this17.createCommandManager();
    _this17.createSchema();
    _this17.on('beforeCreate', _this17.options.onBeforeCreate);
    _this17.emit('beforeCreate', {
      editor: _assertThisInitialized(_this17)
    });
    _this17.createView();
    _this17.injectCSS();
    _this17.on('create', _this17.options.onCreate);
    _this17.on('update', _this17.options.onUpdate);
    _this17.on('selectionUpdate', _this17.options.onSelectionUpdate);
    _this17.on('transaction', _this17.options.onTransaction);
    _this17.on('focus', _this17.options.onFocus);
    _this17.on('blur', _this17.options.onBlur);
    _this17.on('destroy', _this17.options.onDestroy);
    window.setTimeout(function () {
      if (_this17.isDestroyed) {
        return;
      }
      _this17.commands.focus(_this17.options.autofocus);
      _this17.emit('create', {
        editor: _assertThisInitialized(_this17)
      });
    }, 0);
    return _this17;
  }
  /**
   * Returns the editor storage.
   */
  _createClass(Editor, [{
    key: "storage",
    get: function get() {
      return this.extensionStorage;
    }
    /**
     * An object of all registered commands.
     */
  }, {
    key: "commands",
    get: function get() {
      return this.commandManager.commands;
    }
    /**
     * Create a command chain to call multiple commands at once.
     */
  }, {
    key: "chain",
    value: function chain() {
      return this.commandManager.chain();
    }
    /**
     * Check if a command or a command chain can be executed. Without executing it.
     */
  }, {
    key: "can",
    value: function can() {
      return this.commandManager.can();
    }
    /**
     * Inject CSS styles.
     */
  }, {
    key: "injectCSS",
    value: function injectCSS() {
      if (this.options.injectCSS && document) {
        this.css = createStyleTag(style, this.options.injectNonce);
      }
    }
    /**
     * Update editor options.
     *
     * @param options A list of options
     */
  }, {
    key: "setOptions",
    value: function setOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.options = _objectSpread(_objectSpread({}, this.options), options);
      if (!this.view || !this.state || this.isDestroyed) {
        return;
      }
      if (this.options.editorProps) {
        this.view.setProps(this.options.editorProps);
      }
      this.view.updateState(this.state);
    }
    /**
     * Update editable state of the editor.
     */
  }, {
    key: "setEditable",
    value: function setEditable(editable) {
      var emitUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      this.setOptions({
        editable: editable
      });
      if (emitUpdate) {
        this.emit('update', {
          editor: this,
          transaction: this.state.tr
        });
      }
    }
    /**
     * Returns whether the editor is editable.
     */
  }, {
    key: "isEditable",
    get: function get() {
      // since plugins are applied after creating the view
      // `editable` is always `true` for one tick.
      // thats why we also have to check for `options.editable`
      return this.options.editable && this.view && this.view.editable;
    }
    /**
     * Returns the editor state.
     */
  }, {
    key: "state",
    get: function get() {
      return this.view.state;
    }
    /**
     * Register a ProseMirror plugin.
     *
     * @param plugin A ProseMirror plugin
     * @param handlePlugins Control how to merge the plugin into the existing plugins.
     */
  }, {
    key: "registerPlugin",
    value: function registerPlugin(plugin, handlePlugins) {
      var plugins = isFunction(handlePlugins) ? handlePlugins(plugin, _toConsumableArray(this.state.plugins)) : [].concat(_toConsumableArray(this.state.plugins), [plugin]);
      var state = this.state.reconfigure({
        plugins: plugins
      });
      this.view.updateState(state);
    }
    /**
     * Unregister a ProseMirror plugin.
     *
     * @param nameOrPluginKey The plugins name
     */
  }, {
    key: "unregisterPlugin",
    value: function unregisterPlugin(nameOrPluginKey) {
      if (this.isDestroyed) {
        return;
      }
      // @ts-ignore
      var name = typeof nameOrPluginKey === 'string' ? "".concat(nameOrPluginKey, "$") : nameOrPluginKey.key;
      var state = this.state.reconfigure({
        // @ts-ignore
        plugins: this.state.plugins.filter(function (plugin) {
          return !plugin.key.startsWith(name);
        })
      });
      this.view.updateState(state);
    }
    /**
     * Creates an extension manager.
     */
  }, {
    key: "createExtensionManager",
    value: function createExtensionManager() {
      var coreExtensions = this.options.enableCoreExtensions ? Object.values(extensions) : [];
      var allExtensions = [].concat(_toConsumableArray(coreExtensions), _toConsumableArray(this.options.extensions)).filter(function (extension) {
        return ['extension', 'node', 'mark'].includes(extension === null || extension === void 0 ? void 0 : extension.type);
      });
      this.extensionManager = new ExtensionManager(allExtensions, this);
    }
    /**
     * Creates an command manager.
     */
  }, {
    key: "createCommandManager",
    value: function createCommandManager() {
      this.commandManager = new CommandManager({
        editor: this
      });
    }
    /**
     * Creates a ProseMirror schema.
     */
  }, {
    key: "createSchema",
    value: function createSchema() {
      this.schema = this.extensionManager.schema;
    }
    /**
     * Creates a ProseMirror view.
     */
  }, {
    key: "createView",
    value: function createView() {
      var doc = createDocument(this.options.content, this.schema, this.options.parseOptions);
      var selection = resolveFocusPosition(doc, this.options.autofocus);
      this.view = new _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.EditorView(this.options.element, _objectSpread(_objectSpread({}, this.options.editorProps), {}, {
        dispatchTransaction: this.dispatchTransaction.bind(this),
        state: _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.create({
          doc: doc,
          selection: selection || undefined
        })
      }));
      // `editor.view` is not yet available at this time.
      // Therefore we will add all plugins and node views directly afterwards.
      var newState = this.state.reconfigure({
        plugins: this.extensionManager.plugins
      });
      this.view.updateState(newState);
      this.createNodeViews();
      this.prependClass();
      // Lets store the editor instance in the DOM element.
      // So well have access to it for tests.
      var dom = this.view.dom;
      dom.editor = this;
    }
    /**
     * Creates all node views.
     */
  }, {
    key: "createNodeViews",
    value: function createNodeViews() {
      this.view.setProps({
        nodeViews: this.extensionManager.nodeViews
      });
    }
    /**
     * Prepend class name to element.
     */
  }, {
    key: "prependClass",
    value: function prependClass() {
      this.view.dom.className = "tiptap ".concat(this.view.dom.className);
    }
  }, {
    key: "captureTransaction",
    value: function captureTransaction(fn) {
      this.isCapturingTransaction = true;
      fn();
      this.isCapturingTransaction = false;
      var tr = this.capturedTransaction;
      this.capturedTransaction = null;
      return tr;
    }
    /**
     * The callback over which to send transactions (state updates) produced by the view.
     *
     * @param transaction An editor state transaction
     */
  }, {
    key: "dispatchTransaction",
    value: function dispatchTransaction(transaction) {
      var _this18 = this;
      // if the editor / the view of the editor was destroyed
      // the transaction should not be dispatched as there is no view anymore.
      if (this.view.isDestroyed) {
        return;
      }
      if (this.isCapturingTransaction) {
        if (!this.capturedTransaction) {
          this.capturedTransaction = transaction;
          return;
        }
        transaction.steps.forEach(function (step) {
          var _a;
          return (_a = _this18.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);
        });
        return;
      }
      var state = this.state.apply(transaction);
      var selectionHasChanged = !this.state.selection.eq(state.selection);
      this.view.updateState(state);
      this.emit('transaction', {
        editor: this,
        transaction: transaction
      });
      if (selectionHasChanged) {
        this.emit('selectionUpdate', {
          editor: this,
          transaction: transaction
        });
      }
      var focus = transaction.getMeta('focus');
      var blur = transaction.getMeta('blur');
      if (focus) {
        this.emit('focus', {
          editor: this,
          event: focus.event,
          transaction: transaction
        });
      }
      if (blur) {
        this.emit('blur', {
          editor: this,
          event: blur.event,
          transaction: transaction
        });
      }
      if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {
        return;
      }
      this.emit('update', {
        editor: this,
        transaction: transaction
      });
    }
    /**
     * Get attributes of the currently selected node or mark.
     */
  }, {
    key: "getAttributes",
    value: function getAttributes(nameOrType) {
      return _getAttributes(this.state, nameOrType);
    }
  }, {
    key: "isActive",
    value: function isActive(nameOrAttributes, attributesOrUndefined) {
      var name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null;
      var attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes;
      return _isActive(this.state, name, attributes);
    }
    /**
     * Get the document as JSON.
     */
  }, {
    key: "getJSON",
    value: function getJSON() {
      return this.state.doc.toJSON();
    }
    /**
     * Get the document as HTML.
     */
  }, {
    key: "getHTML",
    value: function getHTML() {
      return getHTMLFromFragment(this.state.doc.content, this.schema);
    }
    /**
     * Get the document as text.
     */
  }, {
    key: "getText",
    value: function getText(options) {
      var _ref94 = options || {},
        _ref94$blockSeparator = _ref94.blockSeparator,
        blockSeparator = _ref94$blockSeparator === void 0 ? '\n\n' : _ref94$blockSeparator,
        _ref94$textSerializer = _ref94.textSerializers,
        textSerializers = _ref94$textSerializer === void 0 ? {} : _ref94$textSerializer;
      return _getText(this.state.doc, {
        blockSeparator: blockSeparator,
        textSerializers: _objectSpread(_objectSpread({}, getTextSerializersFromSchema(this.schema)), textSerializers)
      });
    }
    /**
     * Check if there is no content.
     */
  }, {
    key: "isEmpty",
    get: function get() {
      return isNodeEmpty(this.state.doc);
    }
    /**
     * Get the number of characters for the current document.
     *
     * @deprecated
     */
  }, {
    key: "getCharacterCount",
    value: function getCharacterCount() {
      console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.');
      return this.state.doc.content.size - 2;
    }
    /**
     * Destroy the editor.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      this.emit('destroy');
      if (this.view) {
        this.view.destroy();
      }
      this.removeAllListeners();
    }
    /**
     * Check if the editor is already destroyed.
     */
  }, {
    key: "isDestroyed",
    get: function get() {
      var _a;
      // @ts-ignore
      return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);
    }
  }]);
  return Editor;
}(EventEmitter);
/**
 * Build an input rule that adds a mark when the
 * matched text is typed into it.
 */
function markInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: function handler(_ref95) {
      var state = _ref95.state,
        range = _ref95.range,
        match = _ref95.match;
      var attributes = callOrReturn(config.getAttributes, undefined, match);
      if (attributes === false || attributes === null) {
        return null;
      }
      var tr = state.tr;
      var captureGroup = match[match.length - 1];
      var fullMatch = match[0];
      if (captureGroup) {
        var startSpaces = fullMatch.search(/\S/);
        var textStart = range.from + fullMatch.indexOf(captureGroup);
        var textEnd = textStart + captureGroup.length;
        var excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter(function (item) {
          // @ts-ignore
          var excluded = item.mark.type.excluded;
          return excluded.find(function (type) {
            return type === config.type && type !== item.mark.type;
          });
        }).filter(function (item) {
          return item.to > textStart;
        });
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr["delete"](textEnd, range.to);
        }
        if (textStart > range.from) {
          tr["delete"](range.from + startSpaces, textStart);
        }
        var markEnd = range.from + startSpaces + captureGroup.length;
        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr.removeStoredMark(config.type);
      }
    }
  });
}

/**
 * Build an input rule that adds a node when the
 * matched text is typed into it.
 */
function nodeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: function handler(_ref96) {
      var state = _ref96.state,
        range = _ref96.range,
        match = _ref96.match;
      var attributes = callOrReturn(config.getAttributes, undefined, match) || {};
      var tr = state.tr;
      var start = range.from;
      var end = range.to;
      var newNode = config.type.create(attributes);
      if (match[1]) {
        var offset = match[0].lastIndexOf(match[1]);
        var matchStart = start + offset;
        if (matchStart > end) {
          matchStart = end;
        } else {
          end = matchStart + match[1].length;
        }
        // insert last typed character
        var lastChar = match[0][match[0].length - 1];
        tr.insertText(lastChar, start + match[0].length - 1);
        // insert node from input rule
        tr.replaceWith(matchStart, end, newNode);
      } else if (match[0]) {
        tr.insert(start - 1, config.type.create(attributes))["delete"](tr.mapping.map(start), tr.mapping.map(end));
      }
      tr.scrollIntoView();
    }
  });
}

/**
 * Build an input rule that changes the type of a textblock when the
 * matched text is typed into it. When using a regular expresion youll
 * probably want the regexp to start with `^`, so that the pattern can
 * only occur at the start of a textblock.
 */
function textblockTypeInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: function handler(_ref97) {
      var state = _ref97.state,
        range = _ref97.range,
        match = _ref97.match;
      var $start = state.doc.resolve(range.from);
      var attributes = callOrReturn(config.getAttributes, undefined, match) || {};
      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {
        return null;
      }
      state.tr["delete"](range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);
    }
  });
}

/**
 * Build an input rule that replaces text when the
 * matched text is typed into it.
 */
function textInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: function handler(_ref98) {
      var state = _ref98.state,
        range = _ref98.range,
        match = _ref98.match;
      var insert = config.replace;
      var start = range.from;
      var end = range.to;
      if (match[1]) {
        var offset = match[0].lastIndexOf(match[1]);
        insert += match[0].slice(offset + match[1].length);
        start += offset;
        var cutOff = start - end;
        if (cutOff > 0) {
          insert = match[0].slice(offset - cutOff, offset) + insert;
          start = end;
        }
      }
      state.tr.insertText(insert, start, end);
    }
  });
}

/**
 * Build an input rule for automatically wrapping a textblock when a
 * given string is typed. When using a regular expresion youll
 * probably want the regexp to start with `^`, so that the pattern can
 * only occur at the start of a textblock.
 *
 * `type` is the type of node to wrap in.
 *
 * By default, if theres a node with the same type above the newly
 * wrapped node, the rule will try to join those
 * two nodes. You can pass a join predicate, which takes a regular
 * expression match and the node before the wrapped node, and can
 * return a boolean to indicate whether a join should happen.
 */
function wrappingInputRule(config) {
  return new InputRule({
    find: config.find,
    handler: function handler(_ref99) {
      var state = _ref99.state,
        range = _ref99.range,
        match = _ref99.match,
        chain = _ref99.chain;
      var attributes = callOrReturn(config.getAttributes, undefined, match) || {};
      var tr = state.tr["delete"](range.from, range.to);
      var $start = tr.doc.resolve(range.from);
      var blockRange = $start.blockRange();
      var wrapping = blockRange && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.findWrapping)(blockRange, config.type, attributes);
      if (!wrapping) {
        return null;
      }
      tr.wrap(blockRange, wrapping);
      if (config.keepMarks && config.editor) {
        var selection = state.selection,
          storedMarks = state.storedMarks;
        var splittableMarks = config.editor.extensionManager.splittableMarks;
        var marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
        if (marks) {
          var filteredMarks = marks.filter(function (mark) {
            return splittableMarks.includes(mark.type.name);
          });
          tr.ensureMarks(filteredMarks);
        }
      }
      if (config.keepAttributes) {
        /** If the nodeType is `bulletList` or `orderedList` set the `nodeType` as `listItem` */
        var nodeType = config.type.name === 'bulletList' || config.type.name === 'orderedList' ? 'listItem' : 'taskList';
        chain().updateAttributes(nodeType, attributes).run();
      }
      var before = tr.doc.resolve(range.from - 1).nodeBefore;
      if (before && before.type === config.type && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {
        tr.join(range.from - 1);
      }
    }
  });
}
var Mark = /*#__PURE__*/function () {
  function Mark() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, Mark);
    this.type = 'mark';
    this.name = 'mark';
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = _objectSpread(_objectSpread({}, this.config), config);
    this.name = this.config.name;
    if (config.defaultOptions) {
      console.warn("[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"".concat(this.name, "\"."));
    }
    // TODO: remove `addOptions` fallback
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, 'addOptions', {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {
      name: this.name,
      options: this.options
    })) || {};
  }
  _createClass(Mark, [{
    key: "configure",
    value: function configure() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // return a new instance so we can use the same extension
      // with different calls of `configure`
      var extension = this.extend();
      extension.options = mergeDeep(this.options, options);
      extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
  }, {
    key: "extend",
    value: function extend() {
      var extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var extension = new Mark(extendedConfig);
      extension.parent = this;
      this.child = extension;
      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
      if (extendedConfig.defaultOptions) {
        console.warn("[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"".concat(extension.name, "\"."));
      }
      extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {
        name: extension.name
      }));
      extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
  }], [{
    key: "create",
    value: function create() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new Mark(config);
    }
  }, {
    key: "handleExit",
    value: function handleExit(_ref100) {
      var editor = _ref100.editor,
        mark = _ref100.mark;
      var tr = editor.state.tr;
      var currentPos = editor.state.selection.$from;
      var isAtEnd = currentPos.pos === currentPos.end();
      if (isAtEnd) {
        var currentMarks = currentPos.marks();
        var isInMark = !!currentMarks.find(function (m) {
          return (m === null || m === void 0 ? void 0 : m.type.name) === mark.name;
        });
        if (!isInMark) {
          return false;
        }
        var removeMark = currentMarks.find(function (m) {
          return (m === null || m === void 0 ? void 0 : m.type.name) === mark.name;
        });
        if (removeMark) {
          tr.removeStoredMark(removeMark);
        }
        tr.insertText(' ', currentPos.pos);
        editor.view.dispatch(tr);
        return true;
      }
      return false;
    }
  }]);
  return Mark;
}();
var Node = /*#__PURE__*/function () {
  function Node() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, Node);
    this.type = 'node';
    this.name = 'node';
    this.parent = null;
    this.child = null;
    this.config = {
      name: this.name,
      defaultOptions: {}
    };
    this.config = _objectSpread(_objectSpread({}, this.config), config);
    this.name = this.config.name;
    if (config.defaultOptions) {
      console.warn("[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"".concat(this.name, "\"."));
    }
    // TODO: remove `addOptions` fallback
    this.options = this.config.defaultOptions;
    if (this.config.addOptions) {
      this.options = callOrReturn(getExtensionField(this, 'addOptions', {
        name: this.name
      }));
    }
    this.storage = callOrReturn(getExtensionField(this, 'addStorage', {
      name: this.name,
      options: this.options
    })) || {};
  }
  _createClass(Node, [{
    key: "configure",
    value: function configure() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // return a new instance so we can use the same extension
      // with different calls of `configure`
      var extension = this.extend();
      extension.options = mergeDeep(this.options, options);
      extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
  }, {
    key: "extend",
    value: function extend() {
      var extendedConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var extension = new Node(extendedConfig);
      extension.parent = this;
      this.child = extension;
      extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;
      if (extendedConfig.defaultOptions) {
        console.warn("[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"".concat(extension.name, "\"."));
      }
      extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {
        name: extension.name
      }));
      extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {
        name: extension.name,
        options: extension.options
      }));
      return extension;
    }
  }], [{
    key: "create",
    value: function create() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new Node(config);
    }
  }]);
  return Node;
}();
function isAndroid() {
  return navigator.platform === 'Android' || /android/i.test(navigator.userAgent);
}
var NodeView = /*#__PURE__*/function () {
  function NodeView(component, props, options) {
    _classCallCheck(this, NodeView);
    this.isDragging = false;
    this.component = component;
    this.editor = props.editor;
    this.options = _objectSpread({
      stopEvent: null,
      ignoreMutation: null
    }, options);
    this.extension = props.extension;
    this.node = props.node;
    this.decorations = props.decorations;
    this.getPos = props.getPos;
    this.mount();
  }
  _createClass(NodeView, [{
    key: "mount",
    value: function mount() {
      // eslint-disable-next-line
      return;
    }
  }, {
    key: "dom",
    get: function get() {
      return this.editor.view.dom;
    }
  }, {
    key: "contentDOM",
    get: function get() {
      return null;
    }
  }, {
    key: "onDragStart",
    value: function onDragStart(event) {
      var _a, _b, _c, _d, _e, _f, _g;
      var view = this.editor.view;
      var target = event.target;
      // get the drag handle element
      // `closest` is not available for text nodes so we may have to use its parent
      var dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest('[data-drag-handle]') : target.closest('[data-drag-handle]');
      if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {
        return;
      }
      var x = 0;
      var y = 0;
      // calculate offset for drag element if we use a different drag handle element
      if (this.dom !== dragHandle) {
        var domBox = this.dom.getBoundingClientRect();
        var handleBox = dragHandle.getBoundingClientRect();
        // In React, we have to go through nativeEvent to reach offsetX/offsetY.
        var offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;
        var offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;
        x = handleBox.x - domBox.x + offsetX;
        y = handleBox.y - domBox.y + offsetY;
      }
      (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(this.dom, x, y);
      // we need to tell ProseMirror that we want to move the whole node
      // so we create a NodeSelection
      var selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(view.state.doc, this.getPos());
      var transaction = view.state.tr.setSelection(selection);
      view.dispatch(transaction);
    }
  }, {
    key: "stopEvent",
    value: function stopEvent(event) {
      var _this19 = this;
      var _a;
      if (!this.dom) {
        return false;
      }
      if (typeof this.options.stopEvent === 'function') {
        return this.options.stopEvent({
          event: event
        });
      }
      var target = event.target;
      var isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));
      // any event from child nodes should be handled by ProseMirror
      if (!isInElement) {
        return false;
      }
      var isDragEvent = event.type.startsWith('drag');
      var isDropEvent = event.type === 'drop';
      var isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable;
      // any input event within node views should be ignored by ProseMirror
      if (isInput && !isDropEvent && !isDragEvent) {
        return true;
      }
      var isEditable = this.editor.isEditable;
      var isDragging = this.isDragging;
      var isDraggable = !!this.node.type.spec.draggable;
      var isSelectable = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(this.node);
      var isCopyEvent = event.type === 'copy';
      var isPasteEvent = event.type === 'paste';
      var isCutEvent = event.type === 'cut';
      var isClickEvent = event.type === 'mousedown';
      // ProseMirror tries to drag selectable nodes
      // even if `draggable` is set to `false`
      // this fix prevents that
      if (!isDraggable && isSelectable && isDragEvent) {
        event.preventDefault();
      }
      if (isDraggable && isDragEvent && !isDragging) {
        event.preventDefault();
        return false;
      }
      // we have to store that dragging started
      if (isDraggable && isEditable && !isDragging && isClickEvent) {
        var dragHandle = target.closest('[data-drag-handle]');
        var isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));
        if (isValidDragHandle) {
          this.isDragging = true;
          document.addEventListener('dragend', function () {
            _this19.isDragging = false;
          }, {
            once: true
          });
          document.addEventListener('drop', function () {
            _this19.isDragging = false;
          }, {
            once: true
          });
          document.addEventListener('mouseup', function () {
            _this19.isDragging = false;
          }, {
            once: true
          });
        }
      }
      // these events are handled by prosemirror
      if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {
        return false;
      }
      return true;
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      if (!this.dom || !this.contentDOM) {
        return true;
      }
      if (typeof this.options.ignoreMutation === 'function') {
        return this.options.ignoreMutation({
          mutation: mutation
        });
      }
      // a leaf/atom node is like a black box for ProseMirror
      // and should be fully handled by the node view
      if (this.node.isLeaf || this.node.isAtom) {
        return true;
      }
      // ProseMirror should handle any selections
      if (mutation.type === 'selection') {
        return false;
      }
      // try to prevent a bug on iOS and Android that will break node views on enter
      // this is because ProseMirror cant preventDispatch on enter
      // this will lead to a re-render of the node view on enter
      // see: https://github.com/ueberdosis/tiptap/issues/1214
      // see: https://github.com/ueberdosis/tiptap/issues/2534
      if (this.dom.contains(mutation.target) && mutation.type === 'childList' && (isiOS() || isAndroid()) && this.editor.isFocused) {
        var changedNodes = [].concat(_toConsumableArray(Array.from(mutation.addedNodes)), _toConsumableArray(Array.from(mutation.removedNodes)));
        // well check if every changed node is contentEditable
        // to make sure its probably mutated by ProseMirror
        if (changedNodes.every(function (node) {
          return node.isContentEditable;
        })) {
          return false;
        }
      }
      // we will allow mutation contentDOM with attributes
      // so we can for example adding classes within our node view
      if (this.contentDOM === mutation.target && mutation.type === 'attributes') {
        return true;
      }
      // ProseMirror should handle any changes within contentDOM
      if (this.contentDOM.contains(mutation.target)) {
        return false;
      }
      return true;
    }
  }, {
    key: "updateAttributes",
    value: function updateAttributes(attributes) {
      var _this20 = this;
      this.editor.commands.command(function (_ref101) {
        var tr = _ref101.tr;
        var pos = _this20.getPos();
        tr.setNodeMarkup(pos, undefined, _objectSpread(_objectSpread({}, _this20.node.attrs), attributes));
        return true;
      });
    }
  }, {
    key: "deleteNode",
    value: function deleteNode() {
      var from = this.getPos();
      var to = from + this.node.nodeSize;
      this.editor.commands.deleteRange({
        from: from,
        to: to
      });
    }
  }]);
  return NodeView;
}();
/**
 * Build an paste rule that adds a mark when the
 * matched text is pasted into it.
 */
function markPasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: function handler(_ref102) {
      var state = _ref102.state,
        range = _ref102.range,
        match = _ref102.match,
        pasteEvent = _ref102.pasteEvent;
      var attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent);
      if (attributes === false || attributes === null) {
        return null;
      }
      var tr = state.tr;
      var captureGroup = match[match.length - 1];
      var fullMatch = match[0];
      var markEnd = range.to;
      if (captureGroup) {
        var startSpaces = fullMatch.search(/\S/);
        var textStart = range.from + fullMatch.indexOf(captureGroup);
        var textEnd = textStart + captureGroup.length;
        var excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter(function (item) {
          // @ts-ignore
          var excluded = item.mark.type.excluded;
          return excluded.find(function (type) {
            return type === config.type && type !== item.mark.type;
          });
        }).filter(function (item) {
          return item.to > textStart;
        });
        if (excludedMarks.length) {
          return null;
        }
        if (textEnd < range.to) {
          tr["delete"](textEnd, range.to);
        }
        if (textStart > range.from) {
          tr["delete"](range.from + startSpaces, textStart);
        }
        markEnd = range.from + startSpaces + captureGroup.length;
        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));
        tr.removeStoredMark(config.type);
      }
    }
  });
}

// source: https://stackoverflow.com/a/6969486
function escapeForRegEx(string) {
  return string.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
}
function isString(value) {
  return typeof value === 'string';
}

/**
 * Build an paste rule that adds a node when the
 * matched text is pasted into it.
 */
function nodePasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: function handler(_ref103) {
      var match = _ref103.match,
        chain = _ref103.chain,
        range = _ref103.range,
        pasteEvent = _ref103.pasteEvent;
      var attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent);
      if (attributes === false || attributes === null) {
        return null;
      }
      if (match.input) {
        chain().deleteRange(range).insertContentAt(range.from, {
          type: config.type.name,
          attrs: attributes
        });
      }
    }
  });
}

/**
 * Build an paste rule that replaces text when the
 * matched text is pasted into it.
 */
function textPasteRule(config) {
  return new PasteRule({
    find: config.find,
    handler: function handler(_ref104) {
      var state = _ref104.state,
        range = _ref104.range,
        match = _ref104.match;
      var insert = config.replace;
      var start = range.from;
      var end = range.to;
      if (match[1]) {
        var offset = match[0].lastIndexOf(match[1]);
        insert += match[0].slice(offset + match[1].length);
        start += offset;
        var cutOff = start - end;
        if (cutOff > 0) {
          insert = match[0].slice(offset - cutOff, offset) + insert;
          start = end;
        }
      }
      state.tr.insertText(insert, start, end);
    }
  });
}
var Tracker = /*#__PURE__*/function () {
  function Tracker(transaction) {
    _classCallCheck(this, Tracker);
    this.transaction = transaction;
    this.currentStep = this.transaction.steps.length;
  }
  _createClass(Tracker, [{
    key: "map",
    value: function map(position) {
      var deleted = false;
      var mappedPosition = this.transaction.steps.slice(this.currentStep).reduce(function (newPosition, step) {
        var mapResult = step.getMap().mapResult(newPosition);
        if (mapResult.deleted) {
          deleted = true;
        }
        return mapResult.pos;
      }, position);
      return {
        position: mappedPosition,
        deleted: deleted
      };
    }
  }]);
  return Tracker;
}();


/***/ }),

/***/ "./node_modules/@tiptap/extension-blockquote/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-blockquote/dist/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Blockquote: function() { return /* binding */ Blockquote; },
/* harmony export */   "default": function() { return /* binding */ Blockquote; },
/* harmony export */   inputRegex: function() { return /* binding */ inputRegex; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");

var inputRegex = /^\s*>\s$/;
var Blockquote = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({
  name: 'blockquote',
  addOptions: function addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  content: 'block+',
  group: 'block',
  defining: true,
  parseHTML: function parseHTML() {
    return [{
      tag: 'blockquote'
    }];
  },
  renderHTML: function renderHTML(_ref) {
    var HTMLAttributes = _ref.HTMLAttributes;
    return ['blockquote', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands: function addCommands() {
    var _this = this;
    return {
      setBlockquote: function setBlockquote() {
        return function (_ref2) {
          var commands = _ref2.commands;
          return commands.wrapIn(_this.name);
        };
      },
      toggleBlockquote: function toggleBlockquote() {
        return function (_ref3) {
          var commands = _ref3.commands;
          return commands.toggleWrap(_this.name);
        };
      },
      unsetBlockquote: function unsetBlockquote() {
        return function (_ref4) {
          var commands = _ref4.commands;
          return commands.lift(_this.name);
        };
      }
    };
  },
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this2 = this;
    return {
      'Mod-Shift-b': function ModShiftB() {
        return _this2.editor.commands.toggleBlockquote();
      }
    };
  },
  addInputRules: function addInputRules() {
    return [(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({
      find: inputRegex,
      type: this.type
    })];
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-bold/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-bold/dist/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bold: function() { return /* binding */ Bold; },
/* harmony export */   "default": function() { return /* binding */ Bold; },
/* harmony export */   starInputRegex: function() { return /* binding */ starInputRegex; },
/* harmony export */   starPasteRegex: function() { return /* binding */ starPasteRegex; },
/* harmony export */   underscoreInputRegex: function() { return /* binding */ underscoreInputRegex; },
/* harmony export */   underscorePasteRegex: function() { return /* binding */ underscorePasteRegex; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");

var starInputRegex = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/;
var starPasteRegex = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g;
var underscoreInputRegex = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/;
var underscorePasteRegex = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g;
var Bold = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({
  name: 'bold',
  addOptions: function addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML: function parseHTML() {
    return [{
      tag: 'strong'
    }, {
      tag: 'b',
      getAttrs: function getAttrs(node) {
        return node.style.fontWeight !== 'normal' && null;
      }
    }, {
      style: 'font-weight',
      getAttrs: function getAttrs(value) {
        return /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null;
      }
    }];
  },
  renderHTML: function renderHTML(_ref) {
    var HTMLAttributes = _ref.HTMLAttributes;
    return ['strong', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands: function addCommands() {
    var _this = this;
    return {
      setBold: function setBold() {
        return function (_ref2) {
          var commands = _ref2.commands;
          return commands.setMark(_this.name);
        };
      },
      toggleBold: function toggleBold() {
        return function (_ref3) {
          var commands = _ref3.commands;
          return commands.toggleMark(_this.name);
        };
      },
      unsetBold: function unsetBold() {
        return function (_ref4) {
          var commands = _ref4.commands;
          return commands.unsetMark(_this.name);
        };
      }
    };
  },
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this2 = this;
    return {
      'Mod-b': function ModB() {
        return _this2.editor.commands.toggleBold();
      },
      'Mod-B': function ModB() {
        return _this2.editor.commands.toggleBold();
      }
    };
  },
  addInputRules: function addInputRules() {
    return [(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({
      find: starInputRegex,
      type: this.type
    }), (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({
      find: underscoreInputRegex,
      type: this.type
    })];
  },
  addPasteRules: function addPasteRules() {
    return [(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({
      find: starPasteRegex,
      type: this.type
    }), (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({
      find: underscorePasteRegex,
      type: this.type
    })];
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-bullet-list/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-bullet-list/dist/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BulletList: function() { return /* binding */ BulletList; },
/* harmony export */   "default": function() { return /* binding */ BulletList; },
/* harmony export */   inputRegex: function() { return /* binding */ inputRegex; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var ListItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({
  name: 'listItem',
  addOptions: function addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: 'bulletList',
      orderedListTypeName: 'orderedList'
    };
  },
  content: 'paragraph block*',
  defining: true,
  parseHTML: function parseHTML() {
    return [{
      tag: 'li'
    }];
  },
  renderHTML: function renderHTML(_ref) {
    var HTMLAttributes = _ref.HTMLAttributes;
    return ['li', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this = this;
    return {
      Enter: function Enter() {
        return _this.editor.commands.splitListItem(_this.name);
      },
      Tab: function Tab() {
        return _this.editor.commands.sinkListItem(_this.name);
      },
      'Shift-Tab': function ShiftTab() {
        return _this.editor.commands.liftListItem(_this.name);
      }
    };
  }
});
var TextStyle = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({
  name: 'textStyle',
  addOptions: function addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML: function parseHTML() {
    return [{
      tag: 'span',
      getAttrs: function getAttrs(element) {
        var hasStyles = element.hasAttribute('style');
        if (!hasStyles) {
          return false;
        }
        return {};
      }
    }];
  },
  renderHTML: function renderHTML(_ref2) {
    var HTMLAttributes = _ref2.HTMLAttributes;
    return ['span', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands: function addCommands() {
    var _this2 = this;
    return {
      removeEmptyTextStyle: function removeEmptyTextStyle() {
        return function (_ref3) {
          var state = _ref3.state,
            commands = _ref3.commands;
          var attributes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getMarkAttributes)(state, _this2.type);
          var hasStyles = Object.entries(attributes).some(function (_ref4) {
            var _ref5 = _slicedToArray(_ref4, 2),
              value = _ref5[1];
            return !!value;
          });
          if (hasStyles) {
            return true;
          }
          return commands.unsetMark(_this2.name);
        };
      }
    };
  }
});
var inputRegex = /^\s*([-+*])\s$/;
var BulletList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({
  name: 'bulletList',
  addOptions: function addOptions() {
    return {
      itemTypeName: 'listItem',
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: 'block list',
  content: function content() {
    return "".concat(this.options.itemTypeName, "+");
  },
  parseHTML: function parseHTML() {
    return [{
      tag: 'ul'
    }];
  },
  renderHTML: function renderHTML(_ref6) {
    var HTMLAttributes = _ref6.HTMLAttributes;
    return ['ul', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands: function addCommands() {
    var _this3 = this;
    return {
      toggleBulletList: function toggleBulletList() {
        return function (_ref7) {
          var commands = _ref7.commands,
            chain = _ref7.chain;
          if (_this3.options.keepAttributes) {
            return chain().toggleList(_this3.name, _this3.options.itemTypeName, _this3.options.keepMarks).updateAttributes(ListItem.name, _this3.editor.getAttributes(TextStyle.name)).run();
          }
          return commands.toggleList(_this3.name, _this3.options.itemTypeName, _this3.options.keepMarks);
        };
      }
    };
  },
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this4 = this;
    return {
      'Mod-Shift-8': function ModShift8() {
        return _this4.editor.commands.toggleBulletList();
      }
    };
  },
  addInputRules: function addInputRules() {
    var _this5 = this;
    var inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({
      find: inputRegex,
      type: this.type
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({
        find: inputRegex,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: function getAttributes() {
          return _this5.editor.getAttributes(TextStyle.name);
        },
        editor: this.editor
      });
    }
    return [inputRule];
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-character-count/dist/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-character-count/dist/index.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CharacterCount: function() { return /* binding */ CharacterCount; },
/* harmony export */   "default": function() { return /* binding */ CharacterCount; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ "./node_modules/@tiptap/pm/state/dist/index.js");


var CharacterCount = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({
  name: 'characterCount',
  addOptions: function addOptions() {
    return {
      limit: null,
      mode: 'textSize'
    };
  },
  addStorage: function addStorage() {
    return {
      characters: function characters() {
        return 0;
      },
      words: function words() {
        return 0;
      }
    };
  },
  onBeforeCreate: function onBeforeCreate() {
    var _this = this;
    this.storage.characters = function (options) {
      var node = (options === null || options === void 0 ? void 0 : options.node) || _this.editor.state.doc;
      var mode = (options === null || options === void 0 ? void 0 : options.mode) || _this.options.mode;
      if (mode === 'textSize') {
        var text = node.textBetween(0, node.content.size, undefined, ' ');
        return text.length;
      }
      return node.nodeSize;
    };
    this.storage.words = function (options) {
      var node = (options === null || options === void 0 ? void 0 : options.node) || _this.editor.state.doc;
      var text = node.textBetween(0, node.content.size, ' ', ' ');
      var words = text.split(' ').filter(function (word) {
        return word !== '';
      });
      return words.length;
    };
  },
  addProseMirrorPlugins: function addProseMirrorPlugins() {
    var _this2 = this;
    return [new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({
      key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('characterCount'),
      filterTransaction: function filterTransaction(transaction, state) {
        var limit = _this2.options.limit;
        // Nothing has changed or no limit is defined. Ignore it.
        if (!transaction.docChanged || limit === 0 || limit === null || limit === undefined) {
          return true;
        }
        var oldSize = _this2.storage.characters({
          node: state.doc
        });
        var newSize = _this2.storage.characters({
          node: transaction.doc
        });
        // Everything is in the limit. Good.
        if (newSize <= limit) {
          return true;
        }
        // The limit has already been exceeded but will be reduced.
        if (oldSize > limit && newSize > limit && newSize <= oldSize) {
          return true;
        }
        // The limit has already been exceeded and will be increased further.
        if (oldSize > limit && newSize > limit && newSize > oldSize) {
          return false;
        }
        var isPaste = transaction.getMeta('paste');
        // Block all exceeding transactions that were not pasted.
        if (!isPaste) {
          return false;
        }
        // For pasted content, we try to remove the exceeding content.
        var pos = transaction.selection.$head.pos;
        var over = newSize - limit;
        var from = pos - over;
        var to = pos;
        // Its probably a bad idea to mutate transactions within `filterTransaction`
        // but for now this is working fine.
        transaction.deleteRange(from, to);
        // In some situations, the limit will continue to be exceeded after trimming.
        // This happens e.g. when truncating within a complex node (e.g. table)
        // and ProseMirror has to close this node again.
        // If this is the case, we prevent the transaction completely.
        var updatedSize = _this2.storage.characters({
          node: transaction.doc
        });
        if (updatedSize > limit) {
          return false;
        }
        return true;
      }
    })];
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-code-block/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-code-block/dist/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CodeBlock: function() { return /* binding */ CodeBlock; },
/* harmony export */   backtickInputRegex: function() { return /* binding */ backtickInputRegex; },
/* harmony export */   "default": function() { return /* binding */ CodeBlock; },
/* harmony export */   tildeInputRegex: function() { return /* binding */ tildeInputRegex; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ "./node_modules/@tiptap/pm/state/dist/index.js");
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }


var backtickInputRegex = /^```([a-z]+)?[\s\n]$/;
var tildeInputRegex = /^~~~([a-z]+)?[\s\n]$/;
var CodeBlock = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({
  name: 'codeBlock',
  addOptions: function addOptions() {
    return {
      languageClassPrefix: 'language-',
      exitOnTripleEnter: true,
      exitOnArrowDown: true,
      HTMLAttributes: {}
    };
  },
  content: 'text*',
  marks: '',
  group: 'block',
  code: true,
  defining: true,
  addAttributes: function addAttributes() {
    var _this = this;
    return {
      language: {
        "default": null,
        parseHTML: function parseHTML(element) {
          var _a;
          var languageClassPrefix = _this.options.languageClassPrefix;
          var classNames = _toConsumableArray(((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || []);
          var languages = classNames.filter(function (className) {
            return className.startsWith(languageClassPrefix);
          }).map(function (className) {
            return className.replace(languageClassPrefix, '');
          });
          var language = languages[0];
          if (!language) {
            return null;
          }
          return language;
        },
        rendered: false
      }
    };
  },
  parseHTML: function parseHTML() {
    return [{
      tag: 'pre',
      preserveWhitespace: 'full'
    }];
  },
  renderHTML: function renderHTML(_ref) {
    var node = _ref.node,
      HTMLAttributes = _ref.HTMLAttributes;
    return ['pre', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), ['code', {
      "class": node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null
    }, 0]];
  },
  addCommands: function addCommands() {
    var _this2 = this;
    return {
      setCodeBlock: function setCodeBlock(attributes) {
        return function (_ref2) {
          var commands = _ref2.commands;
          return commands.setNode(_this2.name, attributes);
        };
      },
      toggleCodeBlock: function toggleCodeBlock(attributes) {
        return function (_ref3) {
          var commands = _ref3.commands;
          return commands.toggleNode(_this2.name, 'paragraph', attributes);
        };
      }
    };
  },
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this3 = this;
    return {
      'Mod-Alt-c': function ModAltC() {
        return _this3.editor.commands.toggleCodeBlock();
      },
      // remove code block when at start of document or code block is empty
      Backspace: function Backspace() {
        var _this3$editor$state$s = _this3.editor.state.selection,
          empty = _this3$editor$state$s.empty,
          $anchor = _this3$editor$state$s.$anchor;
        var isAtStart = $anchor.pos === 1;
        if (!empty || $anchor.parent.type.name !== _this3.name) {
          return false;
        }
        if (isAtStart || !$anchor.parent.textContent.length) {
          return _this3.editor.commands.clearNodes();
        }
        return false;
      },
      // exit node on triple enter
      Enter: function Enter(_ref4) {
        var editor = _ref4.editor;
        if (!_this3.options.exitOnTripleEnter) {
          return false;
        }
        var state = editor.state;
        var selection = state.selection;
        var $from = selection.$from,
          empty = selection.empty;
        if (!empty || $from.parent.type !== _this3.type) {
          return false;
        }
        var isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        var endsWithDoubleNewline = $from.parent.textContent.endsWith('\n\n');
        if (!isAtEnd || !endsWithDoubleNewline) {
          return false;
        }
        return editor.chain().command(function (_ref5) {
          var tr = _ref5.tr;
          tr["delete"]($from.pos - 2, $from.pos);
          return true;
        }).exitCode().run();
      },
      // exit node on arrow down
      ArrowDown: function ArrowDown(_ref6) {
        var editor = _ref6.editor;
        if (!_this3.options.exitOnArrowDown) {
          return false;
        }
        var state = editor.state;
        var selection = state.selection,
          doc = state.doc;
        var $from = selection.$from,
          empty = selection.empty;
        if (!empty || $from.parent.type !== _this3.type) {
          return false;
        }
        var isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;
        if (!isAtEnd) {
          return false;
        }
        var after = $from.after();
        if (after === undefined) {
          return false;
        }
        var nodeAfter = doc.nodeAt(after);
        if (nodeAfter) {
          return false;
        }
        return editor.commands.exitCode();
      }
    };
  },
  addInputRules: function addInputRules() {
    return [(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({
      find: backtickInputRegex,
      type: this.type,
      getAttributes: function getAttributes(match) {
        return {
          language: match[1]
        };
      }
    }), (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({
      find: tildeInputRegex,
      type: this.type,
      getAttributes: function getAttributes(match) {
        return {
          language: match[1]
        };
      }
    })];
  },
  addProseMirrorPlugins: function addProseMirrorPlugins() {
    var _this4 = this;
    return [
    // this plugin creates a code block for pasted content from VS Code
    // we can also detect the copied code language
    new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({
      key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('codeBlockVSCodeHandler'),
      props: {
        handlePaste: function handlePaste(view, event) {
          if (!event.clipboardData) {
            return false;
          }
          // dont create a new code block within code blocks
          if (_this4.editor.isActive(_this4.type.name)) {
            return false;
          }
          var text = event.clipboardData.getData('text/plain');
          var vscode = event.clipboardData.getData('vscode-editor-data');
          var vscodeData = vscode ? JSON.parse(vscode) : undefined;
          var language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;
          if (!text || !language) {
            return false;
          }
          var tr = view.state.tr;
          // create an empty code block
          tr.replaceSelectionWith(_this4.type.create({
            language: language
          }));
          // put cursor inside the newly created code block
          tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));
          // add text to code block
          // strip carriage return chars from text pasted as code
          // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd
          tr.insertText(text.replace(/\r\n?/g, '\n'));
          // store meta information
          // this is useful for other plugins that depends on the paste event
          // like the paste rule plugin
          tr.setMeta('paste', true);
          view.dispatch(tr);
          return true;
        }
      }
    })];
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-code/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-code/dist/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Code: function() { return /* binding */ Code; },
/* harmony export */   "default": function() { return /* binding */ Code; },
/* harmony export */   inputRegex: function() { return /* binding */ inputRegex; },
/* harmony export */   pasteRegex: function() { return /* binding */ pasteRegex; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");

var inputRegex = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/;
var pasteRegex = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g;
var Code = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({
  name: 'code',
  addOptions: function addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  excludes: '_',
  code: true,
  exitable: true,
  parseHTML: function parseHTML() {
    return [{
      tag: 'code'
    }];
  },
  renderHTML: function renderHTML(_ref) {
    var HTMLAttributes = _ref.HTMLAttributes;
    return ['code', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands: function addCommands() {
    var _this = this;
    return {
      setCode: function setCode() {
        return function (_ref2) {
          var commands = _ref2.commands;
          return commands.setMark(_this.name);
        };
      },
      toggleCode: function toggleCode() {
        return function (_ref3) {
          var commands = _ref3.commands;
          return commands.toggleMark(_this.name);
        };
      },
      unsetCode: function unsetCode() {
        return function (_ref4) {
          var commands = _ref4.commands;
          return commands.unsetMark(_this.name);
        };
      }
    };
  },
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this2 = this;
    return {
      'Mod-e': function ModE() {
        return _this2.editor.commands.toggleCode();
      }
    };
  },
  addInputRules: function addInputRules() {
    return [(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({
      find: inputRegex,
      type: this.type
    })];
  },
  addPasteRules: function addPasteRules() {
    return [(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({
      find: pasteRegex,
      type: this.type
    })];
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-document/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tiptap/extension-document/dist/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Document: function() { return /* binding */ Document; },
/* harmony export */   "default": function() { return /* binding */ Document; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");

var Document = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({
  name: 'doc',
  topNode: true,
  content: 'block+'
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-dropcursor/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-dropcursor/dist/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dropcursor: function() { return /* binding */ Dropcursor; },
/* harmony export */   "default": function() { return /* binding */ Dropcursor; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
/* harmony import */ var _tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/dropcursor */ "./node_modules/@tiptap/pm/dropcursor/dist/index.js");


var Dropcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({
  name: 'dropCursor',
  addOptions: function addOptions() {
    return {
      color: 'currentColor',
      width: 1,
      "class": undefined
    };
  },
  addProseMirrorPlugins: function addProseMirrorPlugins() {
    return [(0,_tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_0__.dropCursor)(this.options)];
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-gapcursor/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-gapcursor/dist/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Gapcursor: function() { return /* binding */ Gapcursor; },
/* harmony export */   "default": function() { return /* binding */ Gapcursor; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
/* harmony import */ var _tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/gapcursor */ "./node_modules/@tiptap/pm/gapcursor/dist/index.js");


var Gapcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({
  name: 'gapCursor',
  addProseMirrorPlugins: function addProseMirrorPlugins() {
    return [(0,_tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_0__.gapCursor)()];
  },
  extendNodeSchema: function extendNodeSchema(extension) {
    var _a;
    var context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    return {
      allowGapCursor: (_a = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.callOrReturn)((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.getExtensionField)(extension, 'allowGapCursor', context))) !== null && _a !== void 0 ? _a : null
    };
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-hard-break/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-hard-break/dist/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HardBreak: function() { return /* binding */ HardBreak; },
/* harmony export */   "default": function() { return /* binding */ HardBreak; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");

var HardBreak = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({
  name: 'hardBreak',
  addOptions: function addOptions() {
    return {
      keepMarks: true,
      HTMLAttributes: {}
    };
  },
  inline: true,
  group: 'inline',
  selectable: false,
  parseHTML: function parseHTML() {
    return [{
      tag: 'br'
    }];
  },
  renderHTML: function renderHTML(_ref) {
    var HTMLAttributes = _ref.HTMLAttributes;
    return ['br', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)];
  },
  renderText: function renderText() {
    return '\n';
  },
  addCommands: function addCommands() {
    var _this = this;
    return {
      setHardBreak: function setHardBreak() {
        return function (_ref2) {
          var commands = _ref2.commands,
            chain = _ref2.chain,
            state = _ref2.state,
            editor = _ref2.editor;
          return commands.first([function () {
            return commands.exitCode();
          }, function () {
            return commands.command(function () {
              var selection = state.selection,
                storedMarks = state.storedMarks;
              if (selection.$from.parent.type.spec.isolating) {
                return false;
              }
              var keepMarks = _this.options.keepMarks;
              var splittableMarks = editor.extensionManager.splittableMarks;
              var marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();
              return chain().insertContent({
                type: _this.name
              }).command(function (_ref3) {
                var tr = _ref3.tr,
                  dispatch = _ref3.dispatch;
                if (dispatch && marks && keepMarks) {
                  var filteredMarks = marks.filter(function (mark) {
                    return splittableMarks.includes(mark.type.name);
                  });
                  tr.ensureMarks(filteredMarks);
                }
                return true;
              }).run();
            });
          }]);
        };
      }
    };
  },
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this2 = this;
    return {
      'Mod-Enter': function ModEnter() {
        return _this2.editor.commands.setHardBreak();
      },
      'Shift-Enter': function ShiftEnter() {
        return _this2.editor.commands.setHardBreak();
      }
    };
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-heading/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-heading/dist/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Heading: function() { return /* binding */ Heading; },
/* harmony export */   "default": function() { return /* binding */ Heading; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

var Heading = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({
  name: 'heading',
  addOptions: function addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6],
      HTMLAttributes: {}
    };
  },
  content: 'inline*',
  group: 'block',
  defining: true,
  addAttributes: function addAttributes() {
    return {
      level: {
        "default": 1,
        rendered: false
      }
    };
  },
  parseHTML: function parseHTML() {
    return this.options.levels.map(function (level) {
      return {
        tag: "h".concat(level),
        attrs: {
          level: level
        }
      };
    });
  },
  renderHTML: function renderHTML(_ref) {
    var node = _ref.node,
      HTMLAttributes = _ref.HTMLAttributes;
    var hasLevel = this.options.levels.includes(node.attrs.level);
    var level = hasLevel ? node.attrs.level : this.options.levels[0];
    return ["h".concat(level), (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands: function addCommands() {
    var _this = this;
    return {
      setHeading: function setHeading(attributes) {
        return function (_ref2) {
          var commands = _ref2.commands;
          if (!_this.options.levels.includes(attributes.level)) {
            return false;
          }
          return commands.setNode(_this.name, attributes);
        };
      },
      toggleHeading: function toggleHeading(attributes) {
        return function (_ref3) {
          var commands = _ref3.commands;
          if (!_this.options.levels.includes(attributes.level)) {
            return false;
          }
          return commands.toggleNode(_this.name, 'paragraph', attributes);
        };
      }
    };
  },
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this2 = this;
    return this.options.levels.reduce(function (items, level) {
      return _objectSpread(_objectSpread({}, items), _defineProperty({}, "Mod-Alt-".concat(level), function ModAlt() {
        return _this2.editor.commands.toggleHeading({
          level: level
        });
      }));
    }, {});
  },
  addInputRules: function addInputRules() {
    var _this3 = this;
    return this.options.levels.map(function (level) {
      return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.textblockTypeInputRule)({
        find: new RegExp("^(#{1,".concat(level, "})\\s$")),
        type: _this3.type,
        getAttributes: {
          level: level
        }
      });
    });
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-history/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-history/dist/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   History: function() { return /* binding */ History; },
/* harmony export */   "default": function() { return /* binding */ History; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
/* harmony import */ var _tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/history */ "./node_modules/@tiptap/pm/history/dist/index.js");


var History = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({
  name: 'history',
  addOptions: function addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addCommands: function addCommands() {
    return {
      undo: function undo() {
        return function (_ref) {
          var state = _ref.state,
            dispatch = _ref.dispatch;
          return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.undo)(state, dispatch);
        };
      },
      redo: function redo() {
        return function (_ref2) {
          var state = _ref2.state,
            dispatch = _ref2.dispatch;
          return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.redo)(state, dispatch);
        };
      }
    };
  },
  addProseMirrorPlugins: function addProseMirrorPlugins() {
    return [(0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.history)(this.options)];
  },
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this = this;
    return {
      'Mod-z': function ModZ() {
        return _this.editor.commands.undo();
      },
      'Mod-Z': function ModZ() {
        return _this.editor.commands.undo();
      },
      'Mod-y': function ModY() {
        return _this.editor.commands.redo();
      },
      'Mod-Y': function ModY() {
        return _this.editor.commands.redo();
      },
      'Shift-Mod-z': function ShiftModZ() {
        return _this.editor.commands.redo();
      },
      'Shift-Mod-Z': function ShiftModZ() {
        return _this.editor.commands.redo();
      },
      // Russian keyboard layouts
      'Mod-': function Mod() {
        return _this.editor.commands.undo();
      },
      'Shift-Mod-': function ShiftMod() {
        return _this.editor.commands.redo();
      }
    };
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-horizontal-rule/dist/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-horizontal-rule/dist/index.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HorizontalRule: function() { return /* binding */ HorizontalRule; },
/* harmony export */   "default": function() { return /* binding */ HorizontalRule; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ "./node_modules/@tiptap/pm/state/dist/index.js");


var HorizontalRule = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({
  name: 'horizontalRule',
  addOptions: function addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: 'block',
  parseHTML: function parseHTML() {
    return [{
      tag: 'hr'
    }];
  },
  renderHTML: function renderHTML(_ref) {
    var HTMLAttributes = _ref.HTMLAttributes;
    return ['hr', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands: function addCommands() {
    var _this = this;
    return {
      setHorizontalRule: function setHorizontalRule() {
        return function (_ref2) {
          var chain = _ref2.chain,
            state = _ref2.state;
          var $originTo = state.selection.$to;
          var currentChain = chain();
          if ($originTo.parentOffset === 0) {
            currentChain.insertContentAt(Math.max($originTo.pos - 2, 0), {
              type: _this.name
            });
          } else {
            currentChain.insertContent({
              type: _this.name
            });
          }
          return currentChain
          // set cursor after horizontal rule
          .command(function (_ref3) {
            var tr = _ref3.tr,
              dispatch = _ref3.dispatch;
            var _a;
            if (dispatch) {
              var $to = tr.selection.$to;
              var posAfter = $to.end();
              if ($to.nodeAfter) {
                if ($to.nodeAfter.isTextblock) {
                  tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos + 1));
                } else if ($to.nodeAfter.isBlock) {
                  tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(tr.doc, $to.pos));
                } else {
                  tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos));
                }
              } else {
                // add node after horizontal rule if its the end of the document
                var node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();
                if (node) {
                  tr.insert(posAfter, node);
                  tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, posAfter + 1));
                }
              }
              tr.scrollIntoView();
            }
            return true;
          }).run();
        };
      }
    };
  },
  addInputRules: function addInputRules() {
    return [(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.nodeInputRule)({
      find: /^(?:---|-|___\s|\*\*\*\s)$/,
      type: this.type
    })];
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-image/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@tiptap/extension-image/dist/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Image: function() { return /* binding */ Image; },
/* harmony export */   "default": function() { return /* binding */ Image; },
/* harmony export */   inputRegex: function() { return /* binding */ inputRegex; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var inputRegex = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/;
var Image = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({
  name: 'image',
  addOptions: function addOptions() {
    return {
      inline: false,
      allowBase64: false,
      HTMLAttributes: {}
    };
  },
  inline: function inline() {
    return this.options.inline;
  },
  group: function group() {
    return this.options.inline ? 'inline' : 'block';
  },
  draggable: true,
  addAttributes: function addAttributes() {
    return {
      src: {
        "default": null
      },
      alt: {
        "default": null
      },
      title: {
        "default": null
      }
    };
  },
  parseHTML: function parseHTML() {
    return [{
      tag: this.options.allowBase64 ? 'img[src]' : 'img[src]:not([src^="data:"])'
    }];
  },
  renderHTML: function renderHTML(_ref) {
    var HTMLAttributes = _ref.HTMLAttributes;
    return ['img', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)];
  },
  addCommands: function addCommands() {
    var _this = this;
    return {
      setImage: function setImage(options) {
        return function (_ref2) {
          var commands = _ref2.commands;
          return commands.insertContent({
            type: _this.name,
            attrs: options
          });
        };
      }
    };
  },
  addInputRules: function addInputRules() {
    return [(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.nodeInputRule)({
      find: inputRegex,
      type: this.type,
      getAttributes: function getAttributes(match) {
        var _match = _slicedToArray(match, 5),
          alt = _match[2],
          src = _match[3],
          title = _match[4];
        return {
          src: src,
          alt: alt,
          title: title
        };
      }
    })];
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-italic/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-italic/dist/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Italic: function() { return /* binding */ Italic; },
/* harmony export */   "default": function() { return /* binding */ Italic; },
/* harmony export */   starInputRegex: function() { return /* binding */ starInputRegex; },
/* harmony export */   starPasteRegex: function() { return /* binding */ starPasteRegex; },
/* harmony export */   underscoreInputRegex: function() { return /* binding */ underscoreInputRegex; },
/* harmony export */   underscorePasteRegex: function() { return /* binding */ underscorePasteRegex; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");

var starInputRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/;
var starPasteRegex = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g;
var underscoreInputRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/;
var underscorePasteRegex = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g;
var Italic = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({
  name: 'italic',
  addOptions: function addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML: function parseHTML() {
    return [{
      tag: 'em'
    }, {
      tag: 'i',
      getAttrs: function getAttrs(node) {
        return node.style.fontStyle !== 'normal' && null;
      }
    }, {
      style: 'font-style=italic'
    }];
  },
  renderHTML: function renderHTML(_ref) {
    var HTMLAttributes = _ref.HTMLAttributes;
    return ['em', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands: function addCommands() {
    var _this = this;
    return {
      setItalic: function setItalic() {
        return function (_ref2) {
          var commands = _ref2.commands;
          return commands.setMark(_this.name);
        };
      },
      toggleItalic: function toggleItalic() {
        return function (_ref3) {
          var commands = _ref3.commands;
          return commands.toggleMark(_this.name);
        };
      },
      unsetItalic: function unsetItalic() {
        return function (_ref4) {
          var commands = _ref4.commands;
          return commands.unsetMark(_this.name);
        };
      }
    };
  },
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this2 = this;
    return {
      'Mod-i': function ModI() {
        return _this2.editor.commands.toggleItalic();
      },
      'Mod-I': function ModI() {
        return _this2.editor.commands.toggleItalic();
      }
    };
  },
  addInputRules: function addInputRules() {
    return [(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({
      find: starInputRegex,
      type: this.type
    }), (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({
      find: underscoreInputRegex,
      type: this.type
    })];
  },
  addPasteRules: function addPasteRules() {
    return [(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({
      find: starPasteRegex,
      type: this.type
    }), (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({
      find: underscorePasteRegex,
      type: this.type
    })];
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-link/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-link/dist/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Link: function() { return /* binding */ Link; },
/* harmony export */   "default": function() { return /* binding */ Link; },
/* harmony export */   pasteRegex: function() { return /* binding */ pasteRegex; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
/* harmony import */ var linkifyjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! linkifyjs */ "./node_modules/linkifyjs/dist/linkify.es.js");
/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/state */ "./node_modules/@tiptap/pm/state/dist/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }



function autolink(options) {
  return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({
    key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey('autolink'),
    appendTransaction: function appendTransaction(transactions, oldState, newState) {
      var docChanges = transactions.some(function (transaction) {
        return transaction.docChanged;
      }) && !oldState.doc.eq(newState.doc);
      var preventAutolink = transactions.some(function (transaction) {
        return transaction.getMeta('preventAutolink');
      });
      if (!docChanges || preventAutolink) {
        return;
      }
      var tr = newState.tr;
      var transform = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.combineTransactionSteps)(oldState.doc, _toConsumableArray(transactions));
      var changes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getChangedRanges)(transform);
      changes.forEach(function (_ref) {
        var newRange = _ref.newRange;
        // Now lets see if we can add new links.
        var nodesInChangedRanges = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findChildrenInRange)(newState.doc, newRange, function (node) {
          return node.isTextblock;
        });
        var textBlock;
        var textBeforeWhitespace;
        if (nodesInChangedRanges.length > 1) {
          // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter).
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, undefined, ' ');
        } else if (nodesInChangedRanges.length
        // We want to make sure to include the block seperator argument to treat hard breaks like spaces.
        && newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ').endsWith(' ')) {
          textBlock = nodesInChangedRanges[0];
          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, undefined, ' ');
        }
        if (textBlock && textBeforeWhitespace) {
          var wordsBeforeWhitespace = textBeforeWhitespace.split(' ').filter(function (s) {
            return s !== '';
          });
          if (wordsBeforeWhitespace.length <= 0) {
            return false;
          }
          var lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];
          var lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);
          if (!lastWordBeforeSpace) {
            return false;
          }
          (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.find)(lastWordBeforeSpace).filter(function (link) {
            return link.isLink;
          })
          // Calculate link position.
          .map(function (link) {
            return _objectSpread(_objectSpread({}, link), {}, {
              from: lastWordAndBlockOffset + link.start + 1,
              to: lastWordAndBlockOffset + link.end + 1
            });
          })
          // ignore link inside code mark
          .filter(function (link) {
            if (!newState.schema.marks.code) {
              return true;
            }
            return !newState.doc.rangeHasMark(link.from, link.to, newState.schema.marks.code);
          })
          // validate link
          .filter(function (link) {
            if (options.validate) {
              return options.validate(link.value);
            }
            return true;
          })
          // Add link mark.
          .forEach(function (link) {
            if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarksBetween)(link.from, link.to, newState.doc).some(function (item) {
              return item.mark.type === options.type;
            })) {
              return;
            }
            tr.addMark(link.from, link.to, options.type.create({
              href: link.href
            }));
          });
        }
      });
      if (!tr.steps.length) {
        return;
      }
      return tr;
    }
  });
}
function clickHandler(options) {
  return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({
    key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey('handleClickLink'),
    props: {
      handleClick: function handleClick(view, pos, event) {
        var _a, _b;
        if (event.button !== 0) {
          return false;
        }
        var eventTarget = event.target;
        if (eventTarget.nodeName !== 'A') {
          return false;
        }
        var attrs = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getAttributes)(view.state, options.type.name);
        var link = event.target;
        var href = (_a = link === null || link === void 0 ? void 0 : link.href) !== null && _a !== void 0 ? _a : attrs.href;
        var target = (_b = link === null || link === void 0 ? void 0 : link.target) !== null && _b !== void 0 ? _b : attrs.target;
        if (link && href) {
          if (view.editable) {
            window.open(href, target);
          }
          return true;
        }
        return false;
      }
    }
  });
}
function pasteHandler(options) {
  return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({
    key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_1__.PluginKey('handlePasteLink'),
    props: {
      handlePaste: function handlePaste(view, event, slice) {
        var state = view.state;
        var selection = state.selection;
        var empty = selection.empty;
        if (empty) {
          return false;
        }
        var textContent = '';
        slice.content.forEach(function (node) {
          textContent += node.textContent;
        });
        var link = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.find)(textContent).find(function (item) {
          return item.isLink && item.value === textContent;
        });
        if (!textContent || !link) {
          return false;
        }
        options.editor.commands.setMark(options.type, {
          href: link.href
        });
        return true;
      }
    }
  });
}
var pasteRegex = /https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z]{2,}\b(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)(?:[-a-zA-Z0-9@:%._+~#=?!&/]*)/gi;
var Link = _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Mark.create({
  name: 'link',
  priority: 1000,
  keepOnSplit: false,
  onCreate: function onCreate() {
    this.options.protocols.forEach(function (protocol) {
      if (typeof protocol === 'string') {
        (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.registerCustomProtocol)(protocol);
        return;
      }
      (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.registerCustomProtocol)(protocol.scheme, protocol.optionalSlashes);
    });
  },
  onDestroy: function onDestroy() {
    (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.reset)();
  },
  inclusive: function inclusive() {
    return this.options.autolink;
  },
  addOptions: function addOptions() {
    return {
      openOnClick: true,
      linkOnPaste: true,
      autolink: true,
      protocols: [],
      HTMLAttributes: {
        target: '_blank',
        rel: 'noopener noreferrer nofollow',
        "class": null
      },
      validate: undefined
    };
  },
  addAttributes: function addAttributes() {
    return {
      href: {
        "default": null
      },
      target: {
        "default": this.options.HTMLAttributes.target
      },
      rel: {
        "default": this.options.HTMLAttributes.rel
      },
      "class": {
        "default": this.options.HTMLAttributes["class"]
      }
    };
  },
  parseHTML: function parseHTML() {
    return [{
      tag: 'a[href]:not([href *= "javascript:" i])'
    }];
  },
  renderHTML: function renderHTML(_ref2) {
    var HTMLAttributes = _ref2.HTMLAttributes;
    var _a;
    // False positive; we're explicitly checking for javascript: links to ignore them
    // eslint-disable-next-line no-script-url
    if ((_a = HTMLAttributes.href) === null || _a === void 0 ? void 0 : _a.startsWith('javascript:')) {
      // strip out the href
      return ['a', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes)(this.options.HTMLAttributes, _objectSpread(_objectSpread({}, HTMLAttributes), {}, {
        href: ''
      })), 0];
    }
    return ['a', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands: function addCommands() {
    var _this = this;
    return {
      setLink: function setLink(attributes) {
        return function (_ref3) {
          var chain = _ref3.chain;
          return chain().setMark(_this.name, attributes).setMeta('preventAutolink', true).run();
        };
      },
      toggleLink: function toggleLink(attributes) {
        return function (_ref4) {
          var chain = _ref4.chain;
          return chain().toggleMark(_this.name, attributes, {
            extendEmptyMarkRange: true
          }).setMeta('preventAutolink', true).run();
        };
      },
      unsetLink: function unsetLink() {
        return function (_ref5) {
          var chain = _ref5.chain;
          return chain().unsetMark(_this.name, {
            extendEmptyMarkRange: true
          }).setMeta('preventAutolink', true).run();
        };
      }
    };
  },
  addPasteRules: function addPasteRules() {
    return [(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.markPasteRule)({
      find: function find(text, event) {
        var _a;
        var html = (_a = event === null || event === void 0 ? void 0 : event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/html');
        var foundLinks = [];
        if (html) {
          var dom = new DOMParser().parseFromString(html, 'text/html');
          var anchors = dom.querySelectorAll('a');
          if (anchors.length) {
            _toConsumableArray(anchors).forEach(function (anchor) {
              return foundLinks.push({
                text: anchor.innerText,
                data: {
                  href: anchor.getAttribute('href')
                },
                // get the index of the anchor inside the text
                // and add the length of the anchor text
                index: dom.body.innerText.indexOf(anchor.innerText) + anchor.innerText.length
              });
            });
          }
        }
        if (text) {
          var links = (0,linkifyjs__WEBPACK_IMPORTED_MODULE_0__.find)(text).filter(function (item) {
            return item.isLink;
          });
          if (links.length) {
            links.forEach(function (link) {
              return foundLinks.push({
                text: link.value,
                data: {
                  href: link.href
                },
                index: link.start
              });
            });
          }
        }
        return foundLinks;
      },
      type: this.type,
      getAttributes: function getAttributes(match) {
        var _a;
        return {
          href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href
        };
      }
    })];
  },
  addProseMirrorPlugins: function addProseMirrorPlugins() {
    var plugins = [];
    if (this.options.autolink) {
      plugins.push(autolink({
        type: this.type,
        validate: this.options.validate
      }));
    }
    if (this.options.openOnClick) {
      plugins.push(clickHandler({
        type: this.type
      }));
    }
    if (this.options.linkOnPaste) {
      plugins.push(pasteHandler({
        editor: this.editor,
        type: this.type
      }));
    }
    return plugins;
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-list-item/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-list-item/dist/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ListItem: function() { return /* binding */ ListItem; },
/* harmony export */   "default": function() { return /* binding */ ListItem; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");

var ListItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({
  name: 'listItem',
  addOptions: function addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: 'bulletList',
      orderedListTypeName: 'orderedList'
    };
  },
  content: 'paragraph block*',
  defining: true,
  parseHTML: function parseHTML() {
    return [{
      tag: 'li'
    }];
  },
  renderHTML: function renderHTML(_ref) {
    var HTMLAttributes = _ref.HTMLAttributes;
    return ['li', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this = this;
    return {
      Enter: function Enter() {
        return _this.editor.commands.splitListItem(_this.name);
      },
      Tab: function Tab() {
        return _this.editor.commands.sinkListItem(_this.name);
      },
      'Shift-Tab': function ShiftTab() {
        return _this.editor.commands.liftListItem(_this.name);
      }
    };
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-mention/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-mention/dist/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Mention: function() { return /* binding */ Mention; },
/* harmony export */   MentionPluginKey: function() { return /* binding */ MentionPluginKey; },
/* harmony export */   "default": function() { return /* binding */ Mention; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ "./node_modules/@tiptap/pm/state/dist/index.js");
/* harmony import */ var _tiptap_suggestion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/suggestion */ "./node_modules/@tiptap/suggestion/dist/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }



var MentionPluginKey = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('mention');
var Mention = _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Node.create({
  name: 'mention',
  addOptions: function addOptions() {
    var _this = this;
    return {
      HTMLAttributes: {},
      renderLabel: function renderLabel(_ref) {
        var options = _ref.options,
          node = _ref.node;
        var _a;
        return "".concat(options.suggestion["char"]).concat((_a = node.attrs.label) !== null && _a !== void 0 ? _a : node.attrs.id);
      },
      suggestion: {
        "char": '@',
        pluginKey: MentionPluginKey,
        command: function command(_ref2) {
          var editor = _ref2.editor,
            range = _ref2.range,
            props = _ref2.props;
          var _a, _b;
          // increase range.to by one when the next node is of type "text"
          // and starts with a space character
          var nodeAfter = editor.view.state.selection.$to.nodeAfter;
          var overrideSpace = (_a = nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.text) === null || _a === void 0 ? void 0 : _a.startsWith(' ');
          if (overrideSpace) {
            range.to += 1;
          }
          editor.chain().focus().insertContentAt(range, [{
            type: _this.name,
            attrs: props
          }, {
            type: 'text',
            text: ' '
          }]).run();
          (_b = window.getSelection()) === null || _b === void 0 ? void 0 : _b.collapseToEnd();
        },
        allow: function allow(_ref3) {
          var state = _ref3.state,
            range = _ref3.range;
          var $from = state.doc.resolve(range.from);
          var type = state.schema.nodes[_this.name];
          var allow = !!$from.parent.type.contentMatch.matchType(type);
          return allow;
        }
      }
    };
  },
  group: 'inline',
  inline: true,
  selectable: false,
  atom: true,
  addAttributes: function addAttributes() {
    return {
      id: {
        "default": null,
        parseHTML: function parseHTML(element) {
          return element.getAttribute('data-id');
        },
        renderHTML: function renderHTML(attributes) {
          if (!attributes.id) {
            return {};
          }
          return {
            'data-id': attributes.id
          };
        }
      },
      label: {
        "default": null,
        parseHTML: function parseHTML(element) {
          return element.getAttribute('data-label');
        },
        renderHTML: function renderHTML(attributes) {
          if (!attributes.label) {
            return {};
          }
          return {
            'data-label': attributes.label
          };
        }
      }
    };
  },
  parseHTML: function parseHTML() {
    return [{
      tag: "span[data-type=\"".concat(this.name, "\"]")
    }];
  },
  renderHTML: function renderHTML(_ref4) {
    var node = _ref4.node,
      HTMLAttributes = _ref4.HTMLAttributes;
    return ['span', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes)({
      'data-type': this.name
    }, this.options.HTMLAttributes, HTMLAttributes), this.options.renderLabel({
      options: this.options,
      node: node
    })];
  },
  renderText: function renderText(_ref5) {
    var node = _ref5.node;
    return this.options.renderLabel({
      options: this.options,
      node: node
    });
  },
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this2 = this;
    return {
      Backspace: function Backspace() {
        return _this2.editor.commands.command(function (_ref6) {
          var tr = _ref6.tr,
            state = _ref6.state;
          var isMention = false;
          var selection = state.selection;
          var empty = selection.empty,
            anchor = selection.anchor;
          if (!empty) {
            return false;
          }
          state.doc.nodesBetween(anchor - 1, anchor, function (node, pos) {
            if (node.type.name === _this2.name) {
              isMention = true;
              tr.insertText(_this2.options.suggestion["char"] || '', pos, pos + node.nodeSize);
              return false;
            }
          });
          return isMention;
        });
      }
    };
  },
  addProseMirrorPlugins: function addProseMirrorPlugins() {
    return [(0,_tiptap_suggestion__WEBPACK_IMPORTED_MODULE_1__["default"])(_objectSpread({
      editor: this.editor
    }, this.options.suggestion))];
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-ordered-list/dist/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-ordered-list/dist/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OrderedList: function() { return /* binding */ OrderedList; },
/* harmony export */   "default": function() { return /* binding */ OrderedList; },
/* harmony export */   inputRegex: function() { return /* binding */ inputRegex; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["start"];
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var ListItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({
  name: 'listItem',
  addOptions: function addOptions() {
    return {
      HTMLAttributes: {},
      bulletListTypeName: 'bulletList',
      orderedListTypeName: 'orderedList'
    };
  },
  content: 'paragraph block*',
  defining: true,
  parseHTML: function parseHTML() {
    return [{
      tag: 'li'
    }];
  },
  renderHTML: function renderHTML(_ref) {
    var HTMLAttributes = _ref.HTMLAttributes;
    return ['li', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this = this;
    return {
      Enter: function Enter() {
        return _this.editor.commands.splitListItem(_this.name);
      },
      Tab: function Tab() {
        return _this.editor.commands.sinkListItem(_this.name);
      },
      'Shift-Tab': function ShiftTab() {
        return _this.editor.commands.liftListItem(_this.name);
      }
    };
  }
});
var TextStyle = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({
  name: 'textStyle',
  addOptions: function addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML: function parseHTML() {
    return [{
      tag: 'span',
      getAttrs: function getAttrs(element) {
        var hasStyles = element.hasAttribute('style');
        if (!hasStyles) {
          return false;
        }
        return {};
      }
    }];
  },
  renderHTML: function renderHTML(_ref2) {
    var HTMLAttributes = _ref2.HTMLAttributes;
    return ['span', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands: function addCommands() {
    var _this2 = this;
    return {
      removeEmptyTextStyle: function removeEmptyTextStyle() {
        return function (_ref3) {
          var state = _ref3.state,
            commands = _ref3.commands;
          var attributes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.getMarkAttributes)(state, _this2.type);
          var hasStyles = Object.entries(attributes).some(function (_ref4) {
            var _ref5 = _slicedToArray(_ref4, 2),
              value = _ref5[1];
            return !!value;
          });
          if (hasStyles) {
            return true;
          }
          return commands.unsetMark(_this2.name);
        };
      }
    };
  }
});
var inputRegex = /^(\d+)\.\s$/;
var OrderedList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({
  name: 'orderedList',
  addOptions: function addOptions() {
    return {
      itemTypeName: 'listItem',
      HTMLAttributes: {},
      keepMarks: false,
      keepAttributes: false
    };
  },
  group: 'block list',
  content: function content() {
    return "".concat(this.options.itemTypeName, "+");
  },
  addAttributes: function addAttributes() {
    return {
      start: {
        "default": 1,
        parseHTML: function parseHTML(element) {
          return element.hasAttribute('start') ? parseInt(element.getAttribute('start') || '', 10) : 1;
        }
      }
    };
  },
  parseHTML: function parseHTML() {
    return [{
      tag: 'ol'
    }];
  },
  renderHTML: function renderHTML(_ref6) {
    var HTMLAttributes = _ref6.HTMLAttributes;
    var start = HTMLAttributes.start,
      attributesWithoutStart = _objectWithoutProperties(HTMLAttributes, _excluded);
    return start === 1 ? ['ol', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, attributesWithoutStart), 0] : ['ol', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands: function addCommands() {
    var _this3 = this;
    return {
      toggleOrderedList: function toggleOrderedList() {
        return function (_ref7) {
          var commands = _ref7.commands,
            chain = _ref7.chain;
          if (_this3.options.keepAttributes) {
            return chain().toggleList(_this3.name, _this3.options.itemTypeName, _this3.options.keepMarks).updateAttributes(ListItem.name, _this3.editor.getAttributes(TextStyle.name)).run();
          }
          return commands.toggleList(_this3.name, _this3.options.itemTypeName, _this3.options.keepMarks);
        };
      }
    };
  },
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this4 = this;
    return {
      'Mod-Shift-7': function ModShift7() {
        return _this4.editor.commands.toggleOrderedList();
      }
    };
  },
  addInputRules: function addInputRules() {
    var _this5 = this;
    var inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({
      find: inputRegex,
      type: this.type,
      getAttributes: function getAttributes(match) {
        return {
          start: +match[1]
        };
      },
      joinPredicate: function joinPredicate(match, node) {
        return node.childCount + node.attrs.start === +match[1];
      }
    });
    if (this.options.keepMarks || this.options.keepAttributes) {
      inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({
        find: inputRegex,
        type: this.type,
        keepMarks: this.options.keepMarks,
        keepAttributes: this.options.keepAttributes,
        getAttributes: function getAttributes(match) {
          return _objectSpread({
            start: +match[1]
          }, _this5.editor.getAttributes(TextStyle.name));
        },
        joinPredicate: function joinPredicate(match, node) {
          return node.childCount + node.attrs.start === +match[1];
        },
        editor: this.editor
      });
    }
    return [inputRule];
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-paragraph/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-paragraph/dist/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Paragraph: function() { return /* binding */ Paragraph; },
/* harmony export */   "default": function() { return /* binding */ Paragraph; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");

var Paragraph = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({
  name: 'paragraph',
  priority: 1000,
  addOptions: function addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  group: 'block',
  content: 'inline*',
  parseHTML: function parseHTML() {
    return [{
      tag: 'p'
    }];
  },
  renderHTML: function renderHTML(_ref) {
    var HTMLAttributes = _ref.HTMLAttributes;
    return ['p', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands: function addCommands() {
    var _this = this;
    return {
      setParagraph: function setParagraph() {
        return function (_ref2) {
          var commands = _ref2.commands;
          return commands.setNode(_this.name);
        };
      }
    };
  },
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this2 = this;
    return {
      'Mod-Alt-0': function ModAlt0() {
        return _this2.editor.commands.setParagraph();
      }
    };
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-strike/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-strike/dist/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Strike: function() { return /* binding */ Strike; },
/* harmony export */   "default": function() { return /* binding */ Strike; },
/* harmony export */   inputRegex: function() { return /* binding */ inputRegex; },
/* harmony export */   pasteRegex: function() { return /* binding */ pasteRegex; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");

var inputRegex = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/;
var pasteRegex = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g;
var Strike = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({
  name: 'strike',
  addOptions: function addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML: function parseHTML() {
    return [{
      tag: 's'
    }, {
      tag: 'del'
    }, {
      tag: 'strike'
    }, {
      style: 'text-decoration',
      consuming: false,
      getAttrs: function getAttrs(style) {
        return style.includes('line-through') ? {} : false;
      }
    }];
  },
  renderHTML: function renderHTML(_ref) {
    var HTMLAttributes = _ref.HTMLAttributes;
    return ['s', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands: function addCommands() {
    var _this = this;
    return {
      setStrike: function setStrike() {
        return function (_ref2) {
          var commands = _ref2.commands;
          return commands.setMark(_this.name);
        };
      },
      toggleStrike: function toggleStrike() {
        return function (_ref3) {
          var commands = _ref3.commands;
          return commands.toggleMark(_this.name);
        };
      },
      unsetStrike: function unsetStrike() {
        return function (_ref4) {
          var commands = _ref4.commands;
          return commands.unsetMark(_this.name);
        };
      }
    };
  },
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this2 = this;
    var shortcuts = {};
    if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.isMacOS)()) {
      shortcuts['Mod-Shift-s'] = function () {
        return _this2.editor.commands.toggleStrike();
      };
    } else {
      shortcuts['Ctrl-Shift-s'] = function () {
        return _this2.editor.commands.toggleStrike();
      };
    }
    return shortcuts;
  },
  addInputRules: function addInputRules() {
    return [(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({
      find: inputRegex,
      type: this.type
    })];
  },
  addPasteRules: function addPasteRules() {
    return [(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({
      find: pasteRegex,
      type: this.type
    })];
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-text/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-text/dist/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Text: function() { return /* binding */ Text; },
/* harmony export */   "default": function() { return /* binding */ Text; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");

var Text = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({
  name: 'text',
  group: 'inline'
});


/***/ }),

/***/ "./node_modules/@tiptap/extension-underline/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-underline/dist/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Underline: function() { return /* binding */ Underline; },
/* harmony export */   "default": function() { return /* binding */ Underline; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");

var Underline = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({
  name: 'underline',
  addOptions: function addOptions() {
    return {
      HTMLAttributes: {}
    };
  },
  parseHTML: function parseHTML() {
    return [{
      tag: 'u'
    }, {
      style: 'text-decoration',
      consuming: false,
      getAttrs: function getAttrs(style) {
        return style.includes('underline') ? {} : false;
      }
    }];
  },
  renderHTML: function renderHTML(_ref) {
    var HTMLAttributes = _ref.HTMLAttributes;
    return ['u', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];
  },
  addCommands: function addCommands() {
    var _this = this;
    return {
      setUnderline: function setUnderline() {
        return function (_ref2) {
          var commands = _ref2.commands;
          return commands.setMark(_this.name);
        };
      },
      toggleUnderline: function toggleUnderline() {
        return function (_ref3) {
          var commands = _ref3.commands;
          return commands.toggleMark(_this.name);
        };
      },
      unsetUnderline: function unsetUnderline() {
        return function (_ref4) {
          var commands = _ref4.commands;
          return commands.unsetMark(_this.name);
        };
      }
    };
  },
  addKeyboardShortcuts: function addKeyboardShortcuts() {
    var _this2 = this;
    return {
      'Mod-u': function ModU() {
        return _this2.editor.commands.toggleUnderline();
      },
      'Mod-U': function ModU() {
        return _this2.editor.commands.toggleUnderline();
      }
    };
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/pm/commands/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/pm/commands/dist/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   autoJoin: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.autoJoin; },
/* harmony export */   baseKeymap: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.baseKeymap; },
/* harmony export */   chainCommands: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.chainCommands; },
/* harmony export */   createParagraphNear: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.createParagraphNear; },
/* harmony export */   deleteSelection: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.deleteSelection; },
/* harmony export */   exitCode: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.exitCode; },
/* harmony export */   joinBackward: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinBackward; },
/* harmony export */   joinDown: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinDown; },
/* harmony export */   joinForward: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinForward; },
/* harmony export */   joinTextblockBackward: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockBackward; },
/* harmony export */   joinTextblockForward: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockForward; },
/* harmony export */   joinUp: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinUp; },
/* harmony export */   lift: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.lift; },
/* harmony export */   liftEmptyBlock: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.liftEmptyBlock; },
/* harmony export */   macBaseKeymap: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.macBaseKeymap; },
/* harmony export */   newlineInCode: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.newlineInCode; },
/* harmony export */   pcBaseKeymap: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.pcBaseKeymap; },
/* harmony export */   selectAll: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectAll; },
/* harmony export */   selectNodeBackward: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeBackward; },
/* harmony export */   selectNodeForward: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeForward; },
/* harmony export */   selectParentNode: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectParentNode; },
/* harmony export */   selectTextblockEnd: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockEnd; },
/* harmony export */   selectTextblockStart: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockStart; },
/* harmony export */   setBlockType: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.setBlockType; },
/* harmony export */   splitBlock: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlock; },
/* harmony export */   splitBlockAs: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockAs; },
/* harmony export */   splitBlockKeepMarks: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockKeepMarks; },
/* harmony export */   toggleMark: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.toggleMark; },
/* harmony export */   wrapIn: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.wrapIn; }
/* harmony export */ });
/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-commands */ "./node_modules/prosemirror-commands/dist/index.js");
// commands/index.ts


/***/ }),

/***/ "./node_modules/@tiptap/pm/dropcursor/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dropcursor/dist/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dropCursor: function() { return /* reexport safe */ prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__.dropCursor; }
/* harmony export */ });
/* harmony import */ var prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-dropcursor */ "./node_modules/prosemirror-dropcursor/dist/index.js");
// dropcursor/index.ts


/***/ }),

/***/ "./node_modules/@tiptap/pm/gapcursor/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/gapcursor/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GapCursor: function() { return /* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.GapCursor; },
/* harmony export */   gapCursor: function() { return /* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.gapCursor; }
/* harmony export */ });
/* harmony import */ var prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-gapcursor */ "./node_modules/prosemirror-gapcursor/dist/index.js");
// gapcursor/index.ts


/***/ }),

/***/ "./node_modules/@tiptap/pm/history/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@tiptap/pm/history/dist/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   closeHistory: function() { return /* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.closeHistory; },
/* harmony export */   history: function() { return /* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.history; },
/* harmony export */   redo: function() { return /* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redo; },
/* harmony export */   redoDepth: function() { return /* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoDepth; },
/* harmony export */   undo: function() { return /* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undo; },
/* harmony export */   undoDepth: function() { return /* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoDepth; }
/* harmony export */ });
/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-history */ "./node_modules/prosemirror-history/dist/index.js");
// history/index.ts


/***/ }),

/***/ "./node_modules/@tiptap/pm/keymap/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@tiptap/pm/keymap/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   keydownHandler: function() { return /* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keydownHandler; },
/* harmony export */   keymap: function() { return /* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keymap; }
/* harmony export */ });
/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-keymap */ "./node_modules/prosemirror-keymap/dist/index.js");
// keymap/index.ts


/***/ }),

/***/ "./node_modules/@tiptap/pm/model/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/model/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContentMatch: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ContentMatch; },
/* harmony export */   DOMParser: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser; },
/* harmony export */   DOMSerializer: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer; },
/* harmony export */   Fragment: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment; },
/* harmony export */   Mark: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark; },
/* harmony export */   MarkType: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType; },
/* harmony export */   Node: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node; },
/* harmony export */   NodeRange: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange; },
/* harmony export */   NodeType: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeType; },
/* harmony export */   ReplaceError: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError; },
/* harmony export */   ResolvedPos: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ResolvedPos; },
/* harmony export */   Schema: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Schema; },
/* harmony export */   Slice: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice; }
/* harmony export */ });
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.js");
// model/index.ts


/***/ }),

/***/ "./node_modules/@tiptap/pm/schema-list/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/pm/schema-list/dist/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addListNodes: function() { return /* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.addListNodes; },
/* harmony export */   bulletList: function() { return /* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.bulletList; },
/* harmony export */   liftListItem: function() { return /* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.liftListItem; },
/* harmony export */   listItem: function() { return /* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.listItem; },
/* harmony export */   orderedList: function() { return /* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.orderedList; },
/* harmony export */   sinkListItem: function() { return /* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.sinkListItem; },
/* harmony export */   splitListItem: function() { return /* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItem; },
/* harmony export */   wrapInList: function() { return /* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.wrapInList; }
/* harmony export */ });
/* harmony import */ var prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-schema-list */ "./node_modules/prosemirror-schema-list/dist/index.js");
// schema-list/index.ts


/***/ }),

/***/ "./node_modules/@tiptap/pm/state/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/state/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AllSelection: function() { return /* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection; },
/* harmony export */   EditorState: function() { return /* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState; },
/* harmony export */   NodeSelection: function() { return /* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection; },
/* harmony export */   Plugin: function() { return /* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin; },
/* harmony export */   PluginKey: function() { return /* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey; },
/* harmony export */   Selection: function() { return /* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection; },
/* harmony export */   SelectionRange: function() { return /* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange; },
/* harmony export */   TextSelection: function() { return /* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection; },
/* harmony export */   Transaction: function() { return /* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Transaction; }
/* harmony export */ });
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");
// state/index.ts


/***/ }),

/***/ "./node_modules/@tiptap/pm/transform/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/transform/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AddMarkStep: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddMarkStep; },
/* harmony export */   AddNodeMarkStep: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddNodeMarkStep; },
/* harmony export */   AttrStep: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AttrStep; },
/* harmony export */   DocAttrStep: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.DocAttrStep; },
/* harmony export */   MapResult: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.MapResult; },
/* harmony export */   Mapping: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Mapping; },
/* harmony export */   RemoveMarkStep: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveMarkStep; },
/* harmony export */   RemoveNodeMarkStep: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveNodeMarkStep; },
/* harmony export */   ReplaceAroundStep: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep; },
/* harmony export */   ReplaceStep: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep; },
/* harmony export */   Step: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Step; },
/* harmony export */   StepMap: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepMap; },
/* harmony export */   StepResult: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepResult; },
/* harmony export */   Transform: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Transform; },
/* harmony export */   TransformError: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.TransformError; },
/* harmony export */   canJoin: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin; },
/* harmony export */   canSplit: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit; },
/* harmony export */   dropPoint: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.dropPoint; },
/* harmony export */   findWrapping: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping; },
/* harmony export */   insertPoint: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.insertPoint; },
/* harmony export */   joinPoint: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint; },
/* harmony export */   liftTarget: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget; },
/* harmony export */   replaceStep: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep; }
/* harmony export */ });
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.js");
// transform/index.ts


/***/ }),

/***/ "./node_modules/@tiptap/pm/view/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@tiptap/pm/view/dist/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Decoration: function() { return /* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration; },
/* harmony export */   DecorationSet: function() { return /* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.DecorationSet; },
/* harmony export */   EditorView: function() { return /* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView; },
/* harmony export */   __endComposition: function() { return /* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__endComposition; },
/* harmony export */   __parseFromClipboard: function() { return /* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__parseFromClipboard; },
/* harmony export */   __serializeForClipboard: function() { return /* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__serializeForClipboard; }
/* harmony export */ });
/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-view */ "./node_modules/prosemirror-view/dist/index.js");
// view/index.ts


/***/ }),

/***/ "./node_modules/@tiptap/starter-kit/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/starter-kit/dist/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StarterKit: function() { return /* binding */ StarterKit; },
/* harmony export */   "default": function() { return /* binding */ StarterKit; }
/* harmony export */ });
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
/* harmony import */ var _tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-blockquote */ "./node_modules/@tiptap/extension-blockquote/dist/index.js");
/* harmony import */ var _tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/extension-bold */ "./node_modules/@tiptap/extension-bold/dist/index.js");
/* harmony import */ var _tiptap_extension_bullet_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/extension-bullet-list */ "./node_modules/@tiptap/extension-bullet-list/dist/index.js");
/* harmony import */ var _tiptap_extension_code__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-code */ "./node_modules/@tiptap/extension-code/dist/index.js");
/* harmony import */ var _tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-code-block */ "./node_modules/@tiptap/extension-code-block/dist/index.js");
/* harmony import */ var _tiptap_extension_document__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/extension-document */ "./node_modules/@tiptap/extension-document/dist/index.js");
/* harmony import */ var _tiptap_extension_dropcursor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/extension-dropcursor */ "./node_modules/@tiptap/extension-dropcursor/dist/index.js");
/* harmony import */ var _tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tiptap/extension-gapcursor */ "./node_modules/@tiptap/extension-gapcursor/dist/index.js");
/* harmony import */ var _tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tiptap/extension-hard-break */ "./node_modules/@tiptap/extension-hard-break/dist/index.js");
/* harmony import */ var _tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tiptap/extension-heading */ "./node_modules/@tiptap/extension-heading/dist/index.js");
/* harmony import */ var _tiptap_extension_history__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tiptap/extension-history */ "./node_modules/@tiptap/extension-history/dist/index.js");
/* harmony import */ var _tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tiptap/extension-horizontal-rule */ "./node_modules/@tiptap/extension-horizontal-rule/dist/index.js");
/* harmony import */ var _tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tiptap/extension-italic */ "./node_modules/@tiptap/extension-italic/dist/index.js");
/* harmony import */ var _tiptap_extension_list_item__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tiptap/extension-list-item */ "./node_modules/@tiptap/extension-list-item/dist/index.js");
/* harmony import */ var _tiptap_extension_ordered_list__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tiptap/extension-ordered-list */ "./node_modules/@tiptap/extension-ordered-list/dist/index.js");
/* harmony import */ var _tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tiptap/extension-paragraph */ "./node_modules/@tiptap/extension-paragraph/dist/index.js");
/* harmony import */ var _tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tiptap/extension-strike */ "./node_modules/@tiptap/extension-strike/dist/index.js");
/* harmony import */ var _tiptap_extension_text__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @tiptap/extension-text */ "./node_modules/@tiptap/extension-text/dist/index.js");



















var StarterKit = _tiptap_core__WEBPACK_IMPORTED_MODULE_18__.Extension.create({
  name: 'starterKit',
  addExtensions: function addExtensions() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    var extensions = [];
    if (this.options.blockquote !== false) {
      extensions.push(_tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__.Blockquote.configure((_a = this.options) === null || _a === void 0 ? void 0 : _a.blockquote));
    }
    if (this.options.bold !== false) {
      extensions.push(_tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__.Bold.configure((_b = this.options) === null || _b === void 0 ? void 0 : _b.bold));
    }
    if (this.options.bulletList !== false) {
      extensions.push(_tiptap_extension_bullet_list__WEBPACK_IMPORTED_MODULE_2__.BulletList.configure((_c = this.options) === null || _c === void 0 ? void 0 : _c.bulletList));
    }
    if (this.options.code !== false) {
      extensions.push(_tiptap_extension_code__WEBPACK_IMPORTED_MODULE_3__.Code.configure((_d = this.options) === null || _d === void 0 ? void 0 : _d.code));
    }
    if (this.options.codeBlock !== false) {
      extensions.push(_tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_4__.CodeBlock.configure((_e = this.options) === null || _e === void 0 ? void 0 : _e.codeBlock));
    }
    if (this.options.document !== false) {
      extensions.push(_tiptap_extension_document__WEBPACK_IMPORTED_MODULE_5__.Document.configure((_f = this.options) === null || _f === void 0 ? void 0 : _f.document));
    }
    if (this.options.dropcursor !== false) {
      extensions.push(_tiptap_extension_dropcursor__WEBPACK_IMPORTED_MODULE_6__.Dropcursor.configure((_g = this.options) === null || _g === void 0 ? void 0 : _g.dropcursor));
    }
    if (this.options.gapcursor !== false) {
      extensions.push(_tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_7__.Gapcursor.configure((_h = this.options) === null || _h === void 0 ? void 0 : _h.gapcursor));
    }
    if (this.options.hardBreak !== false) {
      extensions.push(_tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_8__.HardBreak.configure((_j = this.options) === null || _j === void 0 ? void 0 : _j.hardBreak));
    }
    if (this.options.heading !== false) {
      extensions.push(_tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_9__.Heading.configure((_k = this.options) === null || _k === void 0 ? void 0 : _k.heading));
    }
    if (this.options.history !== false) {
      extensions.push(_tiptap_extension_history__WEBPACK_IMPORTED_MODULE_10__.History.configure((_l = this.options) === null || _l === void 0 ? void 0 : _l.history));
    }
    if (this.options.horizontalRule !== false) {
      extensions.push(_tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_11__.HorizontalRule.configure((_m = this.options) === null || _m === void 0 ? void 0 : _m.horizontalRule));
    }
    if (this.options.italic !== false) {
      extensions.push(_tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_12__.Italic.configure((_o = this.options) === null || _o === void 0 ? void 0 : _o.italic));
    }
    if (this.options.listItem !== false) {
      extensions.push(_tiptap_extension_list_item__WEBPACK_IMPORTED_MODULE_13__.ListItem.configure((_p = this.options) === null || _p === void 0 ? void 0 : _p.listItem));
    }
    if (this.options.orderedList !== false) {
      extensions.push(_tiptap_extension_ordered_list__WEBPACK_IMPORTED_MODULE_14__.OrderedList.configure((_q = this.options) === null || _q === void 0 ? void 0 : _q.orderedList));
    }
    if (this.options.paragraph !== false) {
      extensions.push(_tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_15__.Paragraph.configure((_r = this.options) === null || _r === void 0 ? void 0 : _r.paragraph));
    }
    if (this.options.strike !== false) {
      extensions.push(_tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_16__.Strike.configure((_s = this.options) === null || _s === void 0 ? void 0 : _s.strike));
    }
    if (this.options.text !== false) {
      extensions.push(_tiptap_extension_text__WEBPACK_IMPORTED_MODULE_17__.Text.configure((_t = this.options) === null || _t === void 0 ? void 0 : _t.text));
    }
    return extensions;
  }
});


/***/ }),

/***/ "./node_modules/@tiptap/suggestion/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@tiptap/suggestion/dist/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Suggestion: function() { return /* binding */ Suggestion; },
/* harmony export */   SuggestionPluginKey: function() { return /* binding */ SuggestionPluginKey; },
/* harmony export */   "default": function() { return /* binding */ Suggestion; },
/* harmony export */   findSuggestionMatch: function() { return /* binding */ findSuggestionMatch; }
/* harmony export */ });
/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ "./node_modules/@tiptap/pm/state/dist/index.js");
/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/view */ "./node_modules/@tiptap/pm/view/dist/index.js");
/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ "./node_modules/@tiptap/core/dist/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }



function findSuggestionMatch(config) {
  var _a;
  var _char = config["char"],
    allowSpaces = config.allowSpaces,
    allowedPrefixes = config.allowedPrefixes,
    startOfLine = config.startOfLine,
    $position = config.$position;
  var escapedChar = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.escapeForRegEx)(_char);
  var suffix = new RegExp("\\s".concat(escapedChar, "$"));
  var prefix = startOfLine ? '^' : '';
  var regexp = allowSpaces ? new RegExp("".concat(prefix).concat(escapedChar, ".*?(?=\\s").concat(escapedChar, "|$)"), 'gm') : new RegExp("".concat(prefix, "(?:^)?").concat(escapedChar, "[^\\s").concat(escapedChar, "]*"), 'gm');
  var text = ((_a = $position.nodeBefore) === null || _a === void 0 ? void 0 : _a.isText) && $position.nodeBefore.text;
  if (!text) {
    return null;
  }
  var textFrom = $position.pos - text.length;
  var match = Array.from(text.matchAll(regexp)).pop();
  if (!match || match.input === undefined || match.index === undefined) {
    return null;
  }
  // JavaScript doesn't have lookbehinds. This hacks a check that first character
  // is a space or the start of the line
  var matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);
  var matchPrefixIsAllowed = new RegExp("^[".concat(allowedPrefixes === null || allowedPrefixes === void 0 ? void 0 : allowedPrefixes.join(''), "\0]?$")).test(matchPrefix);
  if (allowedPrefixes !== null && !matchPrefixIsAllowed) {
    return null;
  }
  // The absolute position of the match in the document
  var from = textFrom + match.index;
  var to = from + match[0].length;
  // Edge case handling; if spaces are allowed and we're directly in between
  // two triggers
  if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {
    match[0] += ' ';
    to += 1;
  }
  // If the $position is located within the matched substring, return that range
  if (from < $position.pos && to >= $position.pos) {
    return {
      range: {
        from: from,
        to: to
      },
      query: match[0].slice(_char.length),
      text: match[0]
    };
  }
  return null;
}
var SuggestionPluginKey = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('suggestion');
function Suggestion(_ref) {
  var _ref$pluginKey = _ref.pluginKey,
    pluginKey = _ref$pluginKey === void 0 ? SuggestionPluginKey : _ref$pluginKey,
    editor = _ref.editor,
    _ref$char = _ref["char"],
    _char2 = _ref$char === void 0 ? '@' : _ref$char,
    _ref$allowSpaces = _ref.allowSpaces,
    allowSpaces = _ref$allowSpaces === void 0 ? false : _ref$allowSpaces,
    _ref$allowedPrefixes = _ref.allowedPrefixes,
    allowedPrefixes = _ref$allowedPrefixes === void 0 ? [' '] : _ref$allowedPrefixes,
    _ref$startOfLine = _ref.startOfLine,
    startOfLine = _ref$startOfLine === void 0 ? false : _ref$startOfLine,
    _ref$decorationTag = _ref.decorationTag,
    decorationTag = _ref$decorationTag === void 0 ? 'span' : _ref$decorationTag,
    _ref$decorationClass = _ref.decorationClass,
    decorationClass = _ref$decorationClass === void 0 ? 'suggestion' : _ref$decorationClass,
    _ref$command = _ref.command,
    _command = _ref$command === void 0 ? function () {
      return null;
    } : _ref$command,
    _ref$items = _ref.items,
    items = _ref$items === void 0 ? function () {
      return [];
    } : _ref$items,
    _ref$render = _ref.render,
    render = _ref$render === void 0 ? function () {
      return {};
    } : _ref$render,
    _ref$allow = _ref.allow,
    allow = _ref$allow === void 0 ? function () {
      return true;
    } : _ref$allow;
  var props;
  var renderer = render === null || render === void 0 ? void 0 : render();
  var plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({
    key: pluginKey,
    view: function view() {
      var _this = this;
      return {
        update: function () {
          var _update = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(view, prevState) {
            var _a, _b, _c, _d, _e, _f, _g, prev, next, moved, started, stopped, changed, handleStart, handleChange, handleExit, state, decorationNode;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  prev = (_a = _this.key) === null || _a === void 0 ? void 0 : _a.getState(prevState);
                  next = (_b = _this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state); // See how the state changed
                  moved = prev.active && next.active && prev.range.from !== next.range.from;
                  started = !prev.active && next.active;
                  stopped = prev.active && !next.active;
                  changed = !started && !stopped && prev.query !== next.query;
                  handleStart = started || moved;
                  handleChange = changed && !moved;
                  handleExit = stopped || moved; // Cancel when suggestion isn't active
                  if (!(!handleStart && !handleChange && !handleExit)) {
                    _context.next = 11;
                    break;
                  }
                  return _context.abrupt("return");
                case 11:
                  state = handleExit && !handleStart ? prev : next;
                  decorationNode = view.dom.querySelector("[data-decoration-id=\"".concat(state.decorationId, "\"]"));
                  props = {
                    editor: editor,
                    range: state.range,
                    query: state.query,
                    text: state.text,
                    items: [],
                    command: function command(commandProps) {
                      _command({
                        editor: editor,
                        range: state.range,
                        props: commandProps
                      });
                    },
                    decorationNode: decorationNode,
                    // virtual node for popper.js or tippy.js
                    // this can be used for building popups without a DOM node
                    clientRect: decorationNode ? function () {
                      var _a;
                      // because of `items` can be asynchrounous well search for the current decoration node
                      var _ref2 = (_a = _this.key) === null || _a === void 0 ? void 0 : _a.getState(editor.state),
                        decorationId = _ref2.decorationId; // eslint-disable-line
                      var currentDecorationNode = view.dom.querySelector("[data-decoration-id=\"".concat(decorationId, "\"]"));
                      return (currentDecorationNode === null || currentDecorationNode === void 0 ? void 0 : currentDecorationNode.getBoundingClientRect()) || null;
                    } : null
                  };
                  if (handleStart) {
                    (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeStart) === null || _c === void 0 ? void 0 : _c.call(renderer, props);
                  }
                  if (handleChange) {
                    (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);
                  }
                  if (!(handleChange || handleStart)) {
                    _context.next = 20;
                    break;
                  }
                  _context.next = 19;
                  return items({
                    editor: editor,
                    query: state.query
                  });
                case 19:
                  props.items = _context.sent;
                case 20:
                  if (handleExit) {
                    (_e = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _e === void 0 ? void 0 : _e.call(renderer, props);
                  }
                  if (handleChange) {
                    (_f = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _f === void 0 ? void 0 : _f.call(renderer, props);
                  }
                  if (handleStart) {
                    (_g = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _g === void 0 ? void 0 : _g.call(renderer, props);
                  }
                case 23:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          function update(_x, _x2) {
            return _update.apply(this, arguments);
          }
          return update;
        }(),
        destroy: function destroy() {
          var _a;
          if (!props) {
            return;
          }
          (_a = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a === void 0 ? void 0 : _a.call(renderer, props);
        }
      };
    },
    state: {
      // Initialize the plugin's internal state.
      init: function init() {
        var state = {
          active: false,
          range: {
            from: 0,
            to: 0
          },
          query: null,
          text: null,
          composing: false
        };
        return state;
      },
      // Apply changes to the plugin state from a view transaction.
      apply: function apply(transaction, prev, oldState, state) {
        var isEditable = editor.isEditable;
        var composing = editor.view.composing;
        var selection = transaction.selection;
        var empty = selection.empty,
          from = selection.from;
        var next = _objectSpread({}, prev);
        next.composing = composing;
        // We can only be suggesting if the view is editable, and:
        //   * there is no selection, or
        //   * a composition is active (see: https://github.com/ueberdosis/tiptap/issues/1449)
        if (isEditable && (empty || editor.view.composing)) {
          // Reset active state if we just left the previous suggestion range
          if ((from < prev.range.from || from > prev.range.to) && !composing && !prev.composing) {
            next.active = false;
          }
          // Try to match against where our cursor currently is
          var match = findSuggestionMatch({
            "char": _char2,
            allowSpaces: allowSpaces,
            allowedPrefixes: allowedPrefixes,
            startOfLine: startOfLine,
            $position: selection.$from
          });
          var decorationId = "id_".concat(Math.floor(Math.random() * 0xffffffff));
          // If we found a match, update the current state to show it
          if (match && allow({
            editor: editor,
            state: state,
            range: match.range
          })) {
            next.active = true;
            next.decorationId = prev.decorationId ? prev.decorationId : decorationId;
            next.range = match.range;
            next.query = match.query;
            next.text = match.text;
          } else {
            next.active = false;
          }
        } else {
          next.active = false;
        }
        // Make sure to empty the range if suggestion is inactive
        if (!next.active) {
          next.decorationId = null;
          next.range = {
            from: 0,
            to: 0
          };
          next.query = null;
          next.text = null;
        }
        return next;
      }
    },
    props: {
      // Call the keydown hook if suggestion is active.
      handleKeyDown: function handleKeyDown(view, event) {
        var _a;
        var _plugin$getState = plugin.getState(view.state),
          active = _plugin$getState.active,
          range = _plugin$getState.range;
        if (!active) {
          return false;
        }
        return ((_a = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(renderer, {
          view: view,
          event: event,
          range: range
        })) || false;
      },
      // Setup decorator on the currently active suggestion.
      decorations: function decorations(state) {
        var _plugin$getState2 = plugin.getState(state),
          active = _plugin$getState2.active,
          range = _plugin$getState2.range,
          decorationId = _plugin$getState2.decorationId;
        if (!active) {
          return null;
        }
        return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.DecorationSet.create(state.doc, [_tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.inline(range.from, range.to, {
          nodeName: decorationTag,
          "class": decorationClass,
          'data-decoration-id': decorationId
        })]);
      }
    }
  });
  return plugin;
}


/***/ }),

/***/ "./node_modules/orderedmap/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/orderedmap/dist/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// ::- Persistent data structure representing an ordered mapping from
// strings to values, with some convenient update methods.
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function find(key) {
    for (var i = 0; i < this.content.length; i += 2) if (this.content[i] === key) return i;
    return -1;
  },
  // :: (string)  ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function get(key) {
    var found = this.find(key);
    return found == -1 ? undefined : this.content[found + 1];
  },
  // :: (string, any, ?string)  OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function update(key, value, newKey) {
    var self = newKey && newKey != key ? this.remove(newKey) : this;
    var found = self.find(key),
      content = self.content.slice();
    if (found == -1) {
      content.push(newKey || key, value);
    } else {
      content[found + 1] = value;
      if (newKey) content[found] = newKey;
    }
    return new OrderedMap(content);
  },
  // :: (string)  OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function remove(key) {
    var found = this.find(key);
    if (found == -1) return this;
    var content = this.content.slice();
    content.splice(found, 2);
    return new OrderedMap(content);
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the start of the map.
  addToStart: function addToStart(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function addToEnd(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  // :: (string, string, any)  OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function addBefore(place, key, value) {
    var without = this.remove(key),
      content = without.content.slice();
    var found = without.find(place);
    content.splice(found == -1 ? content.length : found, 0, key, value);
    return new OrderedMap(content);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function forEach(f) {
    for (var i = 0; i < this.content.length; i += 2) f(this.content[i], this.content[i + 1]);
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function prepend(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this;
    return new OrderedMap(map.content.concat(this.subtract(map).content));
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function append(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this;
    return new OrderedMap(this.subtract(map).content.concat(map.content));
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function subtract(map) {
    var result = this;
    map = OrderedMap.from(map);
    for (var i = 0; i < map.content.length; i += 2) result = result.remove(map.content[i]);
    return result;
  },
  // :: ()  Object
  // Turn ordered map into a plain object.
  toObject: function toObject() {
    var result = {};
    this.forEach(function (key, value) {
      result[key] = value;
    });
    return result;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};

// :: (?union<Object, OrderedMap>)  OrderedMap
// Return a map with the given content. If null, create an empty
// map. If given an ordered map, return that map itself. If given an
// object, create a map from the object's properties.
OrderedMap.from = function (value) {
  if (value instanceof OrderedMap) return value;
  var content = [];
  if (value) for (var prop in value) content.push(prop, value[prop]);
  return new OrderedMap(content);
};
/* harmony default export */ __webpack_exports__["default"] = (OrderedMap);

/***/ }),

/***/ "./node_modules/picmo/dist/index.js":
/*!******************************************!*\
  !*** ./node_modules/picmo/dist/index.js ***!
  \******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EmojiPicker: function() { return /* binding */ _s; },
/* harmony export */   Events: function() { return /* binding */ le; },
/* harmony export */   FocusTrap: function() { return /* binding */ st; },
/* harmony export */   InMemoryProvider: function() { return /* binding */ qs; },
/* harmony export */   InMemoryStoreFactory: function() { return /* binding */ Se; },
/* harmony export */   IndexedDbStoreFactory: function() { return /* binding */ Le; },
/* harmony export */   LocalStorageProvider: function() { return /* binding */ zt; },
/* harmony export */   NativeRenderer: function() { return /* binding */ Ft; },
/* harmony export */   RecentsProvider: function() { return /* binding */ Ae; },
/* harmony export */   Renderer: function() { return /* binding */ Et; },
/* harmony export */   SessionStorageProvider: function() { return /* binding */ Us; },
/* harmony export */   animate: function() { return /* binding */ I; },
/* harmony export */   autoTheme: function() { return /* binding */ Os; },
/* harmony export */   caseInsensitiveIncludes: function() { return /* binding */ ue; },
/* harmony export */   computeHash: function() { return /* binding */ Ue; },
/* harmony export */   createDatabase: function() { return /* binding */ Ws; },
/* harmony export */   createPicker: function() { return /* binding */ Hs; },
/* harmony export */   createStyleInjector: function() { return /* binding */ Ss; },
/* harmony export */   darkTheme: function() { return /* binding */ Ns; },
/* harmony export */   debounce: function() { return /* binding */ Ke; },
/* harmony export */   deleteDatabase: function() { return /* binding */ Bs; },
/* harmony export */   empty: function() { return /* binding */ V; },
/* harmony export */   en: function() { return /* binding */ ze; },
/* harmony export */   getEmojiForEvent: function() { return /* binding */ q; },
/* harmony export */   getOptions: function() { return /* binding */ $t; },
/* harmony export */   getPrefixedClasses: function() { return /* binding */ p; },
/* harmony export */   globalConfig: function() { return /* binding */ At; },
/* harmony export */   i18n: function() { return /* binding */ Ks; },
/* harmony export */   isLocalStorageAvailable: function() { return /* binding */ qe; },
/* harmony export */   isSessionStorageAvailable: function() { return /* binding */ xe; },
/* harmony export */   lightTheme: function() { return /* binding */ ot; },
/* harmony export */   prefixClassName: function() { return /* binding */ ne; },
/* harmony export */   replaceChildren: function() { return /* binding */ w; },
/* harmony export */   shouldAnimate: function() { return /* binding */ _e; },
/* harmony export */   throttle: function() { return /* binding */ He; },
/* harmony export */   toElement: function() { return /* binding */ Q; }
/* harmony export */ });
var _excluded = ["skins"],
  _excluded2 = ["local", "version", "cdnUrl"],
  _excluded3 = ["compact", "flat", "shortcodes"];
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function (_e2) { function e(_x57) { return _e2.apply(this, arguments); } e.toString = function () { return _e2.toString(); }; return e; }(function (e) { throw e; }), f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function (_e3) { function e(_x58) { return _e3.apply(this, arguments); } e.toString = function () { return _e3.toString(); }; return e; }(function (e) { didErr = true; err = e; }), f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var U = function U(s, e, t) {
  if (!e.has(s)) throw TypeError("Cannot " + t);
};
var y = function y(s, e, t) {
    return U(s, e, "read from private field"), t ? t.call(s) : e.get(s);
  },
  f = function f(s, e, t) {
    if (e.has(s)) throw TypeError("Cannot add the same private member more than once");
    e instanceof WeakSet ? e.add(s) : e.set(s, t);
  },
  A = function A(s, e, t, o) {
    return U(s, e, "write to private field"), o ? o.call(s, t) : e.set(s, t), t;
  };
var g = function g(s, e, t) {
  return U(s, e, "access private method"), t;
};
var Ve = "14.0";
function De(s, e, t) {
  var o = "https://cdn.jsdelivr.net/npm/emojibase-data@".concat(e, "/").concat(s);
  return typeof t == "function" ? o = t(s, e) : typeof t == "string" && (o = "".concat(t, "/").concat(s)), o;
}
function ae(_x) {
  return _ae.apply(this, arguments);
}
function _ae() {
  _ae = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee35(s) {
    var e,
      _e$local,
      t,
      _e$version,
      o,
      i,
      r,
      a,
      n,
      l,
      m,
      d,
      h,
      _args35 = arguments;
    return _regeneratorRuntime().wrap(function _callee35$(_context35) {
      while (1) switch (_context35.prev = _context35.next) {
        case 0:
          e = _args35.length > 1 && _args35[1] !== undefined ? _args35[1] : {};
          _e$local = e.local, t = _e$local === void 0 ? !1 : _e$local, _e$version = e.version, o = _e$version === void 0 ? "latest" : _e$version, i = e.cdnUrl, r = _objectWithoutProperties(e, _excluded2), a = De(s, o, i), n = t ? localStorage : sessionStorage, l = "emojibase/".concat(o, "/").concat(s), m = n.getItem(l);
          if (!m) {
            _context35.next = 4;
            break;
          }
          return _context35.abrupt("return", Promise.resolve(JSON.parse(m)));
        case 4:
          _context35.next = 6;
          return fetch(a, _objectSpread({
            credentials: "omit",
            mode: "cors",
            redirect: "error"
          }, r));
        case 6:
          d = _context35.sent;
          if (d.ok) {
            _context35.next = 9;
            break;
          }
          throw new Error("Failed to load Emojibase dataset.");
        case 9:
          _context35.next = 11;
          return d.json();
        case 11:
          h = _context35.sent;
          try {
            n.setItem(l, JSON.stringify(h));
          } catch (_unused6) {}
          return _context35.abrupt("return", h);
        case 14:
        case "end":
          return _context35.stop();
      }
    }, _callee35);
  }));
  return _ae.apply(this, arguments);
}
var Be = {
  discord: "joypixels",
  slack: "iamcal"
};
function me(_x2, _x3, _x4) {
  return _me.apply(this, arguments);
}
function _me() {
  _me = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee36(s, e, t) {
    var o;
    return _regeneratorRuntime().wrap(function _callee36$(_context36) {
      while (1) switch (_context36.prev = _context36.next) {
        case 0:
          return _context36.abrupt("return", ae("".concat(s, "/shortcodes/").concat((o = Be[e]) !== null && o !== void 0 ? o : e, ".json"), t));
        case 1:
        case "end":
          return _context36.stop();
      }
    }, _callee36);
  }));
  return _me.apply(this, arguments);
}
function k(s, e) {
  if (e.length === 0) return s;
  var t = new Set(s.shortcodes);
  return e.forEach(function (o) {
    var i = o[s.hexcode];
    Array.isArray(i) ? i.forEach(function (r) {
      return t.add(r);
    }) : i && t.add(i);
  }), s.shortcodes = _toConsumableArray(t), s.skins && s.skins.forEach(function (o) {
    k(o, e);
  }), s;
}
function Ne(s) {
  var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var t = [];
  return s.forEach(function (o) {
    if (o.skins) {
      var i = o.skins,
        r = _objectWithoutProperties(o, _excluded);
      t.push(k(r, e)), i.forEach(function (a) {
        var n = _objectSpread({}, a);
        r.tags && (n.tags = _toConsumableArray(r.tags)), t.push(k(n, e));
      });
    } else t.push(k(o, e));
  }), t;
}
function Oe(s, e) {
  return e.length === 0 || s.forEach(function (t) {
    k(t, e);
  }), s;
}
function Ce(_x5) {
  return _Ce.apply(this, arguments);
}
function _Ce() {
  _Ce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee37(s) {
    var e,
      _e$compact,
      t,
      _e$flat,
      o,
      _e$shortcodes,
      i,
      r,
      a,
      n,
      _args37 = arguments;
    return _regeneratorRuntime().wrap(function _callee37$(_context37) {
      while (1) switch (_context37.prev = _context37.next) {
        case 0:
          e = _args37.length > 1 && _args37[1] !== undefined ? _args37[1] : {};
          _e$compact = e.compact;
          t = _e$compact === void 0 ? !1 : _e$compact;
          _e$flat = e.flat;
          o = _e$flat === void 0 ? !1 : _e$flat;
          _e$shortcodes = e.shortcodes;
          i = _e$shortcodes === void 0 ? [] : _e$shortcodes;
          r = _objectWithoutProperties(e, _excluded3);
          _context37.next = 10;
          return ae("".concat(s, "/").concat(t ? "compact" : "data", ".json"), r);
        case 10:
          a = _context37.sent;
          n = [];
          _context37.t0 = i.length > 0;
          if (!_context37.t0) {
            _context37.next = 17;
            break;
          }
          _context37.next = 16;
          return Promise.all(i.map(function (l) {
            var m;
            if (l.includes("/")) {
              var _l$split = l.split("/"),
                _l$split2 = _slicedToArray(_l$split, 2),
                d = _l$split2[0],
                h = _l$split2[1];
              m = me(d, h, r);
            } else m = me(s, l, r);
            return m["catch"](function () {
              return {};
            });
          }));
        case 16:
          n = _context37.sent;
        case 17:
          return _context37.abrupt("return", o ? Ne(a, n) : Oe(a, n));
        case 18:
        case "end":
          return _context37.stop();
      }
    }, _callee37);
  }));
  return _Ce.apply(this, arguments);
}
function je(_x6, _x7) {
  return _je.apply(this, arguments);
}
function _je() {
  _je = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee38(s, e) {
    return _regeneratorRuntime().wrap(function _callee38$(_context38) {
      while (1) switch (_context38.prev = _context38.next) {
        case 0:
          return _context38.abrupt("return", ae("".concat(s, "/messages.json"), e));
        case 1:
        case "end":
          return _context38.stop();
      }
    }, _callee38);
  }));
  return _je.apply(this, arguments);
}
function q(s, e) {
  var o = s.target.closest("[data-emoji]");
  if (o) {
    var i = e.find(function (r) {
      return r.emoji === o.dataset.emoji;
    });
    if (i) return i;
  }
  return null;
}
function _e(s) {
  var t;
  var e = (t = window.matchMedia) == null ? void 0 : t.call(window, "(prefers-reduced-motion: reduce)");
  return s.animate && !(e != null && e.matches);
}
function ue(s, e) {
  return s.toLowerCase().includes(e.toLowerCase());
}
function He(s, e) {
  var t = null;
  return function () {
    t || (t = window.setTimeout(function () {
      s(), t = null;
    }, e));
  };
}
function Ke(s, e) {
  var t = null;
  return function () {
    for (var _len = arguments.length, o = new Array(_len), _key = 0; _key < _len; _key++) {
      o[_key] = arguments[_key];
    }
    t && window.clearTimeout(t), t = window.setTimeout(function () {
      s.apply(void 0, o), t = null;
    }, e);
  };
}
function I(s, e, t, o) {
  if (_e(o) && s.animate) return s.animate(e, t).finished;
  var i = t.direction === "normal" ? 1 : 0,
    r = Object.entries(e).reduce(function (a, _ref) {
      var _ref2 = _slicedToArray(_ref, 2),
        n = _ref2[0],
        l = _ref2[1];
      return _objectSpread(_objectSpread({}, a), {}, _defineProperty({}, n, l[i]));
    }, {});
  return Object.assign(s.style, r), Promise.resolve();
}
function Q(s) {
  var t;
  var e = document.createElement("template");
  return e.innerHTML = s, (t = e.content) == null ? void 0 : t.firstElementChild;
}
function Ue(_x8) {
  return _Ue.apply(this, arguments);
}
function _Ue() {
  _Ue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee39(s) {
    var e, t;
    return _regeneratorRuntime().wrap(function _callee39$(_context39) {
      while (1) switch (_context39.prev = _context39.next) {
        case 0:
          e = new TextEncoder().encode(s);
          _context39.next = 3;
          return crypto.subtle.digest("SHA-256", e);
        case 3:
          t = _context39.sent;
          return _context39.abrupt("return", Array.from(new Uint8Array(t)).map(function (i) {
            return i.toString(16).padStart(2, "0");
          }).join(""));
        case 5:
        case "end":
          return _context39.stop();
      }
    }, _callee39);
  }));
  return _Ue.apply(this, arguments);
}
function p() {
  for (var _len2 = arguments.length, s = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    s[_key2] = arguments[_key2];
  }
  return s.reduce(function (e, t) {
    return _objectSpread(_objectSpread({}, e), {}, _defineProperty({}, t, ne(t)));
  }, {});
}
function ne(s) {
  return "picmo__".concat(s);
}
function V(s) {
  for (; s.firstChild;) s.removeChild(s.firstChild);
  return s;
}
function w(s) {
  var _V;
  for (var _len3 = arguments.length, e = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    e[_key3 - 1] = arguments[_key3];
  }
  (_V = V(s)).append.apply(_V, e);
}
function ke(s) {
  try {
    return window[s].length, !0;
  } catch (_unused) {
    return !1;
  }
}
function xe() {
  return ke("sessionStorage");
}
function qe() {
  return ke("localStorage");
}
function x(s) {
  var e;
  return {
    emoji: s.emoji,
    label: s.label,
    tags: s.tags,
    skins: (e = s.skins) == null ? void 0 : e.map(function (t) {
      return x(t);
    }),
    order: s.order,
    custom: !1,
    hexcode: s.hexcode,
    version: s.version
  };
}
function B(s, e, t) {
  var o;
  return t && !t.some(function (i) {
    return i.order === s.group;
  }) ? !1 : ue(s.label, e) || ((o = s.tags) == null ? void 0 : o.some(function (i) {
    return ue(i, e);
  }));
}
var Ee = /*#__PURE__*/_createClass(function Ee() {
  var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "en";
  _classCallCheck(this, Ee);
  this.locale = e;
});
var We = [function (s, e) {
  return s.hexcode === "1F91D" && e < 14 && (s.skins = []), s;
}, function (s, e) {
  return s.skins && (s.skins = s.skins.filter(function (t) {
    return !t.version || t.version <= e;
  })), s;
}];
function Ge(s, e) {
  return We.some(function (t) {
    return t(s, e) === null;
  }) ? null : s;
}
function N(s, e) {
  return s.filter(function (t) {
    return Ge(t, e) !== null;
  });
}
var W = {};
function Se(s) {
  return W[s] || (W[s] = new Je(s)), W[s];
}
Se.deleteDatabase = function (s) {};
var Je = /*#__PURE__*/function (_Ee) {
  _inherits(Je, _Ee);
  function Je() {
    _classCallCheck(this, Je);
    return _callSuper(this, Je, arguments);
  }
  _createClass(Je, [{
    key: "open",
    value: function open() {
      return Promise.resolve();
    }
  }, {
    key: "delete",
    value: function _delete() {
      return Promise.resolve();
    }
  }, {
    key: "close",
    value: function close() {}
  }, {
    key: "isPopulated",
    value: function isPopulated() {
      return Promise.resolve(!1);
    }
  }, {
    key: "getEmojiCount",
    value: function getEmojiCount() {
      return Promise.resolve(this.emojis.length);
    }
  }, {
    key: "getEtags",
    value: function getEtags() {
      return Promise.resolve({
        foo: "bar"
      });
    }
  }, {
    key: "getHash",
    value: function getHash() {
      return Promise.resolve("");
    }
  }, {
    key: "populate",
    value: function populate(e) {
      return this.categories = e.groups, this.emojis = e.emojis, Promise.resolve();
    }
  }, {
    key: "getCategories",
    value: function getCategories(e) {
      var o;
      var t = this.categories.filter(function (i) {
        return i.key !== "component";
      });
      if (e.showRecents && t.unshift({
        key: "recents",
        order: -1
      }), (o = e.custom) != null && o.length && t.push({
        key: "custom",
        order: 10
      }), e.categories) {
        var i = e.categories;
        t = t.filter(function (r) {
          return i.includes(r.key);
        }), t.sort(function (r, a) {
          return i.indexOf(r.key) - i.indexOf(a.key);
        });
      } else t.sort(function (i, r) {
        return i.order - r.order;
      });
      return Promise.resolve(t);
    }
  }, {
    key: "getEmojis",
    value: function getEmojis(e, t) {
      var o = this.emojis.filter(function (i) {
        return i.group === e.order;
      }).filter(function (i) {
        return i.version <= t;
      }).sort(function (i, r) {
        return i.order != null && r.order != null ? i.order - r.order : 0;
      }).map(x);
      return Promise.resolve(N(o, t));
    }
  }, {
    key: "searchEmojis",
    value: function searchEmojis(e, t, o, i) {
      var r = this.emojis.filter(function (l) {
          return B(l, e, i) && l.version <= o;
        }).map(x),
        a = t.filter(function (l) {
          return B(l, e, i);
        }),
        n = [].concat(_toConsumableArray(N(r, o)), _toConsumableArray(a));
      return Promise.resolve(n);
    }
  }, {
    key: "setMeta",
    value: function setMeta(e) {
      this.meta = e;
    }
  }]);
  return Je;
}(Ee);
function Ze(s, e) {
  var t = "https://cdn.jsdelivr.net/npm/emojibase-data@".concat(s, "/").concat(e);
  return {
    emojisUrl: "".concat(t, "/data.json"),
    messagesUrl: "".concat(t, "/messages.json")
  };
}
function pe(_x9) {
  return _pe.apply(this, arguments);
}
function _pe() {
  _pe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee40(s) {
    return _regeneratorRuntime().wrap(function _callee40$(_context40) {
      while (1) switch (_context40.prev = _context40.next) {
        case 0:
          _context40.prev = 0;
          _context40.next = 3;
          return fetch(s, {
            method: "HEAD"
          });
        case 3:
          return _context40.abrupt("return", _context40.sent.headers.get("etag"));
        case 6:
          _context40.prev = 6;
          _context40.t0 = _context40["catch"](0);
          return _context40.abrupt("return", null);
        case 9:
        case "end":
          return _context40.stop();
      }
    }, _callee40, null, [[0, 6]]);
  }));
  return _pe.apply(this, arguments);
}
function Ye(s) {
  var _Ze = Ze("latest", s),
    e = _Ze.emojisUrl,
    t = _Ze.messagesUrl;
  try {
    return Promise.all([pe(e), pe(t)]);
  } catch (_unused2) {
    return Promise.all([null, null]);
  }
}
function Qe(_x10, _x11, _x12) {
  return _Qe.apply(this, arguments);
}
function _Qe() {
  _Qe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee41(s, e, t) {
    var o, _o, i, r, _yield$Promise$all3, _yield$Promise$all4, a, n;
    return _regeneratorRuntime().wrap(function _callee41$(_context41) {
      while (1) switch (_context41.prev = _context41.next) {
        case 0:
          _context41.prev = 0;
          _context41.next = 3;
          return s.getEtags();
        case 3:
          o = _context41.sent;
          _context41.next = 9;
          break;
        case 6:
          _context41.prev = 6;
          _context41.t0 = _context41["catch"](0);
          o = {};
        case 9:
          _o = o, i = _o.storedEmojisEtag, r = _o.storedMessagesEtag;
          if (!(t !== r || e !== i)) {
            _context41.next = 19;
            break;
          }
          _context41.next = 13;
          return Promise.all([je(s.locale), Ce(s.locale)]);
        case 13:
          _yield$Promise$all3 = _context41.sent;
          _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);
          a = _yield$Promise$all4[0];
          n = _yield$Promise$all4[1];
          _context41.next = 19;
          return s.populate({
            groups: a.groups,
            emojis: n,
            emojisEtag: e,
            messagesEtag: t
          });
        case 19:
        case "end":
          return _context41.stop();
      }
    }, _callee41, null, [[0, 6]]);
  }));
  return _Qe.apply(this, arguments);
}
function Xe(_x13, _x14) {
  return _Xe.apply(this, arguments);
}
function _Xe() {
  _Xe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee42(s, e) {
    var t;
    return _regeneratorRuntime().wrap(function _callee42$(_context42) {
      while (1) switch (_context42.prev = _context42.next) {
        case 0:
          _context42.next = 2;
          return s.getHash();
        case 2:
          t = _context42.sent;
          return _context42.abrupt("return", e !== t);
        case 4:
        case "end":
          return _context42.stop();
      }
    }, _callee42);
  }));
  return _Xe.apply(this, arguments);
}
function Fe(_x15, _x16, _x17) {
  return _Fe.apply(this, arguments);
}
function _Fe() {
  _Fe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee43(s, e, t) {
    var o;
    return _regeneratorRuntime().wrap(function _callee43$(_context43) {
      while (1) switch (_context43.prev = _context43.next) {
        case 0:
          o = t || e(s);
          _context43.prev = 1;
          _context43.next = 4;
          return o.open();
        case 4:
          _context43.next = 9;
          break;
        case 6:
          _context43.prev = 6;
          _context43.t0 = _context43["catch"](1);
          console.warn("[picmo] IndexedDB not available, falling back to InMemoryStoreFactory"), o = Se(s);
        case 9:
          return _context43.abrupt("return", o);
        case 10:
        case "end":
          return _context43.stop();
      }
    }, _callee43, null, [[1, 6]]);
  }));
  return _Fe.apply(this, arguments);
}
function et(_x18, _x19, _x20) {
  return _et.apply(this, arguments);
}
function _et() {
  _et = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee44(s, e, t) {
    var o, _yield$Ye, _yield$Ye2, i, r, _yield$Promise$all5, _yield$Promise$all6, a, n;
    return _regeneratorRuntime().wrap(function _callee44$(_context44) {
      while (1) switch (_context44.prev = _context44.next) {
        case 0:
          if (!(!xe() && (typeof window === "undefined" ? "undefined" : _typeof(window)) < "u")) {
            _context44.next = 2;
            break;
          }
          throw new Error("Session storage is required to use CDN emoji data.");
        case 2:
          _context44.next = 4;
          return Fe(s, e, t);
        case 4:
          o = _context44.sent;
          _context44.next = 7;
          return Ye(s);
        case 7:
          _yield$Ye = _context44.sent;
          _yield$Ye2 = _slicedToArray(_yield$Ye, 2);
          i = _yield$Ye2[0];
          r = _yield$Ye2[1];
          _context44.next = 13;
          return o.isPopulated();
        case 13:
          if (!_context44.sent) {
            _context44.next = 20;
            break;
          }
          _context44.t0 = i && r;
          if (!_context44.t0) {
            _context44.next = 18;
            break;
          }
          _context44.next = 18;
          return Qe(o, i, r);
        case 18:
          _context44.next = 28;
          break;
        case 20:
          _context44.next = 22;
          return Promise.all([je(s), Ce(s)]);
        case 22:
          _yield$Promise$all5 = _context44.sent;
          _yield$Promise$all6 = _slicedToArray(_yield$Promise$all5, 2);
          a = _yield$Promise$all6[0];
          n = _yield$Promise$all6[1];
          _context44.next = 28;
          return o.populate({
            groups: a.groups,
            emojis: n,
            emojisEtag: i,
            messagesEtag: r
          });
        case 28:
          return _context44.abrupt("return", o);
        case 29:
        case "end":
          return _context44.stop();
      }
    }, _callee44);
  }));
  return _et.apply(this, arguments);
}
function tt(_x21, _x22, _x23, _x24, _x25) {
  return _tt.apply(this, arguments);
}
function _tt() {
  _tt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee45(s, e, t, o, i) {
    var r, a;
    return _regeneratorRuntime().wrap(function _callee45$(_context45) {
      while (1) switch (_context45.prev = _context45.next) {
        case 0:
          _context45.next = 2;
          return Fe(s, e, i);
        case 2:
          r = _context45.sent;
          _context45.next = 5;
          return Ue(o);
        case 5:
          a = _context45.sent;
          _context45.next = 8;
          return r.isPopulated();
        case 8:
          _context45.t0 = !_context45.sent;
          if (_context45.t0) {
            _context45.next = 13;
            break;
          }
          _context45.next = 12;
          return Xe(r, a);
        case 12:
          _context45.t0 = _context45.sent;
        case 13:
          _context45.t1 = _context45.t0;
          if (!_context45.t1) {
            _context45.next = 17;
            break;
          }
          _context45.next = 17;
          return r.populate({
            groups: t.groups,
            emojis: o,
            hash: a
          });
        case 17:
          return _context45.abrupt("return", r);
        case 18:
        case "end":
          return _context45.stop();
      }
    }, _callee45);
  }));
  return _tt.apply(this, arguments);
}
function ce(_x26, _x27, _x28, _x29, _x30) {
  return _ce.apply(this, arguments);
}
function _ce() {
  _ce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee46(s, e, t, o, i) {
    return _regeneratorRuntime().wrap(function _callee46$(_context46) {
      while (1) switch (_context46.prev = _context46.next) {
        case 0:
          return _context46.abrupt("return", t && o ? tt(s, e, t, o, i) : et(s, e, i));
        case 1:
        case "end":
          return _context46.stop();
      }
    }, _callee46);
  }));
  return _ce.apply(this, arguments);
}
function Bs(s, e) {
  s.deleteDatabase(e);
}
var st = /*#__PURE__*/function () {
  function st() {
    _classCallCheck(this, st);
    this.handleKeyDown = this.handleKeyDown.bind(this);
  }
  _createClass(st, [{
    key: "activate",
    value: function activate(e) {
      this.rootElement = e, this.rootElement.addEventListener("keydown", this.handleKeyDown);
    }
  }, {
    key: "deactivate",
    value: function deactivate() {
      var e;
      (e = this.rootElement) == null || e.removeEventListener("keydown", this.handleKeyDown);
    }
  }, {
    key: "focusableElements",
    get: function get() {
      return this.rootElement.querySelectorAll('input, [tabindex="0"]');
    }
  }, {
    key: "lastFocusableElement",
    get: function get() {
      return this.focusableElements[this.focusableElements.length - 1];
    }
  }, {
    key: "firstFocusableElement",
    get: function get() {
      return this.focusableElements[0];
    }
  }, {
    key: "checkFocus",
    value: function checkFocus(e, t, o) {
      e.target === t && (o.focus(), e.preventDefault());
    }
  }, {
    key: "handleKeyDown",
    value: function handleKeyDown(e) {
      e.key === "Tab" && this.checkFocus(e, e.shiftKey ? this.firstFocusableElement : this.lastFocusableElement, e.shiftKey ? this.lastFocusableElement : this.firstFocusableElement);
    }
  }]);
  return st;
}();
var _p = p("light", "dark", "auto"),
  ot = _p.light,
  Ns = _p.dark,
  Os = _p.auto;
var c = /*#__PURE__*/function () {
  function c(_ref3) {
    var e = _ref3.template,
      t = _ref3.classes,
      o = _ref3.parent;
    _classCallCheck(this, c);
    this.isDestroyed = !1, this.appEvents = {}, this.uiEvents = [], this.uiElements = {}, this.ui = {}, this.template = e, this.classes = t, this.parent = o, this.keyBindingHandler = this.keyBindingHandler.bind(this);
  }
  _createClass(c, [{
    key: "initialize",
    value: function initialize() {
      this.bindAppEvents();
    }
  }, {
    key: "setCustomEmojis",
    value: function setCustomEmojis(e) {
      this.customEmojis = e;
    }
  }, {
    key: "setEvents",
    value: function setEvents(e) {
      this.events = e;
    }
  }, {
    key: "setPickerId",
    value: function setPickerId(e) {
      this.pickerId = e;
    }
  }, {
    key: "emit",
    value: function emit(e) {
      var _this$events;
      for (var _len4 = arguments.length, t = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        t[_key4 - 1] = arguments[_key4];
      }
      (_this$events = this.events).emit.apply(_this$events, [e].concat(t));
    }
  }, {
    key: "setI18n",
    value: function setI18n(e) {
      this.i18n = e;
    }
  }, {
    key: "setRenderer",
    value: function setRenderer(e) {
      this.renderer = e;
    }
  }, {
    key: "setEmojiData",
    value: function setEmojiData(e) {
      var _this = this;
      this.emojiDataPromise = e, e.then(function (t) {
        _this.emojiData = t;
      });
    }
  }, {
    key: "updateEmojiData",
    value: function updateEmojiData(e) {
      this.emojiData = e, this.emojiDataPromise = Promise.resolve(e);
    }
  }, {
    key: "setOptions",
    value: function setOptions(e) {
      this.options = e;
    }
  }, {
    key: "renderSync",
    value: function renderSync() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return this.el = this.template.renderSync(_objectSpread({
        classes: this.classes,
        i18n: this.i18n,
        pickerId: this.pickerId
      }, e)), this.postRender(), this.el;
    }
  }, {
    key: "render",
    value: function () {
      var _render = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var e,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              e = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
              _context.next = 3;
              return this.emojiDataPromise;
            case 3:
              _context.next = 5;
              return this.template.renderAsync(_objectSpread({
                classes: this.classes,
                i18n: this.i18n,
                pickerId: this.pickerId
              }, e));
            case 5:
              this.el = _context.sent;
              this.postRender();
              return _context.abrupt("return", this.el);
            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function render() {
        return _render.apply(this, arguments);
      }
      return render;
    }()
  }, {
    key: "postRender",
    value: function postRender() {
      this.bindUIElements(), this.bindKeyBindings(), this.bindUIEvents(), this.scheduleShowAnimation();
    }
  }, {
    key: "bindAppEvents",
    value: function bindAppEvents() {
      var _this2 = this;
      Object.keys(this.appEvents).forEach(function (e) {
        _this2.events.on(e, _this2.appEvents[e], _this2);
      }), this.events.on("data:ready", this.updateEmojiData, this);
    }
  }, {
    key: "unbindAppEvents",
    value: function unbindAppEvents() {
      var _this3 = this;
      Object.keys(this.appEvents).forEach(function (e) {
        _this3.events.off(e, _this3.appEvents[e]);
      }), this.events.off("data:ready", this.updateEmojiData);
    }
  }, {
    key: "keyBindingHandler",
    value: function keyBindingHandler(e) {
      var t = this.keyBindings[e.key];
      t && t.call(this, e);
    }
  }, {
    key: "bindKeyBindings",
    value: function bindKeyBindings() {
      this.keyBindings && this.el.addEventListener("keydown", this.keyBindingHandler);
    }
  }, {
    key: "unbindKeyBindings",
    value: function unbindKeyBindings() {
      this.keyBindings && this.el.removeEventListener("keydown", this.keyBindingHandler);
    }
  }, {
    key: "bindUIElements",
    value: function bindUIElements() {
      var _this4 = this;
      this.ui = Object.keys(this.uiElements).reduce(function (e, t) {
        return _objectSpread(_objectSpread({}, e), {}, _defineProperty({}, t, _this4.el.querySelector(_this4.uiElements[t])));
      }, {});
    }
  }, {
    key: "bindUIEvents",
    value: function bindUIEvents() {
      var _this5 = this;
      this.uiEvents.forEach(function (e) {
        e.handler = e.handler.bind(_this5), (e.target ? _this5.ui[e.target] : _this5.el).addEventListener(e.event, e.handler, e.options);
      });
    }
  }, {
    key: "unbindUIEvents",
    value: function unbindUIEvents() {
      var _this6 = this;
      this.uiEvents.forEach(function (e) {
        (e.target ? _this6.ui[e.target] : _this6.el).removeEventListener(e.event, e.handler);
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.unbindAppEvents(), this.unbindUIEvents(), this.unbindKeyBindings(), this.el.remove(), this.isDestroyed = !0;
    }
  }, {
    key: "scheduleShowAnimation",
    value: function scheduleShowAnimation() {
      var _this7 = this;
      if (this.parent) {
        var e = new MutationObserver(function (t) {
          var _t2 = _slicedToArray(t, 1),
            o = _t2[0];
          o.type === "childList" && o.addedNodes[0] === _this7.el && (_e(_this7.options) && _this7.animateShow && _this7.animateShow(), e.disconnect);
        });
        e.observe(this.parent, {
          childList: !0
        });
      }
    }
  }], [{
    key: "childEvent",
    value: function childEvent(e, t, o) {
      var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      return {
        target: e,
        event: t,
        handler: o,
        options: i
      };
    }
  }, {
    key: "uiEvent",
    value: function uiEvent(e, t) {
      var o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return {
        event: e,
        handler: t,
        options: o
      };
    }
  }, {
    key: "byClass",
    value: function byClass(e) {
      return ".".concat(e);
    }
  }]);
  return c;
}();
var it = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M256 512C114.6 512 0 397.4 0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512zM232 256C232 264 236 271.5 242.7 275.1L338.7 339.1C349.7 347.3 364.6 344.3 371.1 333.3C379.3 322.3 376.3 307.4 365.3 300L280 243.2V120C280 106.7 269.3 96 255.1 96C242.7 96 231.1 106.7 231.1 120L232 256z"/></svg>',
  rt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M64 496C64 504.8 56.75 512 48 512h-32C7.25 512 0 504.8 0 496V32c0-17.75 14.25-32 32-32s32 14.25 32 32V496zM476.3 0c-6.365 0-13.01 1.35-19.34 4.233c-45.69 20.86-79.56 27.94-107.8 27.94c-59.96 0-94.81-31.86-163.9-31.87C160.9 .3055 131.6 4.867 96 15.75v350.5c32-9.984 59.87-14.1 84.85-14.1c73.63 0 124.9 31.78 198.6 31.78c31.91 0 68.02-5.971 111.1-23.09C504.1 355.9 512 344.4 512 332.1V30.73C512 11.1 495.3 0 476.3 0z"/></svg>',
  at = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512C114.6 512 0 397.4 0 256zM176.4 240C194 240 208.4 225.7 208.4 208C208.4 190.3 194 176 176.4 176C158.7 176 144.4 190.3 144.4 208C144.4 225.7 158.7 240 176.4 240zM336.4 176C318.7 176 304.4 190.3 304.4 208C304.4 225.7 318.7 240 336.4 240C354 240 368.4 225.7 368.4 208C368.4 190.3 354 176 336.4 176zM259.9 369.4C288.8 369.4 316.2 375.2 340.6 385.5C352.9 390.7 366.7 381.3 361.4 369.1C344.8 330.9 305.6 303.1 259.9 303.1C214.3 303.1 175.1 330.8 158.4 369.1C153.1 381.3 166.1 390.6 179.3 385.4C203.7 375.1 231 369.4 259.9 369.4L259.9 369.4z"/></svg>',
  nt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M448 64H192C85.96 64 0 149.1 0 256s85.96 192 192 192h256c106 0 192-85.96 192-192S554 64 448 64zM247.1 280h-32v32c0 13.2-10.78 24-23.98 24c-13.2 0-24.02-10.8-24.02-24v-32L136 279.1C122.8 279.1 111.1 269.2 111.1 256c0-13.2 10.85-24.01 24.05-24.01L167.1 232v-32c0-13.2 10.82-24 24.02-24c13.2 0 23.98 10.8 23.98 24v32h32c13.2 0 24.02 10.8 24.02 24C271.1 269.2 261.2 280 247.1 280zM431.1 344c-22.12 0-39.1-17.87-39.1-39.1s17.87-40 39.1-40s39.1 17.88 39.1 40S454.1 344 431.1 344zM495.1 248c-22.12 0-39.1-17.87-39.1-39.1s17.87-40 39.1-40c22.12 0 39.1 17.88 39.1 40S518.1 248 495.1 248z"/></svg>',
  ct = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M112.1 454.3c0 6.297 1.816 12.44 5.284 17.69l17.14 25.69c5.25 7.875 17.17 14.28 26.64 14.28h61.67c9.438 0 21.36-6.401 26.61-14.28l17.08-25.68c2.938-4.438 5.348-12.37 5.348-17.7L272 415.1h-160L112.1 454.3zM191.4 .0132C89.44 .3257 16 82.97 16 175.1c0 44.38 16.44 84.84 43.56 115.8c16.53 18.84 42.34 58.23 52.22 91.45c.0313 .25 .0938 .5166 .125 .7823h160.2c.0313-.2656 .0938-.5166 .125-.7823c9.875-33.22 35.69-72.61 52.22-91.45C351.6 260.8 368 220.4 368 175.1C368 78.61 288.9-.2837 191.4 .0132zM192 96.01c-44.13 0-80 35.89-80 79.1C112 184.8 104.8 192 96 192S80 184.8 80 176c0-61.76 50.25-111.1 112-111.1c8.844 0 16 7.159 16 16S200.8 96.01 192 96.01z"/></svg>',
  lt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M512 32H120c-13.25 0-24 10.75-24 24L96.01 288c0 53 43 96 96 96h192C437 384 480 341 480 288h32c70.63 0 128-57.38 128-128S582.6 32 512 32zM512 224h-32V96h32c35.25 0 64 28.75 64 64S547.3 224 512 224zM560 416h-544C7.164 416 0 423.2 0 432C0 458.5 21.49 480 48 480h480c26.51 0 48-21.49 48-48C576 423.2 568.8 416 560 416z"/></svg>',
  ht = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M482.3 192C516.5 192 576 221 576 256C576 292 516.5 320 482.3 320H365.7L265.2 495.9C259.5 505.8 248.9 512 237.4 512H181.2C170.6 512 162.9 501.8 165.8 491.6L214.9 320H112L68.8 377.6C65.78 381.6 61.04 384 56 384H14.03C6.284 384 0 377.7 0 369.1C0 368.7 .1818 367.4 .5398 366.1L32 256L.5398 145.9C.1818 144.6 0 143.3 0 142C0 134.3 6.284 128 14.03 128H56C61.04 128 65.78 130.4 68.8 134.4L112 192H214.9L165.8 20.4C162.9 10.17 170.6 0 181.2 0H237.4C248.9 0 259.5 6.153 265.2 16.12L365.7 192H482.3z"/></svg>',
  dt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M9.375 233.4C3.375 239.4 0 247.5 0 256v128c0 8.5 3.375 16.62 9.375 22.62S23.5 416 32 416h32V224H32C23.5 224 15.38 227.4 9.375 233.4zM464 96H352V32c0-17.62-14.38-32-32-32S288 14.38 288 32v64H176C131.8 96 96 131.8 96 176V448c0 35.38 28.62 64 64 64h320c35.38 0 64-28.62 64-64V176C544 131.8 508.3 96 464 96zM256 416H192v-32h64V416zM224 296C201.9 296 184 278.1 184 256S201.9 216 224 216S264 233.9 264 256S246.1 296 224 296zM352 416H288v-32h64V416zM448 416h-64v-32h64V416zM416 296c-22.12 0-40-17.88-40-40S393.9 216 416 216S456 233.9 456 256S438.1 296 416 296zM630.6 233.4C624.6 227.4 616.5 224 608 224h-32v192h32c8.5 0 16.62-3.375 22.62-9.375S640 392.5 640 384V256C640 247.5 636.6 239.4 630.6 233.4z"/></svg>',
  mt = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n  <defs>\n    <radialGradient gradientUnits=\"userSpaceOnUse\" cy=\"10%\" id=\"gradient-0\">\n      <stop offset=\"0\" stop-color=\"hsl(50, 100%, 50%)\" />\n      <stop offset=\"1\" stop-color=\"hsl(50, 100%, 60%)\" />\n    </radialGradient>\n  </defs>\n  <!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->\n  <ellipse stroke=\"#000\" fill=\"rgba(0, 0, 0, 0.6)\" cx=\"172.586\" cy=\"207.006\" rx=\"39.974\" ry=\"39.974\"/>\n  <ellipse stroke=\"#000\" fill=\"rgba(0, 0, 0, 0.6)\" cx=\"334.523\" cy=\"207.481\" rx=\"39.974\" ry=\"39.974\"/>\n  <ellipse stroke=\"#000\" fill=\"rgba(0, 0, 0, 0.6)\" cx=\"313.325\" cy=\"356.208\" rx=\"91.497\" ry=\"59.893\"/>\n  <path fill=\"#55a7ff\" d=\"M 159.427 274.06 L 102.158 363.286 L 124.366 417.011 L 160.476 423.338 L 196.937 414.736 L 218.502 375.214\"></path>\n  <path fill=\"url(#gradient-0)\" d=\"M256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512C114.6 512 0 397.4 0 256C0 114.6 114.6 0 256 0zM256 352C290.9 352 323.2 367.8 348.3 394.9C354.3 401.4 364.4 401.7 370.9 395.7C377.4 389.7 377.7 379.6 371.7 373.1C341.6 340.5 301 320 256 320C247.2 320 240 327.2 240 336C240 344.8 247.2 352 256 352H256zM208 369C208 349 179.6 308.6 166.4 291.3C163.2 286.9 156.8 286.9 153.6 291.3C140.6 308.6 112 349 112 369C112 395 133.5 416 160 416C186.5 416 208 395 208 369H208zM303.6 208C303.6 225.7 317.1 240 335.6 240C353.3 240 367.6 225.7 367.6 208C367.6 190.3 353.3 176 335.6 176C317.1 176 303.6 190.3 303.6 208zM207.6 208C207.6 190.3 193.3 176 175.6 176C157.1 176 143.6 190.3 143.6 208C143.6 225.7 157.1 240 175.6 240C193.3 240 207.6 225.7 207.6 208z\" />\n</svg>",
  ut = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M500.3 443.7l-119.7-119.7c27.22-40.41 40.65-90.9 33.46-144.7C401.8 87.79 326.8 13.32 235.2 1.723C99.01-15.51-15.51 99.01 1.724 235.2c11.6 91.64 86.08 166.7 177.6 178.9c53.8 7.189 104.3-6.236 144.7-33.46l119.7 119.7c15.62 15.62 40.95 15.62 56.57 0C515.9 484.7 515.9 459.3 500.3 443.7zM79.1 208c0-70.58 57.42-128 128-128s128 57.42 128 128c0 70.58-57.42 128-128 128S79.1 278.6 79.1 208z"/></svg>',
  pt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M0 256C0 114.6 114.6 0 256 0C397.4 0 512 114.6 512 256C512 397.4 397.4 512 256 512C114.6 512 0 397.4 0 256zM256.3 331.8C208.9 331.8 164.1 324.9 124.5 312.8C112.2 309 100.2 319.7 105.2 331.5C130.1 390.6 188.4 432 256.3 432C324.2 432 382.4 390.6 407.4 331.5C412.4 319.7 400.4 309 388.1 312.8C348.4 324.9 303.7 331.8 256.3 331.8H256.3zM176.4 176C158.7 176 144.4 190.3 144.4 208C144.4 225.7 158.7 240 176.4 240C194 240 208.4 225.7 208.4 208C208.4 190.3 194 176 176.4 176zM336.4 240C354 240 368.4 225.7 368.4 208C368.4 190.3 354 176 336.4 176C318.7 176 304.4 190.3 304.4 208C304.4 225.7 318.7 240 336.4 240z"/></svg>',
  gt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M500.3 7.251C507.7 13.33 512 22.41 512 31.1V175.1C512 202.5 483.3 223.1 447.1 223.1C412.7 223.1 383.1 202.5 383.1 175.1C383.1 149.5 412.7 127.1 447.1 127.1V71.03L351.1 90.23V207.1C351.1 234.5 323.3 255.1 287.1 255.1C252.7 255.1 223.1 234.5 223.1 207.1C223.1 181.5 252.7 159.1 287.1 159.1V63.1C287.1 48.74 298.8 35.61 313.7 32.62L473.7 .6198C483.1-1.261 492.9 1.173 500.3 7.251H500.3zM74.66 303.1L86.5 286.2C92.43 277.3 102.4 271.1 113.1 271.1H174.9C185.6 271.1 195.6 277.3 201.5 286.2L213.3 303.1H239.1C266.5 303.1 287.1 325.5 287.1 351.1V463.1C287.1 490.5 266.5 511.1 239.1 511.1H47.1C21.49 511.1-.0019 490.5-.0019 463.1V351.1C-.0019 325.5 21.49 303.1 47.1 303.1H74.66zM143.1 359.1C117.5 359.1 95.1 381.5 95.1 407.1C95.1 434.5 117.5 455.1 143.1 455.1C170.5 455.1 191.1 434.5 191.1 407.1C191.1 381.5 170.5 359.1 143.1 359.1zM440.3 367.1H496C502.7 367.1 508.6 372.1 510.1 378.4C513.3 384.6 511.6 391.7 506.5 396L378.5 508C372.9 512.1 364.6 513.3 358.6 508.9C352.6 504.6 350.3 496.6 353.3 489.7L391.7 399.1H336C329.3 399.1 323.4 395.9 321 389.6C318.7 383.4 320.4 376.3 325.5 371.1L453.5 259.1C459.1 255 467.4 254.7 473.4 259.1C479.4 263.4 481.6 271.4 478.7 278.3L440.3 367.1zM116.7 219.1L19.85 119.2C-8.112 90.26-6.614 42.31 24.85 15.34C51.82-8.137 93.26-3.642 118.2 21.83L128.2 32.32L137.7 21.83C162.7-3.642 203.6-8.137 231.6 15.34C262.6 42.31 264.1 90.26 236.1 119.2L139.7 219.1C133.2 225.6 122.7 225.6 116.7 219.1H116.7z"/></svg>',
  yt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M413.8 447.1L256 448l0 31.99C256 497.7 241.8 512 224.1 512c-17.67 0-32.1-14.32-32.1-31.99l0-31.99l-158.9-.0099c-28.5 0-43.69-34.49-24.69-56.4l68.98-79.59H62.22c-25.41 0-39.15-29.8-22.67-49.13l60.41-70.85H89.21c-21.28 0-32.87-22.5-19.28-37.31l134.8-146.5c10.4-11.3 28.22-11.3 38.62-.0033l134.9 146.5c13.62 14.81 2.001 37.31-19.28 37.31h-10.77l60.35 70.86c16.46 19.34 2.716 49.12-22.68 49.12h-15.2l68.98 79.59C458.7 413.7 443.1 447.1 413.8 447.1z"/></svg>',
  ft = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M224 256c70.7 0 128-57.31 128-128S294.7 0 224 0C153.3 0 96 57.31 96 128S153.3 256 224 256zM274.7 304H173.3c-95.73 0-173.3 77.6-173.3 173.3C0 496.5 15.52 512 34.66 512H413.3C432.5 512 448 496.5 448 477.3C448 381.6 370.4 304 274.7 304zM479.1 320h-73.85C451.2 357.7 480 414.1 480 477.3C480 490.1 476.2 501.9 470 512h138C625.7 512 640 497.6 640 479.1C640 391.6 568.4 320 479.1 320zM432 256C493.9 256 544 205.9 544 144S493.9 32 432 32c-25.11 0-48.04 8.555-66.72 22.51C376.8 76.63 384 101.4 384 128c0 35.52-11.93 68.14-31.59 94.71C372.7 243.2 400.8 256 432 256z"/></svg>',
  vt = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\">\n  <defs>\n    <radialGradient id=\"radial\" cy=\"85%\">\n      <stop offset=\"20%\" stop-color=\"var(--color-secondary)\" />\n      <stop offset=\"100%\" stop-color=\"var(--color-primary)\" />\n    </radialGradient>\n  </defs>\n  <!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. -->\n  <path fill=\"url('#radial')\" d=\"M506.3 417l-213.3-364c-16.33-28-57.54-28-73.98 0l-213.2 364C-10.59 444.9 9.849 480 42.74 480h426.6C502.1 480 522.6 445 506.3 417zM232 168c0-13.25 10.75-24 24-24S280 154.8 280 168v128c0 13.25-10.75 24-23.1 24S232 309.3 232 296V168zM256 416c-17.36 0-31.44-14.08-31.44-31.44c0-17.36 14.07-31.44 31.44-31.44s31.44 14.08 31.44 31.44C287.4 401.9 273.4 416 256 416z\" />\n</svg>",
  wt = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Pro 6.1.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2022 Fonticons, Inc. --><path d="M310.6 361.4c12.5 12.5 12.5 32.75 0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3L54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75 0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75 0-45.25s32.75-12.5 45.25 0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25 0s12.5 32.75 0 45.25l-105.4 105.4L310.6 361.4z"/></svg>';
function bt(s, e) {
  var t = Q(e);
  return t.dataset.icon = s, t.classList.add(ne("icon")), t;
}
var ge = {
    clock: it,
    flag: rt,
    frown: at,
    gamepad: nt,
    lightbulb: ct,
    mug: lt,
    plane: ht,
    robot: dt,
    sad: mt,
    search: ut,
    smiley: pt,
    symbols: gt,
    tree: yt,
    users: ft,
    warning: vt,
    xmark: wt
  },
  O = {
    recents: "clock",
    "smileys-emotion": "smiley",
    "people-body": "users",
    "animals-nature": "tree",
    "food-drink": "mug",
    activities: "gamepad",
    "travel-places": "plane",
    objects: "lightbulb",
    symbols: "symbols",
    flags: "flag",
    custom: "robot"
  };
function Pe(s, e) {
  if (!(s in ge)) return console.warn("Unknown icon: \"".concat(s, "\"")), document.createElement("div");
  var t = bt(s, ge[s]);
  return e && t.classList.add(ne("icon-".concat(e))), t;
}
var Ct = {
  mode: "sync"
};
var b, E, S, X, F, ee, P, te;
var u = /*#__PURE__*/function () {
  function u(e) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, u);
    f(this, S);
    f(this, F);
    f(this, P);
    f(this, b, void 0);
    f(this, E, void 0);
    A(this, b, e), A(this, E, t.mode || Ct.mode);
  }
  _createClass(u, [{
    key: "renderSync",
    value: function renderSync() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var t = Q(y(this, b).call(this, e));
      return g(this, P, te).call(this, t, e), g(this, F, ee).call(this, t), g(this, S, X).call(this, t, e), t;
    }
  }, {
    key: "renderAsync",
    value: function () {
      var _renderAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var e,
          t,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              e = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
              t = Q(y(this, b).call(this, e));
              g(this, P, te).call(this, t, e);
              g(this, F, ee).call(this, t);
              _context2.next = 6;
              return g(this, S, X).call(this, t, e);
            case 6:
              return _context2.abrupt("return", t);
            case 7:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function renderAsync() {
        return _renderAsync.apply(this, arguments);
      }
      return renderAsync;
    }()
  }, {
    key: "render",
    value: function render(e) {
      return y(this, E) === "sync" ? this.renderSync(e) : this.renderAsync(e);
    }
  }]);
  return u;
}();
b = new WeakMap(), E = new WeakMap(), S = new WeakSet(), X = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(e, t) {
    var o, i, _iterator, _step, _loop;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          o = e.querySelectorAll("[data-view]"), i = [];
          _iterator = _createForOfIteratorHelper(o);
          _context4.prev = 2;
          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
            var r, a;
            return _regeneratorRuntime().wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  r = _step.value;
                  a = t[r.dataset.view];
                  a ? r.dataset.render !== "sync" ? i.push(a.render().then(function (n) {
                    return r.replaceWith(n), n;
                  })) : r.replaceWith(a.renderSync()) : r.remove();
                case 3:
                case "end":
                  return _context3.stop();
              }
            }, _callee3);
          });
          _iterator.s();
        case 5:
          if ((_step = _iterator.n()).done) {
            _context4.next = 9;
            break;
          }
          return _context4.delegateYield(_loop(), "t0", 7);
        case 7:
          _context4.next = 5;
          break;
        case 9:
          _context4.next = 14;
          break;
        case 11:
          _context4.prev = 11;
          _context4.t1 = _context4["catch"](2);
          _iterator.e(_context4.t1);
        case 14:
          _context4.prev = 14;
          _iterator.f();
          return _context4.finish(14);
        case 17:
          return _context4.abrupt("return", Promise.all(i));
        case 18:
        case "end":
          return _context4.stop();
      }
    }, _callee4, null, [[2, 11, 14, 17]]);
  }));
  return function X(_x31, _x32) {
    return _ref4.apply(this, arguments);
  };
}(), F = new WeakSet(), ee = function ee(e) {
  e.querySelectorAll("i[data-icon]").forEach(function (o) {
    var _o$dataset = o.dataset,
      i = _o$dataset.icon,
      r = _o$dataset.size;
    o.replaceWith(Pe(i, r));
  });
}, P = new WeakSet(), te = function te(e, t) {
  return e.querySelectorAll("[data-placeholder]").forEach(function (i) {
    var r = i.dataset.placeholder;
    if (r && t[r]) {
      var a = t[r];
      i.replaceWith.apply(i, _toConsumableArray([a].flat()));
    } else console.warn("Missing placeholder element for key \"".concat(r, "\""));
  }), e;
};
var jt = p("imagePlaceholder", "placeholder"),
  _t = new u(function (_ref5) {
    var s = _ref5.classes;
    return "\n  <div class=\"".concat(s.placeholder, " ").concat(s.imagePlaceholder, "\"></div>\n");
  });
var kt = /*#__PURE__*/function (_c) {
  _inherits(kt, _c);
  function kt() {
    var _this8;
    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      e = _ref6.classNames;
    _classCallCheck(this, kt);
    _this8 = _callSuper(this, kt, [{
      template: _t,
      classes: jt
    }]), _this8.classNames = e;
    return _this8;
  }
  _createClass(kt, [{
    key: "load",
    value: function load(e) {
      var _this9 = this;
      var t = document.createElement("img");
      this.classNames && (t.className = this.classNames), t.addEventListener("load", function () {
        _this9.el.replaceWith(t);
      }, {
        once: !0
      }), Promise.resolve(e).then(function (o) {
        return t.src = o;
      });
    }
  }, {
    key: "renderSync",
    value: function renderSync() {
      var _this10 = this;
      return _get(_getPrototypeOf(kt.prototype), "renderSync", this).call(this), this.classNames && this.classNames.split(" ").forEach(function (t) {
        return _this10.el.classList.add(t);
      }), this.el;
    }
  }]);
  return kt;
}(c);
var xt = p("customEmoji");
var Et = /*#__PURE__*/function () {
  function Et() {
    _classCallCheck(this, Et);
  }
  _createClass(Et, [{
    key: "renderElement",
    value: function renderElement(e) {
      return {
        content: e
      };
    }
  }, {
    key: "renderImage",
    value: function renderImage() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      var t = arguments.length > 1 ? arguments[1] : undefined;
      var o = new kt({
        classNames: e
      });
      return o.renderSync(), {
        content: o,
        resolver: function resolver() {
          return o.load(t()), o.el;
        }
      };
    }
  }, {
    key: "doRender",
    value: function doRender(e, t, o) {
      if (e.custom) return this.renderCustom(e, t, o);
      var _this$render = this.render(e, o),
        i = _this$render.content,
        r = _this$render.resolver,
        a = i instanceof Element ? i : i.el;
      return r && r(), a;
    }
  }, {
    key: "doEmit",
    value: function doEmit(e) {
      return e.custom ? this.emitCustom(e) : this.emit(e);
    }
  }, {
    key: "emitCustom",
    value: function emitCustom(_ref7) {
      var e = _ref7.url,
        t = _ref7.label,
        o = _ref7.emoji,
        i = _ref7.data;
      return {
        url: e,
        label: t,
        emoji: o,
        data: i
      };
    }
  }, {
    key: "renderCustom",
    value: function renderCustom(e, t) {
      var o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "";
      var i = [xt.customEmoji, o].join(" ").trim(),
        _this$renderImage = this.renderImage(i, function () {
          return e.url;
        }),
        r = _this$renderImage.content,
        a = _this$renderImage.resolver,
        n = r instanceof Element ? r : r.el;
      return a && a(), n;
    }
  }]);
  return Et;
}();
var St = new u(function (_ref8) {
  var s = _ref8.emoji;
  return "<span>".concat(s, "</span>");
});
var Ft = /*#__PURE__*/function (_Et) {
  _inherits(Ft, _Et);
  function Ft() {
    _classCallCheck(this, Ft);
    return _callSuper(this, Ft, arguments);
  }
  _createClass(Ft, [{
    key: "render",
    value: function render(e) {
      return this.renderElement(St.renderSync({
        emoji: e.emoji
      }));
    }
  }, {
    key: "emit",
    value: function emit(_ref9) {
      var e = _ref9.emoji,
        t = _ref9.hexcode,
        o = _ref9.label;
      return {
        emoji: e,
        hexcode: t,
        label: o
      };
    }
  }]);
  return Ft;
}(Et);
var ze = {
    "categories.activities": "Activities",
    "categories.animals-nature": "Animals & Nature",
    "categories.custom": "Custom",
    "categories.flags": "Flags",
    "categories.food-drink": "Food & Drink",
    "categories.objects": "Objects",
    "categories.people-body": "People & Body",
    "categories.recents": "Recently Used",
    "categories.smileys-emotion": "Smileys & Emotion",
    "categories.symbols": "Symbols",
    "categories.travel-places": "Travel & Places",
    "error.load": "Failed to load emojis",
    "recents.clear": "Clear recent emojis",
    "recents.none": "You haven't selected any emojis yet.",
    retry: "Try again",
    "search.clear": "Clear search",
    "search.error": "Failed to search emojis",
    "search.notFound": "No results found",
    search: "Search emojis..."
  },
  se = "PicMo";
function Le(s) {
  return new Pt(s);
}
Le.deleteDatabase = function (s) {
  return new Promise(function (e, t) {
    var o = indexedDB.deleteDatabase("".concat(se, "-").concat(s));
    o.addEventListener("success", e), o.addEventListener("error", t);
  });
};
var Pt = /*#__PURE__*/function (_Ee2) {
  _inherits(Pt, _Ee2);
  function Pt() {
    _classCallCheck(this, Pt);
    return _callSuper(this, Pt, arguments);
  }
  _createClass(Pt, [{
    key: "open",
    value: function () {
      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var _this11 = this;
        var e;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              e = indexedDB.open("".concat(se, "-").concat(this.locale));
              return _context6.abrupt("return", new Promise(function (t, o) {
                e.addEventListener("success", function (i) {
                  var r;
                  _this11.db = (r = i.target) == null ? void 0 : r.result, t();
                }), e.addEventListener("error", o), e.addEventListener("upgradeneeded", /*#__PURE__*/function () {
                  var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(i) {
                    var a, r;
                    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                      while (1) switch (_context5.prev = _context5.next) {
                        case 0:
                          _this11.db = (a = i.target) == null ? void 0 : a.result, _this11.db.createObjectStore("category", {
                            keyPath: "order"
                          });
                          r = _this11.db.createObjectStore("emoji", {
                            keyPath: "emoji"
                          });
                          r.createIndex("category", "group"), r.createIndex("version", "version"), _this11.db.createObjectStore("meta");
                        case 3:
                        case "end":
                          return _context5.stop();
                      }
                    }, _callee5);
                  }));
                  return function (_x33) {
                    return _ref10.apply(this, arguments);
                  };
                }());
              }));
            case 2:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function open() {
        return _open.apply(this, arguments);
      }
      return open;
    }()
  }, {
    key: "delete",
    value: function () {
      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        var e;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              this.close();
              e = indexedDB.deleteDatabase("".concat(se, "-").concat(this.locale));
              _context7.next = 4;
              return this.waitForRequest(e);
            case 4:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function _delete() {
        return _delete2.apply(this, arguments);
      }
      return _delete;
    }()
  }, {
    key: "close",
    value: function close() {
      this.db.close();
    }
  }, {
    key: "getEmojiCount",
    value: function () {
      var _getEmojiCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        var t;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              t = this.db.transaction("emoji", "readonly").objectStore("emoji");
              _context8.next = 3;
              return this.waitForRequest(t.count());
            case 3:
              return _context8.abrupt("return", _context8.sent.target.result);
            case 4:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function getEmojiCount() {
        return _getEmojiCount.apply(this, arguments);
      }
      return getEmojiCount;
    }()
  }, {
    key: "getEtags",
    value: function () {
      var _getEtags = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        var t, _yield$Promise$all, _yield$Promise$all2, o, i;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              t = this.db.transaction("meta", "readonly").objectStore("meta");
              _context9.next = 3;
              return Promise.all([this.waitForRequest(t.get("emojisEtag")), this.waitForRequest(t.get("messagesEtag"))]);
            case 3:
              _yield$Promise$all = _context9.sent;
              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
              o = _yield$Promise$all2[0];
              i = _yield$Promise$all2[1];
              return _context9.abrupt("return", {
                storedEmojisEtag: o.target.result,
                storedMessagesEtag: i.target.result
              });
            case 8:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function getEtags() {
        return _getEtags.apply(this, arguments);
      }
      return getEtags;
    }()
  }, {
    key: "setMeta",
    value: function () {
      var _setMeta = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(e) {
        var t, o;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              t = this.db.transaction("meta", "readwrite"), o = t.objectStore("meta");
              return _context10.abrupt("return", new Promise(function (i) {
                t.oncomplete = i, Object.keys(e).filter(Boolean).forEach(function (a) {
                  o.put(e[a], a);
                });
              }));
            case 2:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function setMeta(_x34) {
        return _setMeta.apply(this, arguments);
      }
      return setMeta;
    }()
  }, {
    key: "getHash",
    value: function () {
      var _getHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        var t;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              t = this.db.transaction("meta", "readonly").objectStore("meta");
              _context11.next = 3;
              return this.waitForRequest(t.get("hash"));
            case 3:
              return _context11.abrupt("return", _context11.sent.target.result);
            case 4:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function getHash() {
        return _getHash.apply(this, arguments);
      }
      return getHash;
    }()
  }, {
    key: "isPopulated",
    value: function () {
      var _isPopulated = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
        var t;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              t = this.db.transaction("category", "readonly").objectStore("category");
              _context12.next = 3;
              return this.waitForRequest(t.count());
            case 3:
              _context12.t0 = _context12.sent.target.result;
              return _context12.abrupt("return", _context12.t0 > 0);
            case 5:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function isPopulated() {
        return _isPopulated.apply(this, arguments);
      }
      return isPopulated;
    }()
  }, {
    key: "populate",
    value: function () {
      var _populate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(_ref11) {
        var e, t, o, i, r, a;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              e = _ref11.groups, t = _ref11.emojis, o = _ref11.emojisEtag, i = _ref11.messagesEtag, r = _ref11.hash;
              _context13.next = 3;
              return this.removeAllObjects("category", "emoji");
            case 3:
              a = [this.addObjects("category", e), this.addObjects("emoji", t), this.setMeta({
                emojisEtag: o,
                messagesEtag: i,
                hash: r
              })];
              _context13.next = 6;
              return Promise.all(a);
            case 6:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function populate(_x35) {
        return _populate.apply(this, arguments);
      }
      return populate;
    }()
  }, {
    key: "getCategories",
    value: function () {
      var _getCategories = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(e) {
        var a, o, r, n;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              o = this.db.transaction("category", "readonly").objectStore("category");
              _context14.next = 3;
              return this.waitForRequest(o.getAll());
            case 3:
              r = _context14.sent.target.result.filter(function (n) {
                return n.key !== "component";
              });
              if (e.showRecents && r.unshift({
                key: "recents",
                order: -1
              }), (a = e.custom) != null && a.length && r.push({
                key: "custom",
                order: 10
              }), e.categories) {
                n = e.categories;
                r = r.filter(function (l) {
                  return n.includes(l.key);
                }), r.sort(function (l, m) {
                  return n.indexOf(l.key) - n.indexOf(m.key);
                });
              } else r.sort(function (n, l) {
                return n.order - l.order;
              });
              return _context14.abrupt("return", r);
            case 6:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function getCategories(_x36) {
        return _getCategories.apply(this, arguments);
      }
      return getCategories;
    }()
  }, {
    key: "getEmojis",
    value: function () {
      var _getEmojis = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(e, t) {
        var r, l;
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              r = this.db.transaction("emoji", "readonly").objectStore("emoji").index("category");
              _context15.next = 3;
              return this.waitForRequest(r.getAll(e.order));
            case 3:
              l = _context15.sent.target.result.filter(function (m) {
                return m.version <= t;
              }).sort(function (m, d) {
                return m.order != null && d.order != null ? m.order - d.order : 0;
              }).map(x);
              return _context15.abrupt("return", N(l, t));
            case 5:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));
      function getEmojis(_x37, _x38) {
        return _getEmojis.apply(this, arguments);
      }
      return getEmojis;
    }()
  }, {
    key: "searchEmojis",
    value: function () {
      var _searchEmojis = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(e, t, o, i) {
        var _this12 = this;
        var r;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              r = [];
              return _context16.abrupt("return", new Promise(function (a, n) {
                var d = _this12.db.transaction("emoji", "readonly").objectStore("emoji").openCursor();
                d.addEventListener("success", function (h) {
                  var de;
                  var H = (de = h.target) == null ? void 0 : de.result;
                  if (!H) return a([].concat(_toConsumableArray(N(r, o)), _toConsumableArray(t.filter(function (Me) {
                    return B(Me, e);
                  }))));
                  var K = H.value;
                  B(K, e, i) && K.version <= o && r.push(x(K)), H["continue"]();
                }), d.addEventListener("error", function (h) {
                  n(h);
                });
              }));
            case 2:
            case "end":
              return _context16.stop();
          }
        }, _callee16);
      }));
      function searchEmojis(_x39, _x40, _x41, _x42) {
        return _searchEmojis.apply(this, arguments);
      }
      return searchEmojis;
    }()
  }, {
    key: "waitForRequest",
    value: function () {
      var _waitForRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(e) {
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              return _context17.abrupt("return", new Promise(function (t, o) {
                e.onsuccess = t, e.onerror = o;
              }));
            case 1:
            case "end":
              return _context17.stop();
          }
        }, _callee17);
      }));
      function waitForRequest(_x43) {
        return _waitForRequest.apply(this, arguments);
      }
      return waitForRequest;
    }()
  }, {
    key: "withTransaction",
    value: function withTransaction(e) {
      var _this13 = this;
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "readwrite";
      var o = arguments.length > 2 ? arguments[2] : undefined;
      return new Promise(function (i, r) {
        var a = _this13.db.transaction(e, t);
        a.oncomplete = i, a.onerror = r, o(a);
      });
    }
  }, {
    key: "removeAllObjects",
    value: function () {
      var _removeAllObjects = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
        var _this14 = this;
        var _len5,
          e,
          _key5,
          t,
          o,
          _args18 = arguments;
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              for (_len5 = _args18.length, e = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                e[_key5] = _args18[_key5];
              }
              t = this.db.transaction(e, "readwrite"), o = e.map(function (i) {
                return t.objectStore(i);
              });
              _context18.next = 4;
              return Promise.all(o.map(function (i) {
                return _this14.waitForRequest(i.clear());
              }));
            case 4:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this);
      }));
      function removeAllObjects() {
        return _removeAllObjects.apply(this, arguments);
      }
      return removeAllObjects;
    }()
  }, {
    key: "addObjects",
    value: function () {
      var _addObjects = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(e, t) {
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              return _context19.abrupt("return", this.withTransaction(e, "readwrite", function (o) {
                var i = o.objectStore(e);
                t.forEach(function (r) {
                  i.add(r);
                });
              }));
            case 1:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this);
      }));
      function addObjects(_x44, _x45) {
        return _addObjects.apply(this, arguments);
      }
      return addObjects;
    }()
  }]);
  return Pt;
}(Ee);
function $e() {
  var s = {};
  return {
    getItem: function getItem(e) {
      return s[e];
    },
    setItem: function setItem(e, t) {
      return s[e] = t;
    },
    length: Object.keys(s).length,
    clear: function clear() {
      return s = {};
    },
    key: function key(e) {
      return Object.keys(s)[e];
    },
    removeItem: function removeItem(e) {
      return delete s[e];
    }
  };
}
var Ae = /*#__PURE__*/_createClass(function Ae() {
  _classCallCheck(this, Ae);
});
var G = "PicMo:recents";
var Ie = /*#__PURE__*/function (_Ae) {
  _inherits(Ie, _Ae);
  function Ie(e) {
    var _this15;
    _classCallCheck(this, Ie);
    _this15 = _callSuper(this, Ie), _this15.storage = e;
    return _this15;
  }
  _createClass(Ie, [{
    key: "clear",
    value: function clear() {
      this.storage.removeItem(G);
    }
  }, {
    key: "getRecents",
    value: function getRecents(e) {
      var t;
      try {
        return JSON.parse((t = this.storage.getItem(G)) != null ? t : "[]").slice(0, e);
      } catch (_unused3) {
        return [];
      }
    }
  }, {
    key: "addOrUpdateRecent",
    value: function addOrUpdateRecent(e, t) {
      var o = [e].concat(_toConsumableArray(this.getRecents(t).filter(function (i) {
        return i.hexcode !== e.hexcode;
      }))).slice(0, t);
      try {
        this.storage.setItem(G, JSON.stringify(o));
      } catch (_unused4) {
        console.warn("storage is not available, recent emojis will not be saved");
      }
    }
  }]);
  return Ie;
}(Ae);
var zt = /*#__PURE__*/function (_Ie) {
  _inherits(zt, _Ie);
  function zt() {
    _classCallCheck(this, zt);
    return _callSuper(this, zt, [qe() ? localStorage : $e()]);
  }
  return _createClass(zt);
}(Ie);
var Lt = {
  dataStore: Le,
  theme: ot,
  animate: !0,
  showCategoryTabs: !0,
  showPreview: !0,
  showRecents: !0,
  showSearch: !0,
  showVariants: !0,
  emojisPerRow: 8,
  visibleRows: 6,
  emojiVersion: "auto",
  i18n: ze,
  locale: "en",
  maxRecents: 50,
  custom: []
};
function $t() {
  var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return _objectSpread(_objectSpread(_objectSpread({}, Lt), s), {}, {
    renderer: s.renderer || new Ft(),
    recentsProvider: s.recentsProvider || new zt()
  });
}
var v, C, D, z, oe;
var le = /*#__PURE__*/function () {
  function le() {
    _classCallCheck(this, le);
    f(this, C);
    f(this, z);
    f(this, v, /* @__PURE__ */new Map());
  }
  _createClass(le, [{
    key: "on",
    value: function on(e, t, o) {
      g(this, z, oe).call(this, e, t, o);
    }
  }, {
    key: "once",
    value: function once(e, t, o) {
      g(this, z, oe).call(this, e, t, o, !0);
    }
  }, {
    key: "off",
    value: function off(e, t) {
      var o = g(this, C, D).call(this, e);
      y(this, v).set(e, o.filter(function (i) {
        return i.handler !== t;
      }));
    }
  }, {
    key: "emit",
    value: function emit(e) {
      var _this16 = this;
      for (var _len6 = arguments.length, t = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
        t[_key6 - 1] = arguments[_key6];
      }
      g(this, C, D).call(this, e).forEach(function (i) {
        i.handler.apply(i.context, t), i.once && _this16.off(e, i.handler);
      });
    }
  }, {
    key: "removeAll",
    value: function removeAll() {
      y(this, v).clear();
    }
  }]);
  return le;
}();
v = new WeakMap(), C = new WeakSet(), D = function D(e) {
  return y(this, v).has(e) || y(this, v).set(e, []), y(this, v).get(e);
}, z = new WeakSet(), oe = function oe(e, t, o) {
  var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
  g(this, C, D).call(this, e).push({
    context: o,
    handler: t,
    once: i
  });
};
var At = {
  injectStyles: !0
};
var It = /*#__PURE__*/function (_le) {
  _inherits(It, _le);
  function It() {
    _classCallCheck(this, It);
    return _callSuper(this, It, arguments);
  }
  return _createClass(It);
}(le);
var Tt = /*#__PURE__*/function (_le2) {
  _inherits(Tt, _le2);
  function Tt() {
    _classCallCheck(this, Tt);
    return _callSuper(this, Tt, arguments);
  }
  return _createClass(Tt);
}(le);
var ie = p("emojiCategory", "categoryName", "noRecents", "recentEmojis");
var he = /*#__PURE__*/function (_c2) {
  _inherits(he, _c2);
  function he(_ref12) {
    var _this17;
    var e = _ref12.template,
      t = _ref12.category,
      o = _ref12.showVariants,
      i = _ref12.lazyLoader;
    _classCallCheck(this, he);
    _this17 = _callSuper(this, he, [{
      template: e,
      classes: ie
    }]), _this17.baseUIElements = {
      categoryName: c.byClass(ie.categoryName)
    }, _this17.category = t, _this17.showVariants = o, _this17.lazyLoader = i;
    return _this17;
  }
  _createClass(he, [{
    key: "setActive",
    value: function setActive(e, t, o) {
      this.emojiContainer.setActive(e, t, o);
    }
  }]);
  return he;
}(c);
var Rt = new u(function (_ref13) {
    var s = _ref13.classes,
      e = _ref13.emoji;
    return "\n  <button\n    type=\"button\"\n    class=\"".concat(s.emojiButton, "\"\n    title=\"").concat(e.label, "\"\n    data-emoji=\"").concat(e.emoji, "\"\n    tabindex=\"-1\">\n    <div data-placeholder=\"emojiContent\"></div>\n  </button>\n");
  }),
  Mt = p("emojiButton");
var Te = /*#__PURE__*/function (_c3) {
  _inherits(Te, _c3);
  function Te(_ref14) {
    var _this18;
    var e = _ref14.emoji,
      t = _ref14.lazyLoader,
      o = _ref14.category;
    _classCallCheck(this, Te);
    _this18 = _callSuper(this, Te, [{
      template: Rt,
      classes: Mt
    }]), _this18.emoji = e, _this18.lazyLoader = t, _this18.category = o;
    return _this18;
  }
  _createClass(Te, [{
    key: "initialize",
    value: function initialize() {
      this.uiEvents = [c.uiEvent("focus", this.handleFocus)], _get(_getPrototypeOf(Te.prototype), "initialize", this).call(this);
    }
  }, {
    key: "handleFocus",
    value: function handleFocus() {
      this.category && this.events.emit("focus:change", this.category);
    }
  }, {
    key: "activateFocus",
    value: function activateFocus(e) {
      this.el.tabIndex = 0, e && this.el.focus();
    }
  }, {
    key: "deactivateFocus",
    value: function deactivateFocus() {
      this.el.tabIndex = -1;
    }
  }, {
    key: "renderSync",
    value: function renderSync() {
      return _get(_getPrototypeOf(Te.prototype), "renderSync", this).call(this, {
        emoji: this.emoji,
        emojiContent: this.renderer.doRender(this.emoji, this.lazyLoader)
      });
    }
  }]);
  return Te;
}(c);
var Vt = /*#__PURE__*/function () {
  function Vt(e, t) {
    var o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var r = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
    _classCallCheck(this, Vt);
    this.events = new le(), this.keyHandlers = {
      ArrowLeft: this.focusPrevious.bind(this),
      ArrowRight: this.focusNext.bind(this),
      ArrowUp: this.focusUp.bind(this),
      ArrowDown: this.focusDown.bind(this)
    }, this.rowCount = Math.ceil(t / e), this.columnCount = e, this.focusedRow = o, this.focusedColumn = i, this.emojiCount = t, this.wrap = r, this.handleKeyDown = this.handleKeyDown.bind(this);
  }
  _createClass(Vt, [{
    key: "destroy",
    value: function destroy() {
      this.events.removeAll();
    }
  }, {
    key: "on",
    value: function on(e, t) {
      this.events.on(e, t);
    }
  }, {
    key: "handleKeyDown",
    value: function handleKeyDown(e) {
      e.key in this.keyHandlers && (e.preventDefault(), this.keyHandlers[e.key]());
    }
  }, {
    key: "setCell",
    value: function setCell(e, t) {
      var o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
      var i = this.getIndex();
      this.focusedRow = e, t !== void 0 && (this.focusedColumn = Math.min(this.columnCount, t)), (this.focusedRow >= this.rowCount || this.getIndex() >= this.emojiCount) && (this.focusedRow = this.rowCount - 1, this.focusedColumn = this.emojiCount % this.columnCount - 1), this.events.emit("focus:change", {
        from: i,
        to: this.getIndex(),
        performFocus: o
      });
    }
  }, {
    key: "setFocusedIndex",
    value: function setFocusedIndex(e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
      var o = Math.floor(e / this.columnCount),
        i = e % this.columnCount;
      this.setCell(o, i, t);
    }
  }, {
    key: "focusNext",
    value: function focusNext() {
      this.focusedColumn < this.columnCount - 1 && this.getIndex() < this.emojiCount - 1 ? this.setCell(this.focusedRow, this.focusedColumn + 1) : this.focusedRow < this.rowCount - 1 ? this.setCell(this.focusedRow + 1, 0) : this.wrap ? this.setCell(0, 0) : this.events.emit("focus:overflow", 0);
    }
  }, {
    key: "focusPrevious",
    value: function focusPrevious() {
      this.focusedColumn > 0 ? this.setCell(this.focusedRow, this.focusedColumn - 1) : this.focusedRow > 0 ? this.setCell(this.focusedRow - 1, this.columnCount - 1) : this.wrap ? this.setCell(this.rowCount - 1, this.columnCount - 1) : this.events.emit("focus:underflow", this.columnCount - 1);
    }
  }, {
    key: "focusUp",
    value: function focusUp() {
      this.focusedRow > 0 ? this.setCell(this.focusedRow - 1, this.focusedColumn) : this.events.emit("focus:underflow", this.focusedColumn);
    }
  }, {
    key: "focusDown",
    value: function focusDown() {
      this.focusedRow < this.rowCount - 1 ? this.setCell(this.focusedRow + 1, this.focusedColumn) : this.events.emit("focus:overflow", this.focusedColumn);
    }
  }, {
    key: "focusToIndex",
    value: function focusToIndex(e) {
      this.setCell(Math.floor(e / this.columnCount), e % this.columnCount);
    }
  }, {
    key: "getIndex",
    value: function getIndex() {
      return this.focusedRow * this.columnCount + this.focusedColumn;
    }
  }, {
    key: "getCell",
    value: function getCell() {
      return {
        row: this.focusedRow,
        column: this.focusedColumn
      };
    }
  }, {
    key: "getRowCount",
    value: function getRowCount() {
      return this.rowCount;
    }
  }]);
  return Vt;
}();
var Dt = new u(function (_ref15) {
    var s = _ref15.classes;
    return "\n  <div class=\"".concat(s.emojiContainer, "\">\n    <div data-placeholder=\"emojis\"></div>\n  </div>\n");
  }),
  Bt = p("emojiContainer");
var $ = /*#__PURE__*/function (_c4) {
  _inherits($, _c4);
  function $(_ref16) {
    var _this19;
    var e = _ref16.emojis,
      t = _ref16.showVariants,
      _ref16$preview = _ref16.preview,
      o = _ref16$preview === void 0 ? !0 : _ref16$preview,
      i = _ref16.lazyLoader,
      r = _ref16.category,
      _ref16$fullHeight = _ref16.fullHeight,
      a = _ref16$fullHeight === void 0 ? !1 : _ref16$fullHeight;
    _classCallCheck(this, $);
    _this19 = _callSuper(this, $, [{
      template: Dt,
      classes: Bt
    }]), _this19.fullHeight = !1, _this19.showVariants = t, _this19.lazyLoader = i, _this19.preview = o, _this19.emojis = e, _this19.category = r, _this19.fullHeight = a, _this19.setFocus = _this19.setFocus.bind(_assertThisInitialized(_this19)), _this19.triggerNextCategory = _this19.triggerNextCategory.bind(_assertThisInitialized(_this19)), _this19.triggerPreviousCategory = _this19.triggerPreviousCategory.bind(_assertThisInitialized(_this19));
    return _this19;
  }
  _createClass($, [{
    key: "initialize",
    value: function initialize() {
      this.grid = new Vt(this.options.emojisPerRow, this.emojiCount, 0, 0, !this.category), this.grid.on("focus:change", this.setFocus), this.grid.on("focus:overflow", this.triggerNextCategory), this.grid.on("focus:underflow", this.triggerPreviousCategory), this.uiEvents = [c.uiEvent("click", this.selectEmoji), c.uiEvent("keydown", this.grid.handleKeyDown)], this.preview && this.uiEvents.push(c.uiEvent("mouseover", this.showPreview), c.uiEvent("mouseout", this.hidePreview), c.uiEvent("focus", this.showPreview, {
        capture: !0
      }), c.uiEvent("blur", this.hidePreview, {
        capture: !0
      })), _get(_getPrototypeOf($.prototype), "initialize", this).call(this);
    }
  }, {
    key: "setFocusedView",
    value: function setFocusedView(e, t) {
      var _this20 = this;
      if (!!e) if (typeof e == "string") {
        var o = this.emojis.findIndex(function (i) {
          return i.emoji === e;
        });
        this.grid.setFocusedIndex(o, !1), setTimeout(function () {
          var n, l, m, d;
          var i = _this20.emojiViews[o].el;
          i.scrollIntoView();
          var r = (n = i.parentElement) == null ? void 0 : n.previousElementSibling,
            a = (m = (l = i.parentElement) == null ? void 0 : l.parentElement) == null ? void 0 : m.parentElement;
          a.scrollTop -= (d = r == null ? void 0 : r.offsetHeight) != null ? d : 0;
        });
      } else e.row === "first" || e.row === 0 ? this.grid.setCell(0, e.offset, t) : e.row === "last" && this.grid.setCell(this.grid.getRowCount() - 1, e.offset, t);
    }
  }, {
    key: "setActive",
    value: function setActive(e, t, o) {
      var i;
      e ? this.setFocusedView(t, o) : (i = this.emojiViews[this.grid.getIndex()]) == null || i.deactivateFocus();
    }
  }, {
    key: "renderSync",
    value: function renderSync() {
      var _this21 = this;
      return this.emojiViews = this.emojis.map(function (e) {
        return _this21.viewFactory.create(Te, {
          emoji: e,
          category: _this21.category,
          lazyLoader: _this21.lazyLoader,
          renderer: _this21.renderer
        });
      }), this.emojiElements = this.emojiViews.map(function (e) {
        return e.renderSync();
      }), _get(_getPrototypeOf($.prototype), "renderSync", this).call(this, {
        emojis: this.emojiElements,
        i18n: this.i18n
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      _get(_getPrototypeOf($.prototype), "destroy", this).call(this), this.emojiViews.forEach(function (e) {
        return e.destroy();
      }), this.grid.destroy();
    }
  }, {
    key: "triggerPreviousCategory",
    value: function triggerPreviousCategory(e) {
      this.events.emit("category:previous", e);
    }
  }, {
    key: "triggerNextCategory",
    value: function triggerNextCategory(e) {
      this.category && this.events.emit("category:next", e);
    }
  }, {
    key: "setFocus",
    value: function setFocus(_ref17) {
      var e = _ref17.from,
        t = _ref17.to,
        o = _ref17.performFocus;
      var i, r;
      (i = this.emojiViews[e]) == null || i.deactivateFocus(), (r = this.emojiViews[t]) == null || r.activateFocus(o);
    }
  }, {
    key: "selectEmoji",
    value: function selectEmoji(e) {
      e.stopPropagation();
      var t = q(e, this.emojis);
      t && this.events.emit("emoji:select", {
        emoji: t,
        showVariants: this.showVariants
      });
    }
  }, {
    key: "showPreview",
    value: function showPreview(e) {
      var o = e.target.closest("button"),
        i = o == null ? void 0 : o.firstElementChild,
        r = q(e, this.emojis);
      r && this.events.emit("preview:show", r, i == null ? void 0 : i.cloneNode(!0));
    }
  }, {
    key: "hidePreview",
    value: function hidePreview(e) {
      q(e, this.emojis) && this.events.emit("preview:hide");
    }
  }, {
    key: "emojiCount",
    get: function get() {
      return this.emojis.length;
    }
  }]);
  return $;
}(c);
var Nt = new u(function (_ref18) {
  var s = _ref18.classes,
    e = _ref18.category,
    t = _ref18.pickerId,
    o = _ref18.icon,
    i = _ref18.i18n;
  return "\n  <section class=\"".concat(s.emojiCategory, "\" role=\"tabpanel\" aria-labelledby=\"").concat(t, "-category-").concat(e.key, "\">\n    <h3 data-category=\"").concat(e.key, "\" class=\"").concat(s.categoryName, "\">\n      <i data-icon=\"").concat(o, "\"></i>\n      ").concat(i.get("categories.".concat(e.key), e.message || e.key), "\n    </h3>\n    <div data-view=\"emojis\" data-render=\"sync\"></div>\n  </section>\n");
});
var Ot = /*#__PURE__*/function (_he) {
  _inherits(Ot, _he);
  function Ot(_ref19) {
    var _this22;
    var e = _ref19.category,
      t = _ref19.showVariants,
      o = _ref19.lazyLoader,
      i = _ref19.emojiVersion;
    _classCallCheck(this, Ot);
    _this22 = _callSuper(this, Ot, [{
      category: e,
      showVariants: t,
      lazyLoader: o,
      template: Nt
    }]), _this22.showVariants = t, _this22.lazyLoader = o, _this22.emojiVersion = i;
    return _this22;
  }
  _createClass(Ot, [{
    key: "initialize",
    value: function initialize() {
      this.uiElements = _objectSpread({}, this.baseUIElements), _get(_getPrototypeOf(Ot.prototype), "initialize", this).call(this);
    }
  }, {
    key: "render",
    value: function () {
      var _render2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
        var e;
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              _context20.next = 2;
              return this.emojiDataPromise;
            case 2:
              _context20.next = 4;
              return this.emojiData.getEmojis(this.category, this.emojiVersion);
            case 4:
              e = _context20.sent;
              return _context20.abrupt("return", (this.emojiContainer = this.viewFactory.create($, {
                emojis: e,
                showVariants: this.showVariants,
                lazyLoader: this.lazyLoader,
                category: this.category.key
              }), _get(_getPrototypeOf(Ot.prototype), "render", this).call(this, {
                category: this.category,
                emojis: this.emojiContainer,
                emojiCount: e.length,
                icon: O[this.category.key]
              })));
            case 6:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));
      function render() {
        return _render2.apply(this, arguments);
      }
      return render;
    }()
  }]);
  return Ot;
}(he);
var Ht = /*#__PURE__*/function (_$) {
  _inherits(Ht, _$);
  function Ht(_ref20) {
    var e = _ref20.category,
      t = _ref20.emojis,
      _ref20$preview = _ref20.preview,
      o = _ref20$preview === void 0 ? !0 : _ref20$preview,
      i = _ref20.lazyLoader;
    _classCallCheck(this, Ht);
    return _callSuper(this, Ht, [{
      category: e,
      emojis: t,
      showVariants: !1,
      preview: o,
      lazyLoader: i
    }]);
  }
  _createClass(Ht, [{
    key: "addOrUpdate",
    value: function () {
      var _addOrUpdate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(e) {
        var t, o, i, r;
        return _regeneratorRuntime().wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              t = this.el.querySelector("[data-emoji=\"".concat(e.emoji, "\"]"));
              t && (this.el.removeChild(t), this.emojis = this.emojis.filter(function (i) {
                return i !== e;
              }));
              o = this.viewFactory.create(Te, {
                emoji: e
              });
              if (this.el.insertBefore(o.renderSync(), this.el.firstChild), this.emojis = [e].concat(_toConsumableArray(this.emojis.filter(function (i) {
                return i !== e;
              }))), this.emojis.length > this.options.maxRecents) {
                this.emojis = this.emojis.slice(0, this.options.maxRecents);
                i = this.el.childElementCount - this.options.maxRecents;
                for (r = 0; r < i; r++) this.el.lastElementChild && this.el.removeChild(this.el.lastElementChild);
              }
            case 4:
            case "end":
              return _context21.stop();
          }
        }, _callee21, this);
      }));
      function addOrUpdate(_x46) {
        return _addOrUpdate.apply(this, arguments);
      }
      return addOrUpdate;
    }()
  }]);
  return Ht;
}($);
var Kt = new u(function (_ref21) {
  var s = _ref21.emojiCount,
    e = _ref21.classes,
    t = _ref21.category,
    o = _ref21.pickerId,
    i = _ref21.icon,
    r = _ref21.i18n;
  return "\n  <section class=\"".concat(e.emojiCategory, "\" role=\"tabpanel\" aria-labelledby=\"").concat(o, "-category-").concat(t.key, "\">\n    <h3 data-category=\"").concat(t.key, "\" class=\"").concat(e.categoryName, "\">\n      <i data-icon=\"").concat(i, "\"></i>\n      ").concat(r.get("categories.".concat(t.key), t.message || t.key), "\n    </h3>\n    <div data-empty=\"").concat(s === 0, "\" class=\"").concat(e.recentEmojis, "\">\n      <div data-view=\"emojis\" data-render=\"sync\"></div>\n    </div>\n    <div class=\"").concat(e.noRecents, "\">\n      ").concat(r.get("recents.none"), "\n    </div>\n  </section>\n");
}, {
  mode: "async"
});
var Ut = /*#__PURE__*/function (_he2) {
  _inherits(Ut, _he2);
  function Ut(_ref22) {
    var _this23;
    var e = _ref22.category,
      t = _ref22.lazyLoader,
      o = _ref22.provider;
    _classCallCheck(this, Ut);
    _this23 = _callSuper(this, Ut, [{
      category: e,
      showVariants: !1,
      lazyLoader: t,
      template: Kt
    }]), _this23.provider = o;
    return _this23;
  }
  _createClass(Ut, [{
    key: "initialize",
    value: function initialize() {
      this.uiElements = _objectSpread(_objectSpread({}, this.baseUIElements), {}, {
        recents: c.byClass(ie.recentEmojis)
      }), this.appEvents = {
        "recent:add": this.addRecent
      }, _get(_getPrototypeOf(Ut.prototype), "initialize", this).call(this);
    }
  }, {
    key: "addRecent",
    value: function () {
      var _addRecent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(e) {
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              _context22.next = 2;
              return this.emojiContainer.addOrUpdate(e);
            case 2:
              this.ui.recents.dataset.empty = "false";
            case 3:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this);
      }));
      function addRecent(_x47) {
        return _addRecent.apply(this, arguments);
      }
      return addRecent;
    }()
  }, {
    key: "render",
    value: function () {
      var _render3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {
        var t, e;
        return _regeneratorRuntime().wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              e = (t = this.provider) == null ? void 0 : t.getRecents(this.options.maxRecents);
              this.emojiContainer = this.viewFactory.create(Ht, {
                emojis: e,
                showVariants: !1,
                lazyLoader: this.lazyLoader,
                category: this.category.key
              });
              _context23.next = 4;
              return _get(_getPrototypeOf(Ut.prototype), "render", this).call(this, {
                category: this.category,
                emojis: this.emojiContainer,
                emojiCount: e.length,
                icon: O[this.category.key]
              });
            case 4:
              return _context23.abrupt("return", this.el);
            case 5:
            case "end":
              return _context23.stop();
          }
        }, _callee23, this);
      }));
      function render() {
        return _render3.apply(this, arguments);
      }
      return render;
    }()
  }]);
  return Ut;
}(he);
var qt = new u(function (_ref23) {
  var s = _ref23.classes,
    e = _ref23.category,
    t = _ref23.pickerId,
    o = _ref23.icon,
    i = _ref23.i18n;
  return "\n  <section class=\"".concat(s.emojiCategory, "\" role=\"tabpanel\" aria-labelledby=\"").concat(t, "-category-").concat(e.key, "\">\n    <h3 data-category=\"").concat(e.key, "\" class=\"").concat(s.categoryName, "\">\n      <i data-icon=\"").concat(o, "\"></i>\n      ").concat(i.get("categories.".concat(e.key), e.message || e.key), "\n    </h3>\n    <div data-view=\"emojis\" data-render=\"sync\"></div>\n  </section>\n");
});
var Wt = /*#__PURE__*/function (_he3) {
  _inherits(Wt, _he3);
  function Wt(_ref24) {
    var e = _ref24.category,
      t = _ref24.lazyLoader;
    _classCallCheck(this, Wt);
    return _callSuper(this, Wt, [{
      template: qt,
      showVariants: !1,
      lazyLoader: t,
      category: e
    }]);
  }
  _createClass(Wt, [{
    key: "initialize",
    value: function initialize() {
      this.uiElements = _objectSpread({}, this.baseUIElements), _get(_getPrototypeOf(Wt.prototype), "initialize", this).call(this);
    }
  }, {
    key: "render",
    value: function () {
      var _render4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {
        return _regeneratorRuntime().wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              return _context24.abrupt("return", (this.emojiContainer = this.viewFactory.create($, {
                emojis: this.customEmojis,
                showVariants: this.showVariants,
                lazyLoader: this.lazyLoader,
                category: this.category.key
              }), _get(_getPrototypeOf(Wt.prototype), "render", this).call(this, {
                category: this.category,
                emojis: this.emojiContainer,
                emojiCount: this.customEmojis.length,
                icon: O[this.category.key]
              })));
            case 1:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this);
      }));
      function render() {
        return _render4.apply(this, arguments);
      }
      return render;
    }()
  }]);
  return Wt;
}(he);
var Re = /*#__PURE__*/function () {
  function Re() {
    _classCallCheck(this, Re);
    this.elements = /* @__PURE__ */new Map();
  }
  _createClass(Re, [{
    key: "lazyLoad",
    value: function lazyLoad(e, t) {
      return this.elements.set(e, t), e;
    }
  }, {
    key: "observe",
    value: function observe(e) {
      var _this24 = this;
      if (window.IntersectionObserver) {
        var t = new IntersectionObserver(function (o) {
          o.filter(function (i) {
            return i.intersectionRatio > 0;
          }).map(function (i) {
            return i.target;
          }).forEach(function (i) {
            var r = _this24.elements.get(i);
            r == null || r(), t.unobserve(i);
          });
        }, {
          root: e
        });
        this.elements.forEach(function (o, i) {
          t.observe(i);
        });
      } else this.elements.forEach(function (t) {
        t();
      });
    }
  }]);
  return Re;
}();
var ye = p("emojiArea"),
  Gt = new u(function (_ref25) {
    var s = _ref25.classes;
    return "\n  <div class=\"".concat(s.emojiArea, "\">\n    <div data-placeholder=\"emojis\"></div>\n  </div>\n");
  }, {
    mode: "async"
  }),
  Jt = {
    recents: Ut,
    custom: Wt
  };
function Zt(s) {
  return Jt[s.key] || Ot;
}
function Yt(s) {
  return !s || s === "button" ? {
    row: "first",
    offset: 0
  } : s;
}
var Qt = /*#__PURE__*/function (_c5) {
  _inherits(Qt, _c5);
  function Qt(_ref26) {
    var _this25;
    var e = _ref26.categoryTabs,
      t = _ref26.categories,
      o = _ref26.emojiVersion;
    _classCallCheck(this, Qt);
    _this25 = _callSuper(this, Qt, [{
      template: Gt,
      classes: ye
    }]), _this25.selectedCategory = 0, _this25.scrollListenerState = "active", _this25.lazyLoader = new Re(), _this25.categoryTabs = e, _this25.categories = t, _this25.emojiVersion = o, _this25.handleScroll = He(_this25.handleScroll.bind(_assertThisInitialized(_this25)), 100);
    return _this25;
  }
  _createClass(Qt, [{
    key: "initialize",
    value: function initialize() {
      this.appEvents = {
        "category:select": this.handleCategorySelect,
        "category:previous": this.focusPreviousCategory,
        "category:next": this.focusNextCategory,
        "focus:change": this.updateFocusedCategory
      }, this.uiElements = {
        emojis: c.byClass(ye.emojiArea)
      }, this.uiEvents = [c.uiEvent("scroll", this.handleScroll)], _get(_getPrototypeOf(Qt.prototype), "initialize", this).call(this);
    }
  }, {
    key: "focusableEmoji",
    get: function get() {
      return this.el.querySelector('[tabindex="0"]');
    }
  }, {
    key: "render",
    value: function () {
      var _render5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {
        var _this26 = this;
        var e;
        return _regeneratorRuntime().wrap(function _callee25$(_context25) {
          while (1) switch (_context25.prev = _context25.next) {
            case 0:
              this.emojiCategories = this.categories.map(this.createCategory, this);
              e = {};
              this.categories.forEach(function (t, o) {
                e["emojis-".concat(t.key)] = _this26.emojiCategories[o];
              });
              _context25.t0 = _get(_getPrototypeOf(Qt.prototype), "render", this);
              _context25.t1 = this;
              _context25.next = 7;
              return Promise.all(this.emojiCategories.map(function (t) {
                return t.render();
              }));
            case 7:
              _context25.t2 = _context25.sent;
              _context25.t3 = {
                emojis: _context25.t2
              };
              _context25.next = 11;
              return _context25.t0.call.call(_context25.t0, _context25.t1, _context25.t3);
            case 11:
              this.lazyLoader.observe(this.el);
              return _context25.abrupt("return", this.el);
            case 13:
            case "end":
              return _context25.stop();
          }
        }, _callee25, this);
      }));
      function render() {
        return _render5.apply(this, arguments);
      }
      return render;
    }()
  }, {
    key: "destroy",
    value: function destroy() {
      var _this27 = this;
      _get(_getPrototypeOf(Qt.prototype), "destroy", this).call(this), this.emojiCategories.forEach(function (e) {
        var t;
        (t = _this27.observer) == null || t.unobserve(e.el), e.destroy();
      });
    }
  }, {
    key: "handleCategorySelect",
    value: function handleCategorySelect(e, t) {
      this.el.style.overflow = "hidden", this.selectCategory(e, t), this.el.style.overflow = "auto";
    }
  }, {
    key: "createCategory",
    value: function createCategory(e) {
      var t = Zt(e);
      return this.viewFactory.create(t, {
        category: e,
        showVariants: !0,
        lazyLoader: this.lazyLoader,
        emojiVersion: this.emojiVersion,
        provider: this.options.recentsProvider
      });
    }
  }, {
    key: "determineInitialCategory",
    value: function determineInitialCategory() {
      var _this28 = this;
      var e;
      return this.options.initialCategory && this.categories.find(function (t) {
        return t.key === _this28.options.initialCategory;
      }) ? this.options.initialCategory : (e = this.categories.find(function (t) {
        return t.key !== "recents";
      })) == null ? void 0 : e.key;
    }
  }, {
    key: "determineFocusTarget",
    value: function determineFocusTarget(e) {
      var t = this.emojiCategories.find(function (o) {
        return o.category.key === e;
      });
      return this.options.initialEmoji && (t == null ? void 0 : t.el.querySelector("[data-emoji=\"".concat(this.options.initialEmoji, "\"]"))) ? this.options.initialEmoji : "button";
    }
  }, {
    key: "reset",
    value: function reset() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
      this.events.emit("preview:hide");
      var t = this.determineInitialCategory();
      t && (this.selectCategory(t, {
        focus: this.determineFocusTarget(t),
        performFocus: e,
        scroll: "jump"
      }), this.selectedCategory = this.getCategoryIndex(t));
    }
  }, {
    key: "getCategoryIndex",
    value: function getCategoryIndex(e) {
      return this.categories.findIndex(function (t) {
        return t.key === e;
      });
    }
  }, {
    key: "focusPreviousCategory",
    value: function focusPreviousCategory(e) {
      this.selectedCategory > 0 && this.focusCategory(this.selectedCategory - 1, {
        row: "last",
        offset: e != null ? e : this.options.emojisPerRow
      });
    }
  }, {
    key: "focusNextCategory",
    value: function focusNextCategory(e) {
      this.selectedCategory < this.categories.length - 1 && this.focusCategory(this.selectedCategory + 1, {
        row: "first",
        offset: e != null ? e : 0
      });
    }
  }, {
    key: "focusCategory",
    value: function focusCategory(e, t) {
      this.selectCategory(e, {
        focus: t,
        performFocus: !0
      });
    }
  }, {
    key: "selectCategory",
    value: function () {
      var _selectCategory = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(e) {
        var t,
          l,
          _performFocus$t,
          o,
          i,
          r,
          a,
          n,
          _args26 = arguments;
        return _regeneratorRuntime().wrap(function _callee26$(_context26) {
          while (1) switch (_context26.prev = _context26.next) {
            case 0:
              t = _args26.length > 1 && _args26[1] !== undefined ? _args26[1] : {};
              this.scrollListenerState = "suspend";
              _performFocus$t = _objectSpread({
                performFocus: !1
              }, t), o = _performFocus$t.focus, i = _performFocus$t.performFocus, r = _performFocus$t.scroll;
              this.emojiCategories[this.selectedCategory].setActive(!1);
              a = this.selectedCategory = typeof e == "number" ? e : this.getCategoryIndex(e);
              (l = this.categoryTabs) == null || l.setActiveTab(this.selectedCategory, {
                performFocus: i,
                scroll: o === "button"
              });
              n = this.emojiCategories[a].el.offsetTop;
              this.emojiCategories[a].setActive(!0, Yt(o), o !== "button" && i), r && (this.el.scrollTop = n), this.scrollListenerState = "resume";
            case 8:
            case "end":
              return _context26.stop();
          }
        }, _callee26, this);
      }));
      function selectCategory(_x48) {
        return _selectCategory.apply(this, arguments);
      }
      return selectCategory;
    }()
  }, {
    key: "updateFocusedCategory",
    value: function updateFocusedCategory(e) {
      var t;
      this.categories[this.selectedCategory].key !== e && (this.scrollListenerState = "suspend", this.selectedCategory = this.getCategoryIndex(e), (t = this.categoryTabs) == null || t.setActiveTab(this.selectedCategory, {
        changeFocusable: !1,
        performFocus: !1
      }), this.scrollListenerState = "resume");
    }
  }, {
    key: "handleScroll",
    value: function handleScroll() {
      var _this29 = this;
      if (this.scrollListenerState === "suspend" || !this.categoryTabs) return;
      if (this.scrollListenerState === "resume") {
        this.scrollListenerState = "active";
        return;
      }
      var e = this.el.scrollTop,
        t = this.el.scrollHeight - this.el.offsetHeight,
        o = this.emojiCategories.findIndex(function (r, a) {
          var n;
          return e < ((n = _this29.emojiCategories[a + 1]) == null ? void 0 : n.el.offsetTop);
        }),
        i = {
          changeFocusable: !1,
          performFocus: !1,
          scroll: !1
        };
      e === 0 ? this.categoryTabs.setActiveTab(0, i) : Math.floor(e) === Math.floor(t) || o < 0 ? this.categoryTabs.setActiveTab(this.categories.length - 1, i) : this.categoryTabs.setActiveTab(o, i);
    }
  }]);
  return Qt;
}(c);
var Xt = new u(function (_ref27) {
    var s = _ref27.classList,
      e = _ref27.classes,
      t = _ref27.icon,
      o = _ref27.message;
    return "\n<div class=\"".concat(s, "\" role=\"alert\">\n  <div class=\"").concat(e.iconContainer, "\"><i data-size=\"10x\" data-icon=\"").concat(t, "\"></i></div>\n  <h3 class=\"").concat(e.title, "\">").concat(o, "</h3>\n</div>\n");
  }),
  fe = p("error", "iconContainer", "title");
var re = /*#__PURE__*/function (_c6) {
  _inherits(re, _c6);
  function re(_ref28) {
    var _this30;
    var e = _ref28.message,
      _ref28$icon = _ref28.icon,
      t = _ref28$icon === void 0 ? "warning" : _ref28$icon,
      _ref28$template = _ref28.template,
      o = _ref28$template === void 0 ? Xt : _ref28$template,
      i = _ref28.className;
    _classCallCheck(this, re);
    _this30 = _callSuper(this, re, [{
      template: o,
      classes: fe
    }]), _this30.message = e, _this30.icon = t, _this30.className = i;
    return _this30;
  }
  _createClass(re, [{
    key: "renderSync",
    value: function renderSync() {
      var e = [fe.error, this.className].join(" ").trim();
      return _get(_getPrototypeOf(re.prototype), "renderSync", this).call(this, {
        message: this.message,
        icon: this.icon,
        classList: e
      });
    }
  }]);
  return re;
}(c);
var es = new u(function (_ref29) {
    var s = _ref29.classList,
      e = _ref29.classes,
      t = _ref29.icon,
      o = _ref29.i18n,
      i = _ref29.message;
    return "\n  <div class=\"".concat(s, "\" role=\"alert\">\n    <div class=\"").concat(e.icon, "\"><i data-size=\"10x\" data-icon=\"").concat(t, "\"></i></div>\n    <h3 class=\"").concat(e.title, "\">").concat(i, "</h3>\n    <button type=\"button\">").concat(o.get("retry"), "</button>\n  </div>\n");
  }),
  ts = p("dataError");
var ss = /*#__PURE__*/function (_re) {
  _inherits(ss, _re);
  function ss(_ref30) {
    var e = _ref30.message;
    _classCallCheck(this, ss);
    return _callSuper(this, ss, [{
      message: e,
      template: es,
      className: ts.dataError
    }]);
  }
  _createClass(ss, [{
    key: "initialize",
    value: function initialize() {
      this.uiElements = {
        retryButton: "button"
      }, this.uiEvents = [c.childEvent("retryButton", "click", this.onRetry)], _get(_getPrototypeOf(ss.prototype), "initialize", this).call(this);
    }
  }, {
    key: "onRetry",
    value: function () {
      var _onRetry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {
        var e;
        return _regeneratorRuntime().wrap(function _callee27$(_context27) {
          while (1) switch (_context27.prev = _context27.next) {
            case 0:
              if (!this.emojiData) {
                _context27.next = 5;
                break;
              }
              _context27.next = 3;
              return this.emojiData["delete"]();
            case 3:
              _context27.next = 7;
              break;
            case 5:
              _context27.next = 7;
              return this.options.dataStore.deleteDatabase(this.options.locale);
            case 7:
              this.events.emit("reinitialize");
              _context27.next = 10;
              return ce(this.options.locale, this.options.dataStore, this.options.messages, this.options.emojiData, this.emojiData);
            case 10:
              e = _context27.sent;
              this.viewFactory.setEmojiData(e), this.events.emit("data:ready", e);
            case 12:
            case "end":
              return _context27.stop();
          }
        }, _callee27, this);
      }));
      function onRetry() {
        return _onRetry.apply(this, arguments);
      }
      return onRetry;
    }()
  }]);
  return ss;
}(re);
var j = p("preview", "previewEmoji", "previewName", "tagList", "tag"),
  os = new u(function (_ref31) {
    var s = _ref31.classes,
      e = _ref31.tag;
    return "\n  <li class=\"".concat(s.tag, "\">").concat(e, "</li>\n");
  }),
  is = new u(function (_ref32) {
    var s = _ref32.classes;
    return "\n  <div class=\"".concat(s.preview, "\">\n    <div class=\"").concat(s.previewEmoji, "\"></div>\n    <div class=\"").concat(s.previewName, "\"></div>\n    <ul class=\"").concat(s.tagList, "\"></ul>\n  </div>\n");
  });
var rs = /*#__PURE__*/function (_c7) {
  _inherits(rs, _c7);
  function rs() {
    _classCallCheck(this, rs);
    return _callSuper(this, rs, [{
      template: is,
      classes: j
    }]);
  }
  _createClass(rs, [{
    key: "initialize",
    value: function initialize() {
      this.uiElements = {
        emoji: c.byClass(j.previewEmoji),
        name: c.byClass(j.previewName),
        tagList: c.byClass(j.tagList)
      }, this.appEvents = {
        "preview:show": this.showPreview,
        "preview:hide": this.hidePreview
      }, _get(_getPrototypeOf(rs.prototype), "initialize", this).call(this);
    }
  }, {
    key: "showPreview",
    value: function showPreview(e, t) {
      if (w(this.ui.emoji, t), this.ui.name.textContent = e.label, e.tags) {
        this.ui.tagList.style.display = "flex";
        var o = e.tags.map(function (i) {
          return os.renderSync({
            tag: i,
            classes: j
          });
        });
        w.apply(void 0, [this.ui.tagList].concat(_toConsumableArray(o)));
      }
    }
  }, {
    key: "hidePreview",
    value: function hidePreview() {
      V(this.ui.emoji), V(this.ui.name), V(this.ui.tagList);
    }
  }]);
  return rs;
}(c);
var as = new u(function (_ref33) {
    var s = _ref33.classes,
      e = _ref33.i18n;
    return "\n  <button title=\"".concat(e.get("search.clear"), "\" class=\"").concat(s.clearSearchButton, "\">\n    <i data-icon=\"xmark\"></i>\n  </button>\n");
  }),
  ns = new u(function (_ref34) {
    var s = _ref34.classes,
      e = _ref34.i18n;
    return "\n<div class=\"".concat(s.searchContainer, "\">\n  <input class=\"").concat(s.searchField, "\" placeholder=\"").concat(e.get("search"), "\">\n  <span class=\"").concat(s.searchAccessory, "\"></span>\n</div>\n");
  }, {
    mode: "async"
  }),
  _ = p("searchContainer", "searchField", "clearButton", "searchAccessory", "clearSearchButton", "notFound");
var cs = /*#__PURE__*/function (_c8) {
  _inherits(cs, _c8);
  function cs(_ref35) {
    var _this31;
    var e = _ref35.categories,
      t = _ref35.emojiVersion;
    _classCallCheck(this, cs);
    _this31 = _callSuper(this, cs, [{
      template: ns,
      classes: _
    }]), _this31.categories = e.filter(function (o) {
      return o.key !== "recents";
    }), _this31.emojiVersion = t, _this31.search = Ke(_this31.search.bind(_assertThisInitialized(_this31)), 100);
    return _this31;
  }
  _createClass(cs, [{
    key: "initialize",
    value: function initialize() {
      this.uiElements = {
        searchField: c.byClass(_.searchField),
        searchAccessory: c.byClass(_.searchAccessory)
      }, this.uiEvents = [c.childEvent("searchField", "keydown", this.onKeyDown), c.childEvent("searchField", "input", this.onSearchInput)], _get(_getPrototypeOf(cs.prototype), "initialize", this).call(this);
    }
  }, {
    key: "render",
    value: function () {
      var _render6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {
        var _this32 = this;
        return _regeneratorRuntime().wrap(function _callee28$(_context28) {
          while (1) switch (_context28.prev = _context28.next) {
            case 0:
              _context28.next = 2;
              return _get(_getPrototypeOf(cs.prototype), "render", this).call(this);
            case 2:
              this.searchIcon = Pe("search");
              this.notFoundMessage = this.viewFactory.create(re, {
                message: this.i18n.get("search.notFound"),
                className: _.notFound,
                icon: "sad"
              });
              this.notFoundMessage.renderSync();
              this.errorMessage = this.viewFactory.create(re, {
                message: this.i18n.get("search.error")
              });
              this.errorMessage.renderSync();
              this.clearSearchButton = as.render({
                classes: _,
                i18n: this.i18n
              });
              this.clearSearchButton.addEventListener("click", function (e) {
                return _this32.onClearSearch(e);
              });
              this.searchField = this.ui.searchField;
              this.showSearchIcon();
              return _context28.abrupt("return", this.el);
            case 12:
            case "end":
              return _context28.stop();
          }
        }, _callee28, this);
      }));
      function render() {
        return _render6.apply(this, arguments);
      }
      return render;
    }()
  }, {
    key: "showSearchIcon",
    value: function showSearchIcon() {
      this.showSearchAccessory(this.searchIcon);
    }
  }, {
    key: "showClearSearchButton",
    value: function showClearSearchButton() {
      this.showSearchAccessory(this.clearSearchButton);
    }
  }, {
    key: "showSearchAccessory",
    value: function showSearchAccessory(e) {
      w(this.ui.searchAccessory, e);
    }
  }, {
    key: "clear",
    value: function clear() {
      this.searchField.value = "", this.showSearchIcon();
    }
  }, {
    key: "focus",
    value: function focus() {
      this.searchField.focus();
    }
  }, {
    key: "onClearSearch",
    value: function onClearSearch(e) {
      var t;
      e.stopPropagation(), this.searchField.value = "", (t = this.resultsContainer) == null || t.destroy(), this.resultsContainer = null, this.showSearchIcon(), this.events.emit("content:show"), this.searchField.focus();
    }
  }, {
    key: "handleResultsKeydown",
    value: function handleResultsKeydown(e) {
      this.resultsContainer && e.key === "Escape" && this.onClearSearch(e);
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(e) {
      var t;
      e.key === "Escape" && this.searchField.value ? this.onClearSearch(e) : (e.key === "Enter" || e.key === "ArrowDown") && this.resultsContainer && (e.preventDefault(), (t = this.resultsContainer.el.querySelector('[tabindex="0"]')) == null || t.focus());
    }
  }, {
    key: "onSearchInput",
    value: function onSearchInput(e) {
      this.searchField.value ? (this.showClearSearchButton(), this.search()) : this.onClearSearch(e);
    }
  }, {
    key: "search",
    value: function () {
      var _search = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {
        var _this33 = this;
        var e, t, o;
        return _regeneratorRuntime().wrap(function _callee29$(_context29) {
          while (1) switch (_context29.prev = _context29.next) {
            case 0:
              if (!this.searchField.value) {
                _context29.next = 11;
                break;
              }
              _context29.prev = 1;
              _context29.next = 4;
              return this.emojiData.searchEmojis(this.searchField.value, this.customEmojis, this.emojiVersion, this.categories);
            case 4:
              t = _context29.sent;
              if (this.events.emit("preview:hide"), t.length) {
                o = new Re();
                this.resultsContainer = this.viewFactory.create($, {
                  emojis: t,
                  fullHeight: !0,
                  showVariants: !0,
                  lazyLoader: o
                }), this.resultsContainer.renderSync(), (e = this.resultsContainer) != null && e.el && (o.observe(this.resultsContainer.el), this.resultsContainer.setActive(!0, {
                  row: 0,
                  offset: 0
                }, !1), this.resultsContainer.el.addEventListener("keydown", function (i) {
                  return _this33.handleResultsKeydown(i);
                }), this.events.emit("content:show", this.resultsContainer));
              } else this.events.emit("content:show", this.notFoundMessage);
              _context29.next = 11;
              break;
            case 8:
              _context29.prev = 8;
              _context29.t0 = _context29["catch"](1);
              this.events.emit("content:show", this.errorMessage);
            case 11:
            case "end":
              return _context29.stop();
          }
        }, _callee29, this, [[1, 8]]);
      }));
      function search() {
        return _search.apply(this, arguments);
      }
      return search;
    }()
  }]);
  return cs;
}(c);
var ls = new u(function (_ref36) {
    var s = _ref36.classes;
    return "\n  <div class=\"".concat(s.variantOverlay, "\">\n    <div class=\"").concat(s.variantPopup, "\">\n      <div data-view=\"emojis\" data-render=\"sync\"></div>\n    </div>\n  </div>\n");
  }),
  ve = p("variantOverlay", "variantPopup"),
  J = {
    easing: "ease-in-out",
    duration: 250,
    fill: "both"
  },
  we = {
    opacity: [0, 1]
  },
  be = {
    opacity: [0, 1],
    transform: ["scale3d(0.8, 0.8, 0.8)", "scale3d(1, 1, 1)"]
  };
var hs = /*#__PURE__*/function (_c9) {
  _inherits(hs, _c9);
  function hs(_ref37) {
    var _this34;
    var e = _ref37.emoji,
      t = _ref37.parent;
    _classCallCheck(this, hs);
    _this34 = _callSuper(this, hs, [{
      template: ls,
      classes: ve,
      parent: t
    }]), _this34.focusedEmojiIndex = 0, _this34.focusTrap = new st(), _this34.animateShow = function () {
      return Promise.all([I(_this34.el, we, J, _this34.options), I(_this34.ui.popup, be, J, _this34.options)]);
    }, _this34.emoji = e;
    return _this34;
  }
  _createClass(hs, [{
    key: "initialize",
    value: function initialize() {
      this.uiElements = {
        popup: c.byClass(ve.variantPopup)
      }, this.uiEvents = [c.uiEvent("click", this.handleClick), c.uiEvent("keydown", this.handleKeydown)], _get(_getPrototypeOf(hs.prototype), "initialize", this).call(this);
    }
  }, {
    key: "animateHide",
    value: function animateHide() {
      var e = _objectSpread(_objectSpread({}, J), {}, {
        direction: "reverse"
      });
      return Promise.all([I(this.el, we, e, this.options), I(this.ui.popup, be, e, this.options)]);
    }
  }, {
    key: "hide",
    value: function () {
      var _hide = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30() {
        return _regeneratorRuntime().wrap(function _callee30$(_context30) {
          while (1) switch (_context30.prev = _context30.next) {
            case 0:
              _context30.next = 2;
              return this.animateHide();
            case 2:
              this.events.emit("variantPopup:hide");
            case 3:
            case "end":
              return _context30.stop();
          }
        }, _callee30, this);
      }));
      function hide() {
        return _hide.apply(this, arguments);
      }
      return hide;
    }()
  }, {
    key: "handleKeydown",
    value: function handleKeydown(e) {
      e.key === "Escape" && (this.hide(), e.stopPropagation());
    }
  }, {
    key: "handleClick",
    value: function handleClick(e) {
      this.ui.popup.contains(e.target) || this.hide();
    }
  }, {
    key: "getEmoji",
    value: function getEmoji(e) {
      return this.renderedEmojis[e];
    }
  }, {
    key: "setFocusedEmoji",
    value: function setFocusedEmoji(e) {
      var t = this.getEmoji(this.focusedEmojiIndex);
      t.tabIndex = -1, this.focusedEmojiIndex = e;
      var o = this.getEmoji(this.focusedEmojiIndex);
      o.tabIndex = 0, o.focus();
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.emojiContainer.destroy(), this.focusTrap.deactivate(), _get(_getPrototypeOf(hs.prototype), "destroy", this).call(this);
    }
  }, {
    key: "renderSync",
    value: function renderSync() {
      var _this35 = this;
      var e = _objectSpread(_objectSpread({}, this.emoji), {}, {
          skins: null
        }),
        t = (this.emoji.skins || []).map(function (i) {
          return _objectSpread(_objectSpread({}, i), {}, {
            label: _this35.emoji.label,
            tags: _this35.emoji.tags
          });
        }),
        o = [e].concat(_toConsumableArray(t));
      return this.emojiContainer = this.viewFactory.create($, {
        emojis: o,
        preview: !1
      }), _get(_getPrototypeOf(hs.prototype), "renderSync", this).call(this, {
        emojis: this.emojiContainer
      }), o.length < this.options.emojisPerRow && this.el.style.setProperty("--emojis-per-row", o.length.toString()), this.el;
    }
  }, {
    key: "activate",
    value: function activate() {
      this.emojiContainer.setActive(!0, {
        row: 0,
        offset: 0
      }, !0), this.focusTrap.activate(this.el);
    }
  }]);
  return hs;
}(c);
var ds = new u(function (_ref38) {
    var s = _ref38.classes,
      e = _ref38.i18n,
      t = _ref38.category,
      o = _ref38.pickerId,
      i = _ref38.icon;
    return "\n<li class=\"".concat(s.categoryTab, "\">\n  <button\n    aria-selected=\"false\"\n    role=\"tab\"\n    class=\"").concat(s.categoryButton, "\"\n    tabindex=\"-1\"\n    title=\"").concat(e.get("categories.".concat(t.key), t.message || t.key), "\"\n    type=\"button\"\n    data-category=\"").concat(t.key, "\"\n    id=\"").concat(o, "-category-").concat(t.key, "\"\n  >\n    <i data-icon=\"").concat(i, "\"></i>\n</li>\n");
  }),
  Z = p("categoryTab", "categoryTabActive", "categoryButton");
var ms = /*#__PURE__*/function (_c10) {
  _inherits(ms, _c10);
  function ms(_ref39) {
    var _this36;
    var e = _ref39.category,
      t = _ref39.icon;
    _classCallCheck(this, ms);
    _this36 = _callSuper(this, ms, [{
      template: ds,
      classes: Z
    }]), _this36.isActive = !1, _this36.category = e, _this36.icon = t;
    return _this36;
  }
  _createClass(ms, [{
    key: "initialize",
    value: function initialize() {
      this.uiElements = {
        button: c.byClass(Z.categoryButton)
      }, this.uiEvents = [c.childEvent("button", "click", this.selectCategory), c.childEvent("button", "focus", this.selectCategory)], _get(_getPrototypeOf(ms.prototype), "initialize", this).call(this);
    }
  }, {
    key: "renderSync",
    value: function renderSync() {
      return _get(_getPrototypeOf(ms.prototype), "renderSync", this).call(this, {
        category: this.category,
        icon: this.icon
      }), this.ui.button.ariaSelected = "false", this.el;
    }
  }, {
    key: "setActive",
    value: function setActive(e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _changeFocusable$perf = _objectSpread({
          changeFocusable: !0,
          performFocus: !0,
          scroll: !0
        }, t),
        o = _changeFocusable$perf.changeFocusable,
        i = _changeFocusable$perf.performFocus,
        r = _changeFocusable$perf.scroll;
      this.el.classList.toggle(Z.categoryTabActive, e), o && (this.ui.button.tabIndex = e ? 0 : -1, this.ui.button.ariaSelected = e.toString()), e && i && (this.ui.button.focus(), r && this.events.emit("category:select", this.category.key, {
        scroll: "animate",
        focus: "button",
        performFocus: !1
      })), this.isActive = e;
    }
  }, {
    key: "selectCategory",
    value: function selectCategory() {
      this.isActive || this.events.emit("category:select", this.category.key, {
        scroll: "animate",
        focus: "button",
        performFocus: !0
      });
    }
  }]);
  return ms;
}(c);
var us = new u(function (_ref40) {
    var s = _ref40.classes;
    return "\n  <div class=\"".concat(s.categoryButtonsContainer, "\">\n    <ul role=\"tablist\" class=\"").concat(s.categoryButtons, "\">\n      <div data-placeholder=\"tabs\"></div>\n    </ul>\n  </div>\n");
  }),
  ps = p("categoryButtons", "categoryButtonsContainer");
var gs = /*#__PURE__*/function (_c11) {
  _inherits(gs, _c11);
  function gs(_ref41) {
    var _this37;
    var e = _ref41.categories;
    _classCallCheck(this, gs);
    _this37 = _callSuper(this, gs, [{
      template: us,
      classes: ps
    }]), _this37.activeCategoryIndex = 0, _this37.categories = e;
    return _this37;
  }
  _createClass(gs, [{
    key: "initialize",
    value: function initialize() {
      this.keyBindings = {
        ArrowLeft: this.stepSelectedTab(-1),
        ArrowRight: this.stepSelectedTab(1)
      }, this.uiEvents = [c.uiEvent("scroll", this.checkOverflow)], _get(_getPrototypeOf(gs.prototype), "initialize", this).call(this);
    }
  }, {
    key: "checkOverflow",
    value: function checkOverflow() {
      var e = Math.abs(this.el.scrollLeft - (this.el.scrollWidth - this.el.offsetWidth)) > 1,
        t = this.el.scrollLeft > 0;
      this.el.className = "categoryButtonsContainer", t && e ? this.el.classList.add("has-overflow-both") : t ? this.el.classList.add("has-overflow-left") : e && this.el.classList.add("has-overflow-right");
    }
  }, {
    key: "renderSync",
    value: function renderSync() {
      var _this38 = this;
      return this.tabViews = this.categories.map(function (e) {
        return _this38.viewFactory.create(ms, {
          category: e,
          icon: O[e.key]
        });
      }), _get(_getPrototypeOf(gs.prototype), "renderSync", this).call(this, {
        tabs: this.tabViews.map(function (e) {
          return e.renderSync();
        })
      }), this.el;
    }
  }, {
    key: "currentCategory",
    get: function get() {
      return this.categories[this.activeCategoryIndex];
    }
  }, {
    key: "currentTabView",
    get: function get() {
      return this.tabViews[this.activeCategoryIndex];
    }
  }, {
    key: "setActiveTab",
    value: function setActiveTab(e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.checkOverflow();
      var o = this.currentTabView,
        i = this.tabViews[e];
      o.setActive(!1, t), i.setActive(!0, t), this.activeCategoryIndex = e;
    }
  }, {
    key: "getTargetCategory",
    value: function getTargetCategory(e) {
      return e < 0 ? this.categories.length - 1 : e >= this.categories.length ? 0 : e;
    }
  }, {
    key: "stepSelectedTab",
    value: function stepSelectedTab(e) {
      var _this39 = this;
      return function () {
        var t = _this39.activeCategoryIndex + e;
        _this39.setActiveTab(_this39.getTargetCategory(t), {
          changeFocusable: !0,
          performFocus: !0
        });
      };
    }
  }]);
  return gs;
}(c);
var ys = [{
  version: 15,
  emoji: String.fromCodePoint(129768)
}, {
  version: 14,
  emoji: String.fromCodePoint(128733)
}, {
  version: 13,
  emoji: String.fromCodePoint(129729)
}, {
  version: 12,
  emoji: String.fromCodePoint(129449)
}, {
  version: 11,
  emoji: String.fromCodePoint(129463)
}, {
  version: 5,
  emoji: String.fromCodePoint(129322)
}, {
  version: 4,
  emoji: String.fromCodePoint(9877)
}, {
  version: 3,
  emoji: String.fromCodePoint(129314)
}, {
  version: 2,
  emoji: String.fromCodePoint(128488)
}, {
  version: 1,
  emoji: String.fromCodePoint(128512)
}];
function fs() {
  var e;
  var s = ys.find(function (t) {
    return vs(t.emoji);
  });
  return (e = s == null ? void 0 : s.version) != null ? e : 1;
}
function vs(s) {
  var e = document.createElement("canvas").getContext("2d");
  if (e) return e.textBaseline = "top", e.font = "32px Arial", e.fillText(s, 0, 0), e.getImageData(16, 16, 1, 1).data[0] !== 0;
}
function Y(s, e) {
  return Array.from({
    length: s
  }, function () {
    return e;
  }).join("");
}
function ws(_ref42) {
  var s = _ref42.showHeader,
    e = _ref42.classes;
  return s ? "\n    <header class=\"".concat(e.header, "\">\n      <div data-view=\"search\"></div>\n      <div data-view=\"categoryTabs\" data-render=\"sync\"></div>\n    </header>\n  ") : "";
}
function bs(s) {
  var e = s.classes,
    t = s.theme,
    _s$className = s.className,
    o = _s$className === void 0 ? "" : _s$className;
  return "\n    <div class=\"picmo__picker ".concat(e.picker, " ").concat(t, " ").concat(o, "\">\n      ").concat(ws(s), "\n      <div class=\"").concat(e.content, "\">\n        <div data-view=\"emojiArea\"></div>\n      </div>\n      <div data-view=\"preview\"></div>\n    </div>\n  ");
}
function Cs(s) {
  var e = s.emojiCount,
    t = s.classes,
    o = s.theme,
    i = s.className,
    r = s.categoryCount,
    a = function a(_ref43) {
      var d = _ref43.showSearch,
        h = _ref43.classes;
      return d ? "\n    <div class=\"".concat(h.searchSkeleton, "\">\n      <div class=\"").concat(h.searchInput, " ").concat(h.placeholder, "\"></div>\n    </div>\n  ") : "";
    },
    n = function n(_ref44) {
      var d = _ref44.showCategoryTabs,
        h = _ref44.classes;
      return d ? "\n    <div class=\"".concat(h.categoryTabsSkeleton, "\">\n      ").concat(Y(r, "<div class=\"".concat(h.placeholder, " ").concat(h.categoryTab, "\"></div>")), "\n    </div>\n  ") : "";
    },
    l = function l(_ref45) {
      var d = _ref45.showHeader,
        h = _ref45.classes;
      return d ? "\n    <header class=\"".concat(h.headerSkeleton, "\">\n      ").concat(a(s), "\n      ").concat(n(s), "\n    </header>\n  ") : "";
    },
    m = function m(_ref46) {
      var d = _ref46.showPreview,
        h = _ref46.classes;
      return d ? "\n    <div class=\"".concat(h.previewSkeleton, "\">\n      <div class=\"").concat(h.placeholder, " ").concat(h.previewEmoji, "\"></div>\n      <div class=\"").concat(h.placeholder, " ").concat(h.previewName, "\"></div>\n      <ul class=\"").concat(h.tagList, "\">\n        ").concat(Y(3, "<li class=\"".concat(h.placeholder, " ").concat(h.tag, "\"></li>")), "\n      </ul>\n    </div>\n  ") : "";
    };
  return "\n    <div class=\"picmo__picker ".concat(t.skeleton, " ").concat(t.picker, " ").concat(o, " ").concat(i, "\">\n      ").concat(l(s), "\n      <div class=\"").concat(t.contentSkeleton, "\">\n        <div class=\"").concat(t.placeholder, " ").concat(t.categoryName, "\"></div>\n        <div class=\"").concat(t.emojiGrid, "\">\n          ").concat(Y(e, "<div class=\"".concat(t.placeholder, " ").concat(t.emoji, "\"></div>")), "\n        </div>\n      </div>\n      ").concat(m(s), "\n    </div>\n  ");
}
var js = new u(function (s) {
    return s.isLoaded ? bs(s) : Cs(s);
  }),
  T = p("picker", "skeleton", "placeholder", "searchSkeleton", "searchInput", "categoryTabsSkeleton", "headerSkeleton", "categoryTab", "contentSkeleton", "categoryName", "emojiGrid", "emoji", "previewSkeleton", "previewEmoji", "previewName", "tagList", "tag", "overlay", "content", "fullHeight", "pluginContainer", "header"),
  R = {
    emojisPerRow: "--emojis-per-row",
    visibleRows: "--row-count",
    emojiSize: "--emoji-size"
  };
var _s = /*#__PURE__*/function (_c12) {
  _inherits(_s, _c12);
  function _s() {
    var _this40;
    _classCallCheck(this, _s);
    _this40 = _callSuper(this, _s, [{
      template: js,
      classes: T
    }]), _this40.pickerReady = !1, _this40.externalEvents = new Tt(), _this40.updaters = {
      styleProperty: function styleProperty(e) {
        return function (t) {
          return _this40.el.style.setProperty(R[e], t.toString());
        };
      },
      theme: function theme(e) {
        var t = _this40.options.theme,
          o = _this40.el.closest(".".concat(t));
        _this40.el.classList.remove(t), o == null || o.classList.remove(t), _this40.el.classList.add(e), o == null || o.classList.add(e);
      },
      className: function className(e) {
        _this40.options.className && _this40.el.classList.remove(_this40.options.className), _this40.el.classList.add(e);
      },
      emojisPerRow: _this40.updateStyleProperty.bind(_assertThisInitialized(_this40), "emojisPerRow"),
      emojiSize: _this40.updateStyleProperty.bind(_assertThisInitialized(_this40), "emojiSize"),
      visibleRows: _this40.updateStyleProperty.bind(_assertThisInitialized(_this40), "visibleRows")
    };
    return _this40;
  }
  _createClass(_s, [{
    key: "initialize",
    value: function initialize() {
      this.uiElements = {
        pickerContent: c.byClass(T.content),
        header: c.byClass(T.header)
      }, this.uiEvents = [c.uiEvent("keydown", this.handleKeyDown)], this.appEvents = {
        error: this.onError,
        reinitialize: this.reinitialize,
        "data:ready": this.onDataReady,
        "content:show": this.showContent,
        "variantPopup:hide": this.hideVariantPopup,
        "emoji:select": this.selectEmoji
      }, _get(_getPrototypeOf(_s.prototype), "initialize", this).call(this), this.options.recentsProvider;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var e, t;
      _get(_getPrototypeOf(_s.prototype), "destroy", this).call(this), (e = this.search) == null || e.destroy(), this.emojiArea.destroy(), (t = this.categoryTabs) == null || t.destroy(), this.events.removeAll(), this.externalEvents.removeAll();
    }
  }, {
    key: "clearRecents",
    value: function clearRecents() {
      this.options.recentsProvider.clear();
    }
  }, {
    key: "addEventListener",
    value: function addEventListener(e, t) {
      this.externalEvents.on(e, t);
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(e, t) {
      this.externalEvents.off(e, t);
    }
  }, {
    key: "initializePickerView",
    value: function initializePickerView() {
      this.pickerReady && (this.showContent(), this.emojiArea.reset(!1));
    }
  }, {
    key: "handleKeyDown",
    value: function handleKeyDown(e) {
      var t = e.ctrlKey || e.metaKey;
      e.key === "s" && t && this.search && (e.preventDefault(), this.search.focus());
    }
  }, {
    key: "buildChildViews",
    value: function buildChildViews() {
      return this.options.showPreview && (this.preview = this.viewFactory.create(rs)), this.options.showSearch && (this.search = this.viewFactory.create(cs, {
        categories: this.categories,
        emojiVersion: this.emojiVersion
      })), this.options.showCategoryTabs && (this.categoryTabs = this.viewFactory.create(gs, {
        categories: this.categories
      })), this.currentView = this.emojiArea = this.viewFactory.create(Qt, {
        categoryTabs: this.categoryTabs,
        categories: this.categories,
        emojiVersion: this.emojiVersion
      }), [this.preview, this.search, this.emojiArea, this.categoryTabs];
    }
  }, {
    key: "setStyleProperties",
    value: function setStyleProperties() {
      var _this41 = this;
      this.options.showSearch || this.el.style.setProperty("--search-height-full", "0px"), this.options.showCategoryTabs || (this.el.style.setProperty("--category-tabs-height", "0px"), this.el.style.setProperty("--category-tabs-offset", "0px")), this.options.showPreview || this.el.style.setProperty("--emoji-preview-height-full", "0px"), Object.keys(R).forEach(function (e) {
        _this41.options[e] && _this41.el.style.setProperty(R[e], _this41.options[e].toString());
      });
    }
  }, {
    key: "updateStyleProperty",
    value: function updateStyleProperty(e, t) {
      this.el.style.setProperty(R[e], t.toString());
    }
  }, {
    key: "reinitialize",
    value: function reinitialize() {
      this.renderSync();
    }
  }, {
    key: "onError",
    value: function onError(e) {
      var t = this.viewFactory.createWithOptions({
          data: !1
        }, ss, {
          message: this.i18n.get("error.load")
        }),
        o = this.el.offsetHeight || 375;
      throw this.el.style.height = "".concat(o, "px"), w(this.el, t.renderSync()), e;
    }
  }, {
    key: "onDataReady",
    value: function () {
      var _onDataReady = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(e) {
        var t, _this$buildChildViews, _this$buildChildViews2, o, i, r, a;
        return _regeneratorRuntime().wrap(function _callee31$(_context31) {
          while (1) switch (_context31.prev = _context31.next) {
            case 0:
              t = this.el;
              _context31.prev = 1;
              if (!e) {
                _context31.next = 6;
                break;
              }
              this.emojiData = e;
              _context31.next = 8;
              break;
            case 6:
              _context31.next = 8;
              return this.emojiDataPromise;
            case 8:
              this.options.emojiVersion === "auto" ? this.emojiVersion = fs() || parseFloat(Ve) : this.emojiVersion = this.options.emojiVersion;
              _context31.next = 11;
              return this.emojiData.getCategories(this.options);
            case 11:
              this.categories = _context31.sent;
              _this$buildChildViews = this.buildChildViews(), _this$buildChildViews2 = _slicedToArray(_this$buildChildViews, 4), o = _this$buildChildViews2[0], i = _this$buildChildViews2[1], r = _this$buildChildViews2[2], a = _this$buildChildViews2[3];
              _context31.next = 15;
              return _get(_getPrototypeOf(_s.prototype), "render", this).call(this, {
                isLoaded: !0,
                search: i,
                categoryTabs: a,
                emojiArea: r,
                preview: o,
                showHeader: Boolean(this.search || this.categoryTabs),
                theme: this.options.theme,
                className: this.options.className
              });
            case 15:
              this.el.style.setProperty("--category-count", this.categories.length.toString());
              this.pickerReady = !0;
              t.replaceWith(this.el);
              this.setStyleProperties();
              this.initializePickerView();
              this.setInitialFocus();
              this.externalEvents.emit("data:ready");
              _context31.next = 27;
              break;
            case 24:
              _context31.prev = 24;
              _context31.t0 = _context31["catch"](1);
              this.events.emit("error", _context31.t0);
            case 27:
            case "end":
              return _context31.stop();
          }
        }, _callee31, this, [[1, 24]]);
      }));
      function onDataReady(_x49) {
        return _onDataReady.apply(this, arguments);
      }
      return onDataReady;
    }()
  }, {
    key: "renderSync",
    value: function renderSync() {
      var t;
      var e = ((t = this.options.categories) == null ? void 0 : t.length) || 10;
      if (this.options.showRecents && (e += 1), _get(_getPrototypeOf(_s.prototype), "renderSync", this).call(this, {
        isLoaded: !1,
        theme: this.options.theme,
        className: this.options.className,
        showSearch: this.options.showSearch,
        showPreview: this.options.showPreview,
        showCategoryTabs: this.options.showCategoryTabs,
        showHeader: this.options.showSearch || this.options.showCategoryTabs,
        emojiCount: this.options.emojisPerRow * this.options.visibleRows,
        categoryCount: e
      }), this.el.style.setProperty("--category-count", e.toString()), !this.options.rootElement) throw new Error("Picker must be given a root element via the rootElement option");
      return w(this.options.rootElement, this.el), this.setStyleProperties(), this.pickerReady && this.initializePickerView(), this.el;
    }
  }, {
    key: "getInitialFocusTarget",
    value: function getInitialFocusTarget() {
      if (_typeof(this.options.autoFocus) < "u") switch (this.options.autoFocus) {
        case "emojis":
          return this.emojiArea.focusableEmoji;
        case "search":
          return this.search;
        case "auto":
          return this.search || this.emojiArea.focusableEmoji;
        default:
          return null;
      }
      if (this.options.autoFocusSearch === !0) return console.warn("options.autoFocusSearch is deprecated, please use options.focusTarget instead"), this.search;
    }
  }, {
    key: "setInitialFocus",
    value: function setInitialFocus() {
      var e;
      !this.pickerReady || (e = this.getInitialFocusTarget()) == null || e.focus();
    }
  }, {
    key: "reset",
    value: function reset() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
      var t;
      this.pickerReady && (this.emojiArea.reset(e), this.showContent(this.emojiArea)), (t = this.search) == null || t.clear(), this.hideVariantPopup();
    }
  }, {
    key: "showContent",
    value: function showContent() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.emojiArea;
      var t, o;
      e !== this.currentView && (this.currentView !== this.emojiArea && ((t = this.currentView) == null || t.destroy()), this.ui.pickerContent.classList.toggle(T.fullHeight, e !== this.emojiArea), w(this.ui.pickerContent, e.el), this.currentView = e, e === this.emojiArea ? (this.emojiArea.reset(), this.categoryTabs && this.ui.header.appendChild(this.categoryTabs.el)) : (o = this.categoryTabs) == null || o.el.remove());
    }
  }, {
    key: "hideVariantPopup",
    value: function hideVariantPopup() {
      var e;
      (e = this.variantPopup) == null || e.destroy();
    }
  }, {
    key: "isPickerClick",
    value: function isPickerClick(e) {
      var r, a;
      var t = e.target,
        o = this.el.contains(t),
        i = (a = (r = this.variantPopup) == null ? void 0 : r.el) == null ? void 0 : a.contains(t);
      return o || i;
    }
  }, {
    key: "selectEmoji",
    value: function () {
      var _selectEmoji = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32(_ref47) {
        var e, t, o;
        return _regeneratorRuntime().wrap(function _callee32$(_context32) {
          while (1) switch (_context32.prev = _context32.next) {
            case 0:
              e = _ref47.emoji;
              if (!(((t = e.skins) == null ? void 0 : t.length) && this.options.showVariants && !this.isVariantPopupOpen)) {
                _context32.next = 5;
                break;
              }
              this.showVariantPopup(e);
              _context32.next = 10;
              break;
            case 5:
              _context32.next = 7;
              return (o = this.variantPopup) == null ? void 0 : o.animateHide();
            case 7:
              this.events.emit("variantPopup:hide");
              _context32.next = 10;
              return this.emitEmoji(e);
            case 10:
            case "end":
              return _context32.stop();
          }
        }, _callee32, this);
      }));
      function selectEmoji(_x50) {
        return _selectEmoji.apply(this, arguments);
      }
      return selectEmoji;
    }()
  }, {
    key: "isVariantPopupOpen",
    get: function get() {
      return this.variantPopup && !this.variantPopup.isDestroyed;
    }
  }, {
    key: "showVariantPopup",
    value: function () {
      var _showVariantPopup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee33(e) {
        var t;
        return _regeneratorRuntime().wrap(function _callee33$(_context33) {
          while (1) switch (_context33.prev = _context33.next) {
            case 0:
              t = document.activeElement;
              this.events.once("variantPopup:hide", function () {
                t == null || t.focus();
              }), this.variantPopup = this.viewFactory.create(hs, {
                emoji: e,
                parent: this.el
              }), this.el.appendChild(this.variantPopup.renderSync()), this.variantPopup.activate();
            case 2:
            case "end":
              return _context33.stop();
          }
        }, _callee33, this);
      }));
      function showVariantPopup(_x51) {
        return _showVariantPopup.apply(this, arguments);
      }
      return showVariantPopup;
    }()
  }, {
    key: "emitEmoji",
    value: function () {
      var _emitEmoji = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee34(e) {
        return _regeneratorRuntime().wrap(function _callee34$(_context34) {
          while (1) switch (_context34.prev = _context34.next) {
            case 0:
              _context34.t0 = this.externalEvents;
              _context34.next = 3;
              return this.renderer.doEmit(e);
            case 3:
              _context34.t1 = _context34.sent;
              _context34.t0.emit.call(_context34.t0, "emoji:select", _context34.t1);
              this.options.recentsProvider.addOrUpdateRecent(e, this.options.maxRecents);
              this.events.emit("recent:add", e);
            case 7:
            case "end":
              return _context34.stop();
          }
        }, _callee34, this);
      }));
      function emitEmoji(_x52) {
        return _emitEmoji.apply(this, arguments);
      }
      return emitEmoji;
    }()
  }, {
    key: "updateOptions",
    value: function updateOptions(e) {
      var _this42 = this;
      Object.keys(e).forEach(function (t) {
        _this42.updaters[t](e[t]);
      }), Object.assign(this.options, e);
    }
  }]);
  return _s;
}(c);
var ks = /*#__PURE__*/function () {
  function ks(_ref48) {
    var e = _ref48.events,
      t = _ref48.i18n,
      o = _ref48.renderer,
      i = _ref48.emojiData,
      r = _ref48.options,
      _ref48$customEmojis = _ref48.customEmojis,
      a = _ref48$customEmojis === void 0 ? [] : _ref48$customEmojis,
      n = _ref48.pickerId;
    _classCallCheck(this, ks);
    this.events = e, this.i18n = t, this.renderer = o, this.emojiData = i, this.options = r, this.customEmojis = a, this.pickerId = n;
  }
  _createClass(ks, [{
    key: "setEmojiData",
    value: function setEmojiData(e) {
      this.emojiData = Promise.resolve(e);
    }
  }, {
    key: "createWithOptions",
    value: function createWithOptions() {
      var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var t = arguments.length > 1 ? arguments[1] : undefined;
      for (var _len7 = arguments.length, o = new Array(_len7 > 2 ? _len7 - 2 : 0), _key7 = 2; _key7 < _len7; _key7++) {
        o[_key7 - 2] = arguments[_key7];
      }
      var i = _construct(t, o);
      return i.setPickerId(this.pickerId), i.setEvents(this.events), i.setI18n(this.i18n), i.setRenderer(this.renderer), e.data !== !1 && i.setEmojiData(this.emojiData), i.setOptions(this.options), i.setCustomEmojis(this.customEmojis), i.viewFactory = this, i.initialize(), i;
    }
  }, {
    key: "create",
    value: function create(e) {
      for (var _len8 = arguments.length, t = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
        t[_key8 - 1] = arguments[_key8];
      }
      return this.createWithOptions.apply(this, [{}, e].concat(t));
    }
  }]);
  return ks;
}();
var L;
var xs = /*#__PURE__*/function () {
  function xs() {
    var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, xs);
    f(this, L, void 0);
    A(this, L, new Map(Object.entries(e)));
  }
  _createClass(xs, [{
    key: "get",
    value: function get(e) {
      var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e;
      return y(this, L).get(e) || t;
    }
  }]);
  return xs;
}();
L = new WeakMap();
function Es(s, e) {
  e === void 0 && (e = {});
  var t = e.insertAt;
  if (!(!s || (typeof document === "undefined" ? "undefined" : _typeof(document)) > "u")) {
    var o = document.head || document.getElementsByTagName("head")[0],
      i = document.createElement("style");
    i.type = "text/css", t === "top" && o.firstChild ? o.insertBefore(i, o.firstChild) : o.appendChild(i), i.styleSheet ? i.styleSheet.cssText = s : i.appendChild(document.createTextNode(s));
  }
}
function Ss() {
  var s = !1;
  return function (t) {
    At.injectStyles && !s && (Es(t), s = !0);
  };
}
var Fs = ".picmo__picker .picmo__icon{width:1.25em;height:1em;fill:currentColor}.picmo__icon-small{font-size:.8em}.picmo__icon-medium{font-size:1em}.picmo__icon-large{font-size:1.25em}.picmo__icon-2x{font-size:2em}.picmo__icon-3x{font-size:3em}.picmo__icon-4x{font-size:4em}.picmo__icon-5x{font-size:5em}.picmo__icon-8x{font-size:8em}.picmo__icon-10x{font-size:10em}.picmo__light,.picmo__auto{color-scheme:light;--accent-color: #4f46e5;--background-color: #f9fafb;--border-color: #cccccc;--category-name-background-color: #f9fafb;--category-name-button-color: #999999;--category-name-text-color: hsl(214, 30%, 50%);--category-tab-active-background-color: rgba(255, 255, 255, .6);--category-tab-active-color: var(--accent-color);--category-tab-color: #666;--category-tab-highlight-background-color: rgba(0, 0, 0, .15);--error-color-dark: hsl(0, 100%, 45%);--error-color: hsl(0, 100%, 40%);--focus-indicator-background-color: hsl(198, 65%, 85%);--focus-indicator-color: #333333;--hover-background-color: #c7d2fe;--placeholder-background-color: #cccccc;--search-background-color: #f9fafb;--search-focus-background-color: #ffffff;--search-icon-color: #999999;--search-placeholder-color: #71717a;--secondary-background-color: #e2e8f0;--secondary-text-color: #666666;--tag-background-color: rgba(162, 190, 245, .3);--text-color: #000000;--variant-popup-background-color: #ffffff}.picmo__dark{color-scheme:dark;--accent-color: #A580F9;--background-color: #333333;--border-color: #666666;--category-name-background-color: #333333;--category-name-button-color: #eeeeee;--category-name-text-color: #ffffff;--category-tab-active-background-color: #000000;--category-tab-active-color: var(--accent-color);--category-tab-color: #cccccc;--category-tab-highlight-background-color: #4A4A4A;--error-color-dark: hsl(0, 7%, 3%);--error-color: hsl(0, 30%, 60%);--focus-indicator-background-color: hsl(0, 0%, 50%);--focus-indicator-color: #999999;--hover-background-color: hsla(0, 0%, 40%, .85);--image-placeholder-color: #ffffff;--placeholder-background-color: #666666;--search-background-color: #71717a;--search-focus-background-color: #52525b;--search-icon-color: #cccccc;--search-placeholder-color: #d4d4d8;--secondary-background-color: #000000;--secondary-text-color: #999999;--tag-background-color: rgba(162, 190, 245, .3);--text-color: #ffffff;--variant-popup-background-color: #333333}@media (prefers-color-scheme: dark){.picmo__auto{color-scheme:dark;--accent-color: #A580F9;--background-color: #333333;--border-color: #666666;--category-name-background-color: #333333;--category-name-button-color: #eeeeee;--category-name-text-color: #ffffff;--category-tab-active-background-color: #000000;--category-tab-active-color: var(--accent-color);--category-tab-color: #cccccc;--category-tab-highlight-background-color: #4A4A4A;--error-color-dark: hsl(0, 7%, 3%);--error-color: hsl(0, 30%, 60%);--focus-indicator-background-color: hsl(0, 0%, 50%);--focus-indicator-color: #999999;--hover-background-color: hsla(0, 0%, 40%, .85);--image-placeholder-color: #ffffff;--placeholder-background-color: #666666;--search-background-color: #71717a;--search-focus-background-color: #52525b;--search-icon-color: #cccccc;--search-placeholder-color: #d4d4d8;--secondary-background-color: #000000;--secondary-text-color: #999999;--tag-background-color: rgba(162, 190, 245, .3);--text-color: #ffffff;--variant-popup-background-color: #333333}}.picmo__picker .picmo__categoryButtonsContainer{overflow:auto;padding:2px 0}.picmo__picker .picmo__categoryButtonsContainer.picmo__has-overflow-right{mask-image:linear-gradient(270deg,rgba(255,255,255,0) 0%,rgba(255,255,255,1) 10%);-webkit-mask-image:linear-gradient(270deg,rgba(255,255,255,0) 0%,rgba(255,255,255,1) 10%)}.picmo__picker .picmo__categoryButtonsContainer.picmo__has-overflow-left{mask-image:linear-gradient(90deg,rgba(255,255,255,0) 0%,rgba(255,255,255,1) 10%);-webkit-mask-image:linear-gradient(90deg,rgba(255,255,255,0) 0%,rgba(255,255,255,1) 10%)}.picmo__picker .picmo__categoryButtonsContainer.picmo__has-overflow-both{mask-image:linear-gradient(90deg,rgba(255,255,255,0) 0%,rgba(255,255,255,1) 10%,rgba(255,255,255,1) 90%,rgba(255,255,255,0) 100%);-webkit-mask-image:linear-gradient(90deg,rgba(255,255,255,0) 0%,rgba(255,255,255,1) 10%,rgba(255,255,255,1) 90%,rgba(255,255,255,0) 100%)}.picmo__picker .picmo__categoryButtons{display:flex;flex-direction:row;gap:var(--tab-gap);margin:0;padding:0 .5em;align-items:center;height:var(--category-tabs-height);box-sizing:border-box;width:100%;justify-content:space-between;position:relative;list-style-type:none;justify-self:center;max-width:min(23.55rem,calc(var(--category-count, 1) * 2.5rem))}.picmo__picker .picmo__categoryButtons .picmo__categoryTab{display:flex;align-items:center;transition:all .1s;width:2em}.picmo__picker .picmo__categoryButtons .picmo__categoryTab.picmo__categoryTabActive .picmo__categoryButton{color:var(--category-tab-active-color);background:linear-gradient(rgba(255,255,255,.75) 0%,rgba(255,255,255,.75) 100%),linear-gradient(var(--category-tab-active-color) 0%,var(--category-tab-active-color) 100%);border:2px solid var(--category-tab-active-color)}.picmo__picker .picmo__categoryButtons .picmo__categoryTab.picmo__categoryTabActive .picmo__categoryButton:hover{background-color:var(--category-tab-active-background-color)}.picmo__picker .picmo__categoryButtons .picmo__categoryTab button.picmo__categoryButton{border-radius:5px;background:transparent;border:2px solid transparent;color:var(--category-tab-color);cursor:pointer;padding:2px;vertical-align:middle;display:flex;align-items:center;justify-content:center;font-size:1.2rem;width:1.6em;height:1.6em;transition:all .1s}.picmo__picker .picmo__categoryButtons .picmo__categoryTab button.picmo__categoryButton:is(img){width:var(--category-tab-size);height:var(--category-tab-size)}.picmo__picker .picmo__categoryButtons .picmo__categoryTab button.picmo__categoryButton:hover{background:var(--category-tab-highlight-background-color)}.picmo__dataError [data-icon]{opacity:.8}@keyframes appear{0%{opacity:0}to{opacity:.8}}@keyframes appear-grow{0%{opacity:0;transform:scale(.8)}to{opacity:.8;transform:scale(1)}}.picmo__picker .picmo__error{display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;color:var(--secondary-text-color)}.picmo__picker .picmo__error .picmo__iconContainer{opacity:.8;animation:appear-grow .25s cubic-bezier(.175,.885,.32,1.275);--color-primary: var(--error-color);--color-secondary: var(--error-color-dark)}.picmo__picker .picmo__error .picmo__title{animation:appear .25s;animation-delay:50ms;animation-fill-mode:both}.picmo__picker .picmo__error button{padding:8px 16px;cursor:pointer;background:var(--background-color);border:1px solid var(--text-color);border-radius:5px;color:var(--text-color)}.picmo__picker .picmo__error button:hover{background:var(--text-color);color:var(--background-color)}.picmo__emojiButton{background:transparent;border:none;border-radius:15px;cursor:pointer;display:flex;font-family:var(--emoji-font);font-size:var(--emoji-size);height:100%;justify-content:center;align-items:center;margin:0;overflow:hidden;padding:0;width:100%}.picmo__emojiButton:hover{background:var(--hover-background-color)}.picmo__emojiButton:focus{border-radius:0;background:var(--focus-indicator-background-color);outline:1px solid var(--focus-indicator-color)}.picmo__picker .picmo__emojiArea{height:var(--emoji-area-height);overflow-y:auto;position:relative}.picmo__picker .picmo__emojiCategory{position:relative}.picmo__picker .picmo__emojiCategory .picmo__categoryName{font-size:.9em;padding:.5rem;margin:0;background:var(--category-name-background-color);color:var(--category-name-text-color);top:0;z-index:1;display:grid;gap:4px;grid-template-columns:auto 1fr auto;align-items:center;line-height:1;box-sizing:border-box;height:var(--category-name-height);justify-content:flex-start;text-transform:uppercase}.picmo__picker .picmo__emojiCategory .picmo__categoryName button{background:transparent;border:none;display:flex;align-items:center;cursor:pointer;color:var(--category-name-button-color)}.picmo__picker .picmo__emojiCategory .picmo__categoryName button:hover{opacity:1}.picmo__picker .picmo__emojiCategory .picmo__noRecents{color:var(--secondary-text-color);grid-column:1 / span var(--emojis-per-row);font-size:.9em;text-align:center;display:flex;align-items:center;justify-content:center;min-height:calc(var(--emoji-size) * var(--emoji-size-multiplier))}.picmo__picker .picmo__emojiCategory .picmo__recentEmojis[data-empty=true]{display:none}:is(.picmo__picker .picmo__emojiCategory) .picmo__recentEmojis[data-empty=false]+div{display:none}.picmo__picker .picmo__emojiContainer{display:grid;justify-content:space-between;gap:1px;padding:0 .5em;grid-template-columns:repeat(var(--emojis-per-row),calc(var(--emoji-size) * var(--emoji-size-multiplier)));grid-auto-rows:calc(var(--emoji-size) * var(--emoji-size-multiplier));align-items:center;justify-items:center}.picmo__picker.picmo__picker{--border-radius: 5px;--emoji-area-height: calc( (var(--row-count) * var(--emoji-size) * var(--emoji-size-multiplier)) + var(--category-name-height) );--content-height: var(--emoji-area-height);--emojis-per-row: 8;--row-count: 6;--emoji-preview-margin: 4px;--emoji-preview-height: calc(var(--emoji-preview-size) + 1em + 1px);--emoji-preview-height-full: calc(var(--emoji-preview-height) + var(--emoji-preview-margin));--emoji-preview-size: 2.75em;--emoji-size: 2rem;--emoji-size-multiplier: 1.3;--content-margin: 8px;--category-tabs-height:calc(1.5em + 9px);--category-tabs-offset: 8px;--category-tab-size: 1.2rem;--category-name-height: 2rem;--category-name-padding-y: 6px;--search-height: 2em;--search-margin: .5em;--search-margin-bottom: 4px;--search-height-full: calc(var(--search-height) + var(--search-margin) + var(--search-margin-bottom));--overlay-background-color: rgba(0, 0, 0, .8);--emoji-font: \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Segoe UI\", \"Apple Color Emoji\", \"Twemoji Mozilla\", \"Noto Color Emoji\", \"EmojiOne Color\", \"Android Emoji\";--ui-font: -apple-system, BlinkMacSystemFont, \"Helvetica Neue\", sans-serif;--ui-font-size: 16px;--picker-width: calc(var(--emojis-per-row) * var(--emoji-size) * var(--emoji-size-multiplier) + 2.75rem);--preview-background-color: var(--secondary-background-color);background:var(--background-color);border-radius:var(--border-radius);border:1px solid var(--border-color);font-family:var(--ui-font);font-size:var(--ui-font-size);overflow:hidden;position:relative;width:var(--picker-width);display:grid;gap:8px}.picmo__picker.picmo__picker>*{font-family:var(--ui-font)}.picmo__picker.picmo__skeleton{background:var(--background-color);border-radius:var(--border-radius);border:1px solid var(--border-color);font-family:var(--ui-font);width:var(--picker-width);color:var(--secondary-text-color)}.picmo__picker.picmo__skeleton *{box-sizing:border-box}.picmo__picker.picmo__skeleton .picmo__placeholder{background:var(--placeholder-background-color);position:relative;overflow:hidden}.picmo__picker.picmo__skeleton .picmo__placeholder:after{position:absolute;top:0;right:0;bottom:0;left:0;transform:translate(-100%);background-image:linear-gradient(90deg,rgba(255,255,255,0) 0,rgba(255,255,255,.2) 20%,rgba(255,255,255,.5) 60%,rgba(255,255,255,0) 100%);animation:shine 2s infinite;content:\"\"}.picmo__picker.picmo__skeleton .picmo__headerSkeleton{background-color:var(--secondary-background-color);padding-top:8px;padding-bottom:8px;display:flex;flex-direction:column;overflow:hidden;gap:8px;border-bottom:1px solid var(--border-color);width:var(--picker-width)}.picmo__picker.picmo__skeleton .picmo__searchSkeleton{padding:0 8px;height:var(--search-height)}.picmo__picker.picmo__skeleton .picmo__searchSkeleton .picmo__searchInput{width:100%;height:28px;border-radius:3px}.picmo__picker.picmo__skeleton .picmo__categoryTabsSkeleton{height:var(--category-tabs-height);display:flex;flex-direction:row;align-items:center;justify-self:center;width:calc(2rem * var(--category-count, 1))}.picmo__picker.picmo__skeleton .picmo__categoryTabsSkeleton .picmo__categoryTab{width:25px;height:25px;padding:2px;border-radius:5px;margin:.25em}.picmo__picker.picmo__skeleton .picmo__contentSkeleton{height:var(--content-height);padding-right:8px;opacity:.7}.picmo__picker.picmo__skeleton .picmo__contentSkeleton .picmo__categoryName{width:50%;height:1rem;margin:.5rem;box-sizing:border-box}.picmo__picker.picmo__skeleton .picmo__contentSkeleton .picmo__emojiGrid{display:grid;justify-content:space-between;gap:1px;padding:0 .5em;grid-template-columns:repeat(var(--emojis-per-row),calc(var(--emoji-size) * var(--emoji-size-multiplier)));grid-auto-rows:calc(var(--emoji-size) * var(--emoji-size-multiplier));align-items:center;justify-items:center;width:var(--picker-width)}.picmo__picker.picmo__skeleton .picmo__contentSkeleton .picmo__emojiGrid .picmo__emoji{width:var(--emoji-size);height:var(--emoji-size);border-radius:50%}.picmo__picker.picmo__skeleton .picmo__previewSkeleton{height:var(--emoji-preview-height);border-top:1px solid var(--border-color);display:grid;align-items:center;padding:.5em;gap:6px;grid-template-columns:auto 1fr;grid-template-rows:auto 1fr;grid-template-areas:\"emoji name\" \"emoji tags\"}.picmo__picker.picmo__skeleton .picmo__previewSkeleton .picmo__previewEmoji{grid-area:emoji;border-radius:50%;width:var(--emoji-preview-size);height:var(--emoji-preview-size)}.picmo__picker.picmo__skeleton .picmo__previewSkeleton .picmo__previewName{grid-area:name;height:.8em;width:80%}.picmo__picker.picmo__skeleton .picmo__previewSkeleton .picmo__tagList{grid-area:tags;list-style-type:none;display:flex;flex-direction:row;padding:0;margin:0}.picmo__picker.picmo__skeleton .picmo__previewSkeleton .picmo__tagList .picmo__tag{border-radius:3px;padding:2px 8px;margin-right:.25em;height:1em;width:20%}.picmo__overlay{background:rgba(0,0,0,.75);height:100%;left:0;position:fixed;top:0;width:100%;z-index:1000}.picmo__content{position:relative;overflow:hidden;height:var(--content-height)}.picmo__content.picmo__fullHeight{height:calc(var(--content-height) + var(--category-tabs-height) + var(--category-tabs-offset));overflow-y:auto}.picmo__pluginContainer{margin:.5em;display:flex;flex-direction:row}.picmo__header{background-color:var(--secondary-background-color);padding-top:8px;padding-bottom:8px;display:grid;gap:8px;border-bottom:1px solid var(--border-color)}@media (prefers-reduced-motion: reduce){.picmo__placeholder{background:var(--placeholder-background-color);position:relative;overflow:hidden}.picmo__placeholder:after{display:none}}.picmo__picker .picmo__preview{border-top:1px solid var(--border-color);display:grid;align-items:center;gap:6px;grid-template-columns:auto 1fr;grid-template-rows:auto 1fr;grid-template-areas:\"emoji name\" \"emoji tags\";height:var(--emoji-preview-height);box-sizing:border-box;padding:.5em;position:relative;background:var(--preview-background-color)}.picmo__picker .picmo__preview .picmo__previewEmoji{grid-area:emoji;font-size:var(--emoji-preview-size);font-family:var(--emoji-font);width:1.25em;display:flex;align-items:center;justify-content:center}.picmo__picker .picmo__preview .picmo__previewName{grid-area:name;color:var(--text-color);font-size:.8em;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-weight:500}.picmo__picker .picmo__preview .picmo__tagList{grid-area:tags;list-style-type:none;display:flex;flex-direction:row;padding:0;margin:0;font-size:.75em;overflow:hidden}.picmo__picker .picmo__preview .picmo__tag{border-radius:3px;background:var(--tag-background-color);color:var(--text-color);padding:2px 8px;margin-right:.25em;white-space:nowrap}.picmo__picker .picmo__preview .picmo__tag:last-child{margin-right:0}.picmo__picker .picmo__searchContainer{display:flex;height:var(--search-height);box-sizing:border-box;padding:0 8px;position:relative}.picmo__picker .picmo__searchContainer .picmo__searchField{background:var(--search-background-color);border-radius:3px;border:none;box-sizing:border-box;color:var(--text-color);font-size:.9em;outline:none;padding:.5em 2.25em .5em .5em;width:100%}.picmo__picker .picmo__searchContainer .picmo__searchField:focus{background:var(--search-focus-background-color)}.picmo__picker .picmo__searchContainer .picmo__searchField::placeholder{color:var(--search-placeholder-color)}.picmo__picker .picmo__searchContainer .picmo__searchAccessory{color:var(--search-icon-color);height:100%;position:absolute;right:1em;top:0;width:1.25rem;display:flex;align-items:center}.picmo__picker .picmo__searchContainer .picmo__searchAccessory svg{fill:var(--search-icon-color)}.picmo__picker .picmo__searchContainer .picmo__clearButton{border:0;color:var(--search-icon-color);background:transparent;cursor:pointer}.picmo__picker .picmo__searchContainer .picmo__clearSearchButton{cursor:pointer;border:none;background:transparent;color:var(--search-icon-color);font-size:1em;width:100%;height:100%;display:flex;align-items:center;padding:0}.picmo__picker .picmo__searchContainer .picmo__notFound [data-icon]{fill:#f3e265}.picmo__picker .picmo__variantOverlay{background:var(--overlay-background-color);border-radius:5px;display:flex;flex-direction:column;height:100%;justify-content:center;left:0;position:absolute;top:0;width:100%;z-index:1}.picmo__picker .picmo__variantOverlay .picmo__variantPopup{background:var(--variant-popup-background-color);border-radius:5px;margin:.5em;padding:.5em;text-align:center;user-select:none;display:flex;align-items:center;justify-content:center}.picmo__customEmoji{width:1em;height:1em}@keyframes shine{to{transform:translate(100%)}}.picmo__picker .picmo__imagePlaceholder{width:2rem;height:2rem;border-radius:50%}.picmo__placeholder{background:#DDDBDD;position:relative}.picmo__placeholder:after{position:absolute;top:0;right:0;bottom:0;left:0;transform:translate(-100%);background-image:linear-gradient(90deg,rgba(255,255,255,0) 0,rgba(255,255,255,.2) 20%,rgba(255,255,255,.5) 60%,rgba(255,255,255,0) 100%);animation:shine 2s infinite;content:\"\"}\n";
function Ps(s) {
  return ce(s.locale, s.dataStore, s.messages, s.emojiData);
}
var zs = 0,
  M;
function Ls() {
  return "picmo-".concat(Date.now(), "-").concat(zs++);
}
var $s = Ss();
function Hs(s) {
  $s(Fs);
  var e = $t(s),
    t = ((e == null ? void 0 : e.custom) || []).map(function (n) {
      return _objectSpread(_objectSpread({}, n), {}, {
        custom: !0,
        tags: ["custom"].concat(_toConsumableArray(n.tags || []))
      });
    }),
    o = new It();
  M || (M = Ps(e));
  var i = new xs(e.i18n);
  M.then(function (n) {
    o.emit("data:ready", n);
  })["catch"](function (n) {
    o.emit("error", n);
  });
  var a = new ks({
    events: o,
    i18n: i,
    customEmojis: t,
    renderer: e.renderer,
    options: e,
    emojiData: M,
    pickerId: Ls()
  }).create(_s);
  return a.renderSync(), a;
}
var As = {
    "categories.activities": "Aktivit\xE4ten",
    "categories.animals-nature": "Tiere & Natur",
    "categories.custom": "Benutzerdefiniert",
    "categories.flags": "Flaggen",
    "categories.food-drink": "Essen & Trinken",
    "categories.objects": "Gegenst\xE4nde",
    "categories.people-body": "Mensch & K\xF6rper",
    "categories.recents": "Zuletzt genutzt",
    "categories.smileys-emotion": "Smileys & Emotionen",
    "categories.symbols": "Symbole",
    "categories.travel-places": "Reisen & Orte",
    "error.load": "Emojis wurden nicht geladen",
    "recents.clear": "Zuletzt genutzte Emojis l\xF6schen",
    "recents.none": "Kein Emoji ausgew\xE4hlt.",
    retry: "Erneut versuchen",
    "search.clear": "Suche l\xF6schen",
    "search.error": "Suche erfolglos",
    "search.notFound": "Kein Emoji gefunden",
    search: "Emojis durchsuchen ..."
  },
  Is = {
    "categories.activities": "Aktiviteetit",
    "categories.animals-nature": "El\xE4imet & luonto",
    "categories.custom": "Mukautettu",
    "categories.flags": "Liput",
    "categories.food-drink": "Ruoka & juoma",
    "categories.objects": "Esineet",
    "categories.people-body": "Ihmiset & keho",
    "categories.recents": "Viimeksi k\xE4ytetty",
    "categories.smileys-emotion": "Hymi\xF6t & tunne",
    "categories.symbols": "Symbolit",
    "categories.travel-places": "Matkustus & paikat",
    "error.load": "Emojien lataaminen ep\xE4onnistui",
    "recents.clear": "Tyhjenn\xE4 viimeksi k\xE4ytetyt emojit",
    "recents.none": "Et ole valinnut viel\xE4 emojia.",
    retry: "Kokeile uudestaan",
    "search.clear": "Tyhjenn\xE4 haku",
    "search.error": "Emojien etsiminen ep\xE4onnistui",
    "search.notFound": "Emojia ei l\xF6ytynyt",
    search: "Etsi emojia..."
  },
  Ts = {
    "categories.activities": "Activit\xE9s",
    "categories.animals-nature": "Animaux et nature",
    "categories.custom": "Personnalis\xE9",
    "categories.flags": "Drapeaux",
    "categories.food-drink": "Nourriture et boissons",
    "categories.objects": "Objets",
    "categories.people-body": "Personnes et corps",
    "categories.recents": "R\xE9cemment utilis\xE9",
    "categories.smileys-emotion": "Visages et \xE9motions",
    "categories.symbols": "Symboles",
    "categories.travel-places": "Voyages et lieux",
    "error.load": "\xC9chec du chargement des \xE9mojis",
    "recents.clear": "Effacez les \xE9mojis r\xE9cents",
    "recents.none": "Vous n'avez pas encore s\xE9lectionn\xE9 d'\xE9mojis.",
    retry: "Essayez \xE0 nouveau",
    "search.clear": "Effacer la recherche",
    "search.error": "\xC9chec de la recherche d'\xE9mojis",
    "search.notFound": "Aucun \xE9moji trouv\xE9",
    search: "Rechercher des \xE9mojis..."
  },
  Rs = {
    "categories.activities": "Activiteiten",
    "categories.animals-nature": "Dieren & Natuur",
    "categories.custom": "Aangepast",
    "categories.flags": "Vlaggen",
    "categories.food-drink": "Eten & Drinken",
    "categories.objects": "Voorwerpen",
    "categories.people-body": "Mens & Lichaam",
    "categories.recents": "Laatst gebruikt",
    "categories.smileys-emotion": "Smileys en emoties",
    "categories.symbols": "Symbolen",
    "categories.travel-places": "Reizen & Plaatsen",
    "error.load": "Kan emoji's niet laden",
    "recents.clear": "Wis recente emoji's",
    "recents.none": "Geen emoji geselecteerd.",
    retry: "Probeer het nog eens",
    "search.clear": "Zoekopdracht wissen",
    "search.error": "Zoeken mislukt",
    "search.notFound": "Geen emoji gevonden",
    search: "Zoek emoji..."
  },
  Ms = {
    "categories.activities": "Aktiviteter",
    "categories.animals-nature": "Dyr & natur",
    "categories.custom": "Tilpasset",
    "categories.flags": "Flagg",
    "categories.food-drink": "Mat & drikke",
    "categories.objects": "Objekter",
    "categories.people-body": "Mennesker & kropp",
    "categories.recents": "Nylig brukte",
    "categories.smileys-emotion": "Smilefjes & f\xF8lelser",
    "categories.symbols": "Symboler",
    "categories.travel-places": "Reise & steder",
    "error.load": "Klarte ikke laste inn emojis",
    "recents.clear": "Fjern nylige emojis",
    "recents.none": "Du har ikke valgt noen emojis enda.",
    retry: "Pr\xF8v igjen",
    "search.clear": "T\xF8m s\xF8k",
    "search.error": "Klarte ikke \xE5 s\xF8ke etter emojis",
    "search.notFound": "Ingen emojis funnet",
    search: "S\xF8k etter emojis..."
  },
  Vs = {
    "categories.activities": "Aktiviteter",
    "categories.animals-nature": "Djur & natur",
    "categories.custom": "Anpassad",
    "categories.flags": "Flagga",
    "categories.food-drink": "Mat & dryck",
    "categories.objects": "Objekt",
    "categories.people-body": "M\xE4nniskor & kropp",
    "categories.recents": "Nyligen anv\xE4nd",
    "categories.smileys-emotion": "Hum\xF6r & k\xE4nslor",
    "categories.symbols": "Symboler",
    "categories.travel-places": "Resor & platser",
    "error.load": "Det gick inte att ladda emojis",
    "recents.clear": "Ta bort de senaste emojis",
    "recents.none": "Du har inte valt n\xE5gra emojis \xE4n",
    retry: "F\xF6rs\xF6k igen",
    "search.clear": "Tom s\xF6kning",
    "search.error": "Det gick inte att s\xF6ka efter emojis",
    "search.notFound": "Inga emojis hittades",
    search: "S\xF6k efter emojis..."
  },
  Ks = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({
    __proto__: null,
    de: As,
    en: ze,
    fi: Is,
    fr: Ts,
    nl: Rs,
    no: Ms,
    sv: Vs
  }, Symbol.toStringTag, {
    value: "Module"
  }));
var Us = /*#__PURE__*/function (_Ie2) {
  _inherits(Us, _Ie2);
  function Us() {
    _classCallCheck(this, Us);
    return _callSuper(this, Us, [xe() ? sessionStorage : $e()]);
  }
  return _createClass(Us);
}(Ie);
var qs = /*#__PURE__*/function (_Ae2) {
  _inherits(qs, _Ae2);
  function qs() {
    var _this43;
    _classCallCheck(this, qs);
    _this43 = _callSuper(this, qs, arguments), _this43.recents = [];
    return _this43;
  }
  _createClass(qs, [{
    key: "clear",
    value: function clear() {
      this.recents = [];
    }
  }, {
    key: "getRecents",
    value: function getRecents(e) {
      return this.recents.slice(0, e);
    }
  }, {
    key: "addOrUpdateRecent",
    value: function addOrUpdateRecent(e, t) {
      this.recents = [e].concat(_toConsumableArray(this.getRecents(t).filter(function (o) {
        return o.hexcode !== e.hexcode;
      }))).slice(0, t);
    }
  }]);
  return qs;
}(Ae);
function Ws(_x53, _x54, _x55, _x56) {
  return _Ws.apply(this, arguments);
}
function _Ws() {
  _Ws = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee47(s, e, t, o) {
    return _regeneratorRuntime().wrap(function _callee47$(_context47) {
      while (1) switch (_context47.prev = _context47.next) {
        case 0:
          _context47.next = 2;
          return ce(s, e, t, o);
        case 2:
          _context47.sent.close();
        case 3:
        case "end":
          return _context47.stop();
      }
    }, _callee47);
  }));
  return _Ws.apply(this, arguments);
}


/***/ }),

/***/ "./node_modules/prosemirror-commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/prosemirror-commands/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   autoJoin: function() { return /* binding */ autoJoin; },
/* harmony export */   baseKeymap: function() { return /* binding */ baseKeymap; },
/* harmony export */   chainCommands: function() { return /* binding */ chainCommands; },
/* harmony export */   createParagraphNear: function() { return /* binding */ createParagraphNear; },
/* harmony export */   deleteSelection: function() { return /* binding */ deleteSelection; },
/* harmony export */   exitCode: function() { return /* binding */ exitCode; },
/* harmony export */   joinBackward: function() { return /* binding */ joinBackward; },
/* harmony export */   joinDown: function() { return /* binding */ joinDown; },
/* harmony export */   joinForward: function() { return /* binding */ joinForward; },
/* harmony export */   joinTextblockBackward: function() { return /* binding */ joinTextblockBackward; },
/* harmony export */   joinTextblockForward: function() { return /* binding */ joinTextblockForward; },
/* harmony export */   joinUp: function() { return /* binding */ joinUp; },
/* harmony export */   lift: function() { return /* binding */ lift; },
/* harmony export */   liftEmptyBlock: function() { return /* binding */ liftEmptyBlock; },
/* harmony export */   macBaseKeymap: function() { return /* binding */ macBaseKeymap; },
/* harmony export */   newlineInCode: function() { return /* binding */ newlineInCode; },
/* harmony export */   pcBaseKeymap: function() { return /* binding */ pcBaseKeymap; },
/* harmony export */   selectAll: function() { return /* binding */ selectAll; },
/* harmony export */   selectNodeBackward: function() { return /* binding */ selectNodeBackward; },
/* harmony export */   selectNodeForward: function() { return /* binding */ selectNodeForward; },
/* harmony export */   selectParentNode: function() { return /* binding */ selectParentNode; },
/* harmony export */   selectTextblockEnd: function() { return /* binding */ selectTextblockEnd; },
/* harmony export */   selectTextblockStart: function() { return /* binding */ selectTextblockStart; },
/* harmony export */   setBlockType: function() { return /* binding */ setBlockType; },
/* harmony export */   splitBlock: function() { return /* binding */ splitBlock; },
/* harmony export */   splitBlockAs: function() { return /* binding */ splitBlockAs; },
/* harmony export */   splitBlockKeepMarks: function() { return /* binding */ splitBlockKeepMarks; },
/* harmony export */   toggleMark: function() { return /* binding */ toggleMark; },
/* harmony export */   wrapIn: function() { return /* binding */ wrapIn; }
/* harmony export */ });
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.js");
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");




/**
Delete the selection, if there is one.
*/
var deleteSelection = function deleteSelection(state, dispatch) {
  if (state.selection.empty) return false;
  if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state, view) {
  var $cursor = state.selection.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0)) return null;
  return $cursor;
}
/**
If the selection is empty and at the start of a textblock, try to
reduce the distance between that block and the one before itif
there's a block directly before it that can be joined, join them.
If not, try to move the selected block closer to the next one in
the document structure by lifting it out of its parent or moving it
into a parent of the previous block. Will use the view for accurate
(bidi-aware) start-of-textblock detection if given.
*/
var joinBackward = function joinBackward(state, dispatch, view) {
  var $cursor = atBlockStart(state, view);
  if (!$cursor) return false;
  var $cut = findCutBefore($cursor);
  // If there is no node before this, try to lift
  if (!$cut) {
    var range = $cursor.blockRange(),
      target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);
    if (target == null) return false;
    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  var before = $cut.nodeBefore;
  // Apply the joining algorithm
  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch)) return true;
  // If the node below has no content and the node above is
  // selectable, delete the node below and select the one above.
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(before))) {
    var delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(), $cursor.after(), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        var tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(before, "end") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  // If the node before is an atom, delete it
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch) dispatch(state.tr["delete"]($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
/**
A more limited form of [`joinBackward`]($commands.joinBackward)
that only tries to join the current textblock to the one before
it, if the cursor is at the start of a textblock.
*/
var joinTextblockBackward = function joinTextblockBackward(state, dispatch, view) {
  var $cursor = atBlockStart(state, view);
  if (!$cursor) return false;
  var $cut = findCutBefore($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
/**
A more limited form of [`joinForward`]($commands.joinForward)
that only tries to join the current textblock to the one after
it, if the cursor is at the end of a textblock.
*/
var joinTextblockForward = function joinTextblockForward(state, dispatch, view) {
  var $cursor = atBlockEnd(state, view);
  if (!$cursor) return false;
  var $cut = findCutAfter($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};
function joinTextblocksAround(state, $cut, dispatch) {
  var before = $cut.nodeBefore,
    beforeText = before,
    beforePos = $cut.pos - 1;
  for (; !beforeText.isTextblock; beforePos--) {
    if (beforeText.type.spec.isolating) return false;
    var child = beforeText.lastChild;
    if (!child) return false;
    beforeText = child;
  }
  var after = $cut.nodeAfter,
    afterText = after,
    afterPos = $cut.pos + 1;
  for (; !afterText.isTextblock; afterPos++) {
    if (afterText.type.spec.isolating) return false;
    var _child = afterText.firstChild;
    if (!_child) return false;
    afterText = _child;
  }
  var step = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, beforePos, afterPos, prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);
  if (!step || step.from != beforePos || step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep && step.slice.size >= afterPos - beforePos) return false;
  if (dispatch) {
    var tr = state.tr.step(step);
    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, beforePos));
    dispatch(tr.scrollIntoView());
  }
  return true;
}
function textblockAt(node, side) {
  var only = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  for (var scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock) return true;
    if (only && scan.childCount != 1) return false;
  }
  return false;
}
/**
When the selection is empty and at the start of a textblock, select
the node before that textblock, if possible. This is intended to be
bound to keys like backspace, after
[`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward) or other deleting
commands, as a fall-back behavior when the schema doesn't allow
deletion at the selected point.
*/
var selectNodeBackward = function selectNodeBackward(state, dispatch, view) {
  var _state$selection = state.selection,
    $head = _state$selection.$head,
    empty = _state$selection.empty,
    $cut = $head;
  if (!empty) return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0) return false;
    $cut = findCutBefore($head);
  }
  var node = $cut && $cut.nodeBefore;
  if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) return false;
  if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating) for (var i = $pos.depth - 1; i >= 0; i--) {
    if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1));
    if ($pos.node(i).type.spec.isolating) break;
  }
  return null;
}
function atBlockEnd(state, view) {
  var $cursor = state.selection.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size)) return null;
  return $cursor;
}
/**
If the selection is empty and the cursor is at the end of a
textblock, try to reduce or remove the boundary between that block
and the one after it, either by joining them or by moving the other
block closer to this one in the tree structure. Will use the view
for accurate start-of-textblock detection if given.
*/
var joinForward = function joinForward(state, dispatch, view) {
  var $cursor = atBlockEnd(state, view);
  if (!$cursor) return false;
  var $cut = findCutAfter($cursor);
  // If there is no node after this, there's nothing to do
  if (!$cut) return false;
  var after = $cut.nodeAfter;
  // Try the joining algorithm
  if (deleteBarrier(state, $cut, dispatch)) return true;
  // If the node above has no content and the node below is
  // selectable, delete the node above and select the one below.
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(after))) {
    var delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(), $cursor.after(), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        var tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(after, "start") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  // If the next node is an atom, delete it
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch) dispatch(state.tr["delete"]($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
/**
When the selection is empty and at the end of a textblock, select
the node coming after that textblock, if possible. This is intended
to be bound to keys like delete, after
[`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward) and similar deleting
commands, to provide a fall-back behavior when the schema doesn't
allow deletion at the selected point.
*/
var selectNodeForward = function selectNodeForward(state, dispatch, view) {
  var _state$selection2 = state.selection,
    $head = _state$selection2.$head,
    empty = _state$selection2.empty,
    $cut = $head;
  if (!empty) return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size) return false;
    $cut = findCutAfter($head);
  }
  var node = $cut && $cut.nodeAfter;
  if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) return false;
  if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating) for (var i = $pos.depth - 1; i >= 0; i--) {
    var parent = $pos.node(i);
    if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1));
    if (parent.type.spec.isolating) break;
  }
  return null;
}
/**
Join the selected block or, if there is a text selection, the
closest ancestor block of the selection that can be joined, with
the sibling above it.
*/
var joinUp = function joinUp(state, dispatch) {
  var sel = state.selection,
    nodeSel = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection,
    point;
  if (nodeSel) {
    if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.from)) return false;
    point = sel.from;
  } else {
    point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.from, -1);
    if (point == null) return false;
  }
  if (dispatch) {
    var tr = state.tr.join(point);
    if (nodeSel) tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
/**
Join the selected block, or the closest ancestor of the selection
that can be joined, with the sibling after it.
*/
var joinDown = function joinDown(state, dispatch) {
  var sel = state.selection,
    point;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {
    if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.to)) return false;
    point = sel.to;
  } else {
    point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.to, 1);
    if (point == null) return false;
  }
  if (dispatch) dispatch(state.tr.join(point).scrollIntoView());
  return true;
};
/**
Lift the selected block, or the closest ancestor block of the
selection that can be lifted, out of its parent node.
*/
var lift = function lift(state, dispatch) {
  var _state$selection3 = state.selection,
    $from = _state$selection3.$from,
    $to = _state$selection3.$to;
  var range = $from.blockRange($to),
    target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);
  if (target == null) return false;
  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
/**
If the selection is in a node whose type has a truthy
[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, replace the
selection with a newline character.
*/
var newlineInCode = function newlineInCode(state, dispatch) {
  var _state$selection4 = state.selection,
    $head = _state$selection4.$head,
    $anchor = _state$selection4.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;
  if (dispatch) dispatch(state.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt(match) {
  for (var i = 0; i < match.edgeCount; i++) {
    var _match$edge = match.edge(i),
      type = _match$edge.type;
    if (type.isTextblock && !type.hasRequiredAttrs()) return type;
  }
  return null;
}
/**
When the selection is in a node with a truthy
[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, create a
default block after the code block, and move the cursor there.
*/
var exitCode = function exitCode(state, dispatch) {
  var _state$selection5 = state.selection,
    $head = _state$selection5.$head,
    $anchor = _state$selection5.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;
  var above = $head.node(-1),
    after = $head.indexAfter(-1),
    type = defaultBlockAt(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type)) return false;
  if (dispatch) {
    var pos = $head.after(),
      tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(tr.doc.resolve(pos), 1));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
/**
If a block node is selected, create an empty paragraph before (if
it is its parent's first child) or after it.
*/
var createParagraphNear = function createParagraphNear(state, dispatch) {
  var sel = state.selection,
    $from = sel.$from,
    $to = sel.$to;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) return false;
  var type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock) return false;
  if (dispatch) {
    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    var tr = state.tr.insert(side, type.createAndFill());
    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, side + 1));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
/**
If the cursor is in an empty textblock that can be lifted, lift the
block.
*/
var liftEmptyBlock = function liftEmptyBlock(state, dispatch) {
  var $cursor = state.selection.$cursor;
  if (!$cursor || $cursor.parent.content.size) return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    var before = $cursor.before();
    if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, before)) {
      if (dispatch) dispatch(state.tr.split(before).scrollIntoView());
      return true;
    }
  }
  var range = $cursor.blockRange(),
    target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);
  if (target == null) return false;
  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
/**
Create a variant of [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock) that uses
a custom function to determine the type of the newly split off block.
*/
function splitBlockAs(splitNode) {
  return function (state, dispatch) {
    var _state$selection6 = state.selection,
      $from = _state$selection6.$from,
      $to = _state$selection6.$to;
    if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, $from.pos)) return false;
      if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.parent.isBlock) return false;
    if (dispatch) {
      var atEnd = $to.parentOffset == $to.parent.content.size;
      var tr = state.tr;
      if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection || state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection) tr.deleteSelection();
      var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      var splitType = splitNode && splitNode($to.parent, atEnd);
      var types = splitType ? [splitType] : atEnd && deflt ? [{
        type: deflt
      }] : undefined;
      var can = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);
      if (!types && !can && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{
        type: deflt
      }] : undefined)) {
        if (deflt) types = [{
          type: deflt
        }];
        can = true;
      }
      if (can) {
        tr.split(tr.mapping.map($from.pos), 1, types);
        if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {
          var first = tr.mapping.map($from.before()),
            $first = tr.doc.resolve(first);
          if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
        }
      }
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
}
/**
Split the parent block of the selection. If the selection is a text
selection, also delete its content.
*/
var splitBlock = splitBlockAs();
/**
Acts like [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock), but without
resetting the set of active marks at the cursor.
*/
var splitBlockKeepMarks = function splitBlockKeepMarks(state, dispatch) {
  return splitBlock(state, dispatch && function (tr) {
    var marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
    if (marks) tr.ensureMarks(marks);
    dispatch(tr);
  });
};
/**
Move the selection to the node wrapping the current selection, if
any. (Will not select the document node.)
*/
var selectParentNode = function selectParentNode(state, dispatch) {
  var _state$selection7 = state.selection,
    $from = _state$selection7.$from,
    to = _state$selection7.to,
    pos;
  var same = $from.sharedDepth(to);
  if (same == 0) return false;
  pos = $from.before(same);
  if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, pos)));
  return true;
};
/**
Select the whole document.
*/
var selectAll = function selectAll(state, dispatch) {
  if (dispatch) dispatch(state.tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection(state.doc)));
  return true;
};
function joinMaybeClear(state, $pos, dispatch) {
  var before = $pos.nodeBefore,
    after = $pos.nodeAfter,
    index = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type)) return false;
  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
    if (dispatch) dispatch(state.tr["delete"]($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, $pos.pos))) return false;
  if (dispatch) dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch) {
  var before = $cut.nodeBefore,
    after = $cut.nodeAfter,
    conn,
    match;
  if (before.type.spec.isolating || after.type.spec.isolating) return false;
  if (joinMaybeClear(state, $cut, dispatch)) return true;
  var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      var end = $cut.pos + after.nodeSize,
        wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;
      for (var i = conn.length - 1; i >= 0; i--) wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(conn[i].create(null, wrap));
      wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(before.copy(wrap));
      var tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(wrap, 1, 0), conn.length, true));
      var joinAt = end + 2 * conn.length;
      if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinAt)) tr.join(joinAt);
      dispatch(tr.scrollIntoView());
    }
    return true;
  }
  var selAfter = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($cut, 1);
  var range = selAfter && selAfter.$from.blockRange(selAfter.$to),
    target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    var at = before,
      _wrap = [];
    for (;;) {
      _wrap.push(at);
      if (at.isTextblock) break;
      at = at.lastChild;
    }
    var afterText = after,
      afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild) afterDepth++;
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        var _end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;
        for (var _i = _wrap.length - 1; _i >= 0; _i--) _end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(_wrap[_i].copy(_end));
        var _tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - _wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(_end, _wrap.length, 0), 0, true));
        dispatch(_tr.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function (state, dispatch) {
    var sel = state.selection,
      $pos = side < 0 ? sel.$from : sel.$to;
    var depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth) return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock) return false;
    if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
/**
Moves the cursor to the start of current text block.
*/
var selectTextblockStart = selectTextblockSide(-1);
/**
Moves the cursor to the end of current text block.
*/
var selectTextblockEnd = selectTextblockSide(1);
// Parameterized commands
/**
Wrap the selection in a node of the given type with the given
attributes.
*/
function wrapIn(nodeType) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (state, dispatch) {
    var _state$selection8 = state.selection,
      $from = _state$selection8.$from,
      $to = _state$selection8.$to;
    var range = $from.blockRange($to),
      wrapping = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping)(range, nodeType, attrs);
    if (!wrapping) return false;
    if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}
/**
Returns a command that tries to set the selected textblocks to the
given node type with the given attributes.
*/
function setBlockType(nodeType) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (state, dispatch) {
    var applicable = false;
    for (var i = 0; i < state.selection.ranges.length && !applicable; i++) {
      var _state$selection$rang = state.selection.ranges[i],
        from = _state$selection$rang.$from.pos,
        to = _state$selection$rang.$to.pos;
      state.doc.nodesBetween(from, to, function (node, pos) {
        if (applicable) return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          var $pos = state.doc.resolve(pos),
            index = $pos.index();
          applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
        }
      });
    }
    if (!applicable) return false;
    if (dispatch) {
      var tr = state.tr;
      for (var _i2 = 0; _i2 < state.selection.ranges.length; _i2++) {
        var _state$selection$rang2 = state.selection.ranges[_i2],
          _from = _state$selection$rang2.$from.pos,
          _to = _state$selection$rang2.$to.pos;
        tr.setBlockType(_from, _to, nodeType, attrs);
      }
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
}
function markApplies(doc, ranges, type) {
  var _loop = function _loop() {
      var _ranges$i = ranges[i],
        $from = _ranges$i.$from,
        $to = _ranges$i.$to;
      var can = $from.depth == 0 ? doc.inlineContent && doc.type.allowsMarkType(type) : false;
      doc.nodesBetween($from.pos, $to.pos, function (node) {
        if (can) return false;
        can = node.inlineContent && node.type.allowsMarkType(type);
      });
      if (can) return {
        v: true
      };
    },
    _ret;
  for (var i = 0; i < ranges.length; i++) {
    _ret = _loop();
    if (_ret) return _ret.v;
  }
  return false;
}
/**
Create a command function that toggles the given mark with the
given attributes. Will return `false` when the current selection
doesn't support that mark. This will remove the mark if any marks
of that type exist in the selection, or add it otherwise. If the
selection is empty, this applies to the [stored
marks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks) instead of a range of the
document.
*/
function toggleMark(markType) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (state, dispatch) {
    var _state$selection9 = state.selection,
      empty = _state$selection9.empty,
      $cursor = _state$selection9.$cursor,
      ranges = _state$selection9.ranges;
    if (empty && !$cursor || !markApplies(state.doc, ranges, markType)) return false;
    if (dispatch) {
      if ($cursor) {
        if (markType.isInSet(state.storedMarks || $cursor.marks())) dispatch(state.tr.removeStoredMark(markType));else dispatch(state.tr.addStoredMark(markType.create(attrs)));
      } else {
        var has = false,
          tr = state.tr;
        for (var i = 0; !has && i < ranges.length; i++) {
          var _ranges$i2 = ranges[i],
            $from = _ranges$i2.$from,
            $to = _ranges$i2.$to;
          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);
        }
        for (var _i3 = 0; _i3 < ranges.length; _i3++) {
          var _ranges$_i = ranges[_i3],
            _$from = _ranges$_i.$from,
            _$to = _ranges$_i.$to;
          if (has) {
            tr.removeMark(_$from.pos, _$to.pos, markType);
          } else {
            var from = _$from.pos,
              to = _$to.pos,
              start = _$from.nodeAfter,
              end = _$to.nodeBefore;
            var spaceStart = start && start.isText ? /^\s*/.exec(start.text)[0].length : 0;
            var spaceEnd = end && end.isText ? /\s*$/.exec(end.text)[0].length : 0;
            if (from + spaceStart < to) {
              from += spaceStart;
              to -= spaceEnd;
            }
            tr.addMark(from, to, markType.create(attrs));
          }
        }
        dispatch(tr.scrollIntoView());
      }
    }
    return true;
  };
}
function wrapDispatchForJoin(dispatch, isJoinable) {
  return function (tr) {
    if (!tr.isGeneric) return dispatch(tr);
    var ranges = [];
    for (var i = 0; i < tr.mapping.maps.length; i++) {
      var map = tr.mapping.maps[i];
      for (var j = 0; j < ranges.length; j++) ranges[j] = map.map(ranges[j]);
      map.forEach(function (_s, _e, from, to) {
        return ranges.push(from, to);
      });
    }
    // Figure out which joinable points exist inside those ranges,
    // by checking all node boundaries in their parent nodes.
    var joinable = [];
    for (var _i4 = 0; _i4 < ranges.length; _i4 += 2) {
      var from = ranges[_i4],
        to = ranges[_i4 + 1];
      var $from = tr.doc.resolve(from),
        depth = $from.sharedDepth(to),
        parent = $from.node(depth);
      for (var index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {
        var after = parent.maybeChild(index);
        if (!after) break;
        if (index && joinable.indexOf(pos) == -1) {
          var before = parent.child(index - 1);
          if (before.type == after.type && isJoinable(before, after)) joinable.push(pos);
        }
        pos += after.nodeSize;
      }
    }
    // Join the joinable points
    joinable.sort(function (a, b) {
      return a - b;
    });
    for (var _i5 = joinable.length - 1; _i5 >= 0; _i5--) {
      if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinable[_i5])) tr.join(joinable[_i5]);
    }
    dispatch(tr);
  };
}
/**
Wrap a command so that, when it produces a transform that causes
two joinable nodes to end up next to each other, those are joined.
Nodes are considered joinable when they are of the same type and
when the `isJoinable` predicate returns true for them or, if an
array of strings was passed, if their node type name is in that
array.
*/
function autoJoin(command, isJoinable) {
  var canJoin = Array.isArray(isJoinable) ? function (node) {
    return isJoinable.indexOf(node.type.name) > -1;
  } : isJoinable;
  return function (state, dispatch, view) {
    return command(state, dispatch && wrapDispatchForJoin(dispatch, canJoin), view);
  };
}
/**
Combine a number of command functions into a single function (which
calls them one by one until one returns true).
*/
function chainCommands() {
  for (var _len = arguments.length, commands = new Array(_len), _key = 0; _key < _len; _key++) {
    commands[_key] = arguments[_key];
  }
  return function (state, dispatch, view) {
    for (var i = 0; i < commands.length; i++) if (commands[i](state, dispatch, view)) return true;
    return false;
  };
}
var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
/**
A basic keymap containing bindings not specific to any schema.
Binds the following keys (when multiple commands are listed, they
are chained with [`chainCommands`](https://prosemirror.net/docs/ref/#commands.chainCommands)):

* **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`
* **Mod-Enter** to `exitCode`
* **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`
* **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`
* **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`
* **Mod-a** to `selectAll`
*/
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};
/**
A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,
**Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and
**Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like
Ctrl-Delete.
*/
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};
for (var key in pcBaseKeymap) macBaseKeymap[key] = pcBaseKeymap[key];
var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
// @ts-ignore
: typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
/**
Depending on the detected platform, this will hold
[`pcBasekeymap`](https://prosemirror.net/docs/ref/#commands.pcBaseKeymap) or
[`macBaseKeymap`](https://prosemirror.net/docs/ref/#commands.macBaseKeymap).
*/
var baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;


/***/ }),

/***/ "./node_modules/prosemirror-dropcursor/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/prosemirror-dropcursor/dist/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   dropCursor: function() { return /* binding */ dropCursor; }
/* harmony export */ });
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }



/**
Create a plugin that, when added to a ProseMirror instance,
causes a decoration to show up at the drop position when something
is dragged over the editor.

Nodes may add a `disableDropCursor` property to their spec to
control the showing of a drop cursor inside them. This may be a
boolean or a function, which will be called with a view and a
position, and should return a boolean.
*/
function dropCursor() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({
    view: function view(editorView) {
      return new DropCursorView(editorView, options);
    }
  });
}
var DropCursorView = /*#__PURE__*/function () {
  function DropCursorView(editorView, options) {
    var _this = this;
    _classCallCheck(this, DropCursorView);
    var _a;
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;
    this.color = options.color === false ? undefined : options.color || "black";
    this["class"] = options["class"];
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(function (name) {
      var handler = function handler(e) {
        _this[name](e);
      };
      editorView.dom.addEventListener(name, handler);
      return {
        name: name,
        handler: handler
      };
    });
  }
  _createClass(DropCursorView, [{
    key: "destroy",
    value: function destroy() {
      var _this2 = this;
      this.handlers.forEach(function (_ref) {
        var name = _ref.name,
          handler = _ref.handler;
        return _this2.editorView.dom.removeEventListener(name, handler);
      });
    }
  }, {
    key: "update",
    value: function update(editorView, prevState) {
      if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
        if (this.cursorPos > editorView.state.doc.content.size) this.setCursor(null);else this.updateOverlay();
      }
    }
  }, {
    key: "setCursor",
    value: function setCursor(pos) {
      if (pos == this.cursorPos) return;
      this.cursorPos = pos;
      if (pos == null) {
        this.element.parentNode.removeChild(this.element);
        this.element = null;
      } else {
        this.updateOverlay();
      }
    }
  }, {
    key: "updateOverlay",
    value: function updateOverlay() {
      var $pos = this.editorView.state.doc.resolve(this.cursorPos);
      var isBlock = !$pos.parent.inlineContent,
        rect;
      if (isBlock) {
        var before = $pos.nodeBefore,
          after = $pos.nodeAfter;
        if (before || after) {
          var node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
          if (node) {
            var nodeRect = node.getBoundingClientRect();
            var top = before ? nodeRect.bottom : nodeRect.top;
            if (before && after) top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
            rect = {
              left: nodeRect.left,
              right: nodeRect.right,
              top: top - this.width / 2,
              bottom: top + this.width / 2
            };
          }
        }
      }
      if (!rect) {
        var coords = this.editorView.coordsAtPos(this.cursorPos);
        rect = {
          left: coords.left - this.width / 2,
          right: coords.left + this.width / 2,
          top: coords.top,
          bottom: coords.bottom
        };
      }
      var parent = this.editorView.dom.offsetParent;
      if (!this.element) {
        this.element = parent.appendChild(document.createElement("div"));
        if (this["class"]) this.element.className = this["class"];
        this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
        if (this.color) {
          this.element.style.backgroundColor = this.color;
        }
      }
      this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
      this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
      var parentLeft, parentTop;
      if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
        parentLeft = -pageXOffset;
        parentTop = -pageYOffset;
      } else {
        var _rect = parent.getBoundingClientRect();
        parentLeft = _rect.left - parent.scrollLeft;
        parentTop = _rect.top - parent.scrollTop;
      }
      this.element.style.left = rect.left - parentLeft + "px";
      this.element.style.top = rect.top - parentTop + "px";
      this.element.style.width = rect.right - rect.left + "px";
      this.element.style.height = rect.bottom - rect.top + "px";
    }
  }, {
    key: "scheduleRemoval",
    value: function scheduleRemoval(timeout) {
      var _this3 = this;
      clearTimeout(this.timeout);
      this.timeout = setTimeout(function () {
        return _this3.setCursor(null);
      }, timeout);
    }
  }, {
    key: "dragover",
    value: function dragover(event) {
      if (!this.editorView.editable) return;
      var pos = this.editorView.posAtCoords({
        left: event.clientX,
        top: event.clientY
      });
      var node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
      var disableDropCursor = node && node.type.spec.disableDropCursor;
      var disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
      if (pos && !disabled) {
        var target = pos.pos;
        if (this.editorView.dragging && this.editorView.dragging.slice) {
          var point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.dropPoint)(this.editorView.state.doc, target, this.editorView.dragging.slice);
          if (point != null) target = point;
        }
        this.setCursor(target);
        this.scheduleRemoval(5000);
      }
    }
  }, {
    key: "dragend",
    value: function dragend() {
      this.scheduleRemoval(20);
    }
  }, {
    key: "drop",
    value: function drop() {
      this.scheduleRemoval(20);
    }
  }, {
    key: "dragleave",
    value: function dragleave(event) {
      if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget)) this.setCursor(null);
    }
  }]);
  return DropCursorView;
}();


/***/ }),

/***/ "./node_modules/prosemirror-gapcursor/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-gapcursor/dist/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GapCursor: function() { return /* binding */ GapCursor; },
/* harmony export */   gapCursor: function() { return /* binding */ gapCursor; }
/* harmony export */ });
/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-keymap */ "./node_modules/prosemirror-keymap/dist/index.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.js");
/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-view */ "./node_modules/prosemirror-view/dist/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }





/**
Gap cursor selections are represented using this class. Its
`$anchor` and `$head` properties both point at the cursor position.
*/
var GapCursor = /*#__PURE__*/function (_Selection) {
  _inherits(GapCursor, _Selection);
  /**
  Create a gap cursor.
  */
  function GapCursor($pos) {
    _classCallCheck(this, GapCursor);
    return _callSuper(this, GapCursor, [$pos, $pos]);
  }
  _createClass(GapCursor, [{
    key: "map",
    value: function map(doc, mapping) {
      var $pos = doc.resolve(mapping.map(this.head));
      return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($pos);
    }
  }, {
    key: "content",
    value: function content() {
      return prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return other instanceof GapCursor && other.head == this.head;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: "gapcursor",
        pos: this.head
      };
    }
    /**
    @internal
    */
  }, {
    key: "getBookmark",
    value:
    /**
    @internal
    */
    function getBookmark() {
      return new GapBookmark(this.anchor);
    }
    /**
    @internal
    */
  }], [{
    key: "fromJSON",
    value: function fromJSON(doc, json) {
      if (typeof json.pos != "number") throw new RangeError("Invalid input for GapCursor.fromJSON");
      return new GapCursor(doc.resolve(json.pos));
    }
  }, {
    key: "valid",
    value: function valid($pos) {
      var parent = $pos.parent;
      if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos)) return false;
      var override = parent.type.spec.allowGapCursor;
      if (override != null) return override;
      var deflt = parent.contentMatchAt($pos.index()).defaultType;
      return deflt && deflt.isTextblock;
    }
    /**
    @internal
    */
  }, {
    key: "findGapCursorFrom",
    value: function findGapCursorFrom($pos, dir) {
      var mustMove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      search: for (;;) {
        if (!mustMove && GapCursor.valid($pos)) return $pos;
        var pos = $pos.pos,
          next = null;
        // Scan up from this position
        for (var d = $pos.depth;; d--) {
          var parent = $pos.node(d);
          if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
            next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
            break;
          } else if (d == 0) {
            return null;
          }
          pos += dir;
          var $cur = $pos.doc.resolve(pos);
          if (GapCursor.valid($cur)) return $cur;
        }
        // And then down into the next node
        for (;;) {
          var inside = dir > 0 ? next.firstChild : next.lastChild;
          if (!inside) {
            if (next.isAtom && !next.isText && !prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(next)) {
              $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
              mustMove = false;
              continue search;
            }
            break;
          }
          next = inside;
          pos += dir;
          var _$cur = $pos.doc.resolve(pos);
          if (GapCursor.valid(_$cur)) return _$cur;
        }
        return null;
      }
    }
  }]);
  return GapCursor;
}(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection);
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.jsonID("gapcursor", GapCursor);
var GapBookmark = /*#__PURE__*/function () {
  function GapBookmark(pos) {
    _classCallCheck(this, GapBookmark);
    this.pos = pos;
  }
  _createClass(GapBookmark, [{
    key: "map",
    value: function map(mapping) {
      return new GapBookmark(mapping.map(this.pos));
    }
  }, {
    key: "resolve",
    value: function resolve(doc) {
      var $pos = doc.resolve(this.pos);
      return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($pos);
    }
  }]);
  return GapBookmark;
}();
function closedBefore($pos) {
  for (var d = $pos.depth; d >= 0; d--) {
    var index = $pos.index(d),
      parent = $pos.node(d);
    // At the start of this parent, look at next one
    if (index == 0) {
      if (parent.type.spec.isolating) return true;
      continue;
    }
    // See if the node before (or its first ancestor) is closed
    for (var before = parent.child(index - 1);; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating) return true;
      if (before.inlineContent) return false;
    }
  }
  // Hit start of document
  return true;
}
function closedAfter($pos) {
  for (var d = $pos.depth; d >= 0; d--) {
    var index = $pos.indexAfter(d),
      parent = $pos.node(d);
    if (index == parent.childCount) {
      if (parent.type.spec.isolating) return true;
      continue;
    }
    for (var after = parent.child(index);; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating) return true;
      if (after.inlineContent) return false;
    }
  }
  return true;
}

/**
Create a gap cursor plugin. When enabled, this will capture clicks
near and arrow-key-motion past places that don't have a normally
selectable position nearby, and create a gap cursor selection for
them. The cursor is drawn as an element with class
`ProseMirror-gapcursor`. You can either include
`style/gapcursor.css` from the package's directory or add your own
styles to make it visible.
*/
function gapCursor() {
  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween: function createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick: handleClick,
      handleKeyDown: handleKeyDown,
      handleDOMEvents: {
        beforeinput: beforeinput
      }
    }
  });
}
var handleKeyDown = (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__.keydownHandler)({
  "ArrowLeft": arrow("horiz", -1),
  "ArrowRight": arrow("horiz", 1),
  "ArrowUp": arrow("vert", -1),
  "ArrowDown": arrow("vert", 1)
});
function arrow(axis, dir) {
  var dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function (state, dispatch, view) {
    var sel = state.selection;
    var $start = dir > 0 ? sel.$to : sel.$from,
      mustMove = sel.empty;
    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0) return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    var $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found) return false;
    if (dispatch) dispatch(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable) return false;
  var $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos)) return false;
  var clickPos = view.posAtCoords({
    left: event.clientX,
    top: event.clientY
  });
  if (clickPos && clickPos.inside > -1 && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside))) return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
// This is a hack that, when a composition starts while a gap cursor
// is active, quickly creates an inline context for the composition to
// happen in, to avoid it being aborted by the DOM selection being
// moved into a valid position.
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor)) return false;
  var $from = view.state.selection.$from;
  var insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert) return false;
  var frag = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;
  for (var i = insert.length - 1; i >= 0; i--) frag = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(insert[i].createAndFill(null, frag));
  var tr = view.state.tr.replace($from.pos, $from.pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(frag, 0, 0));
  tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve($from.pos + 1)));
  view.dispatch(tr);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor)) return null;
  var node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return prosemirror_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(state.doc, [prosemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.widget(state.selection.head, node, {
    key: "gapcursor"
  })]);
}


/***/ }),

/***/ "./node_modules/prosemirror-history/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/prosemirror-history/dist/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   closeHistory: function() { return /* binding */ closeHistory; },
/* harmony export */   history: function() { return /* binding */ history; },
/* harmony export */   redo: function() { return /* binding */ redo; },
/* harmony export */   redoDepth: function() { return /* binding */ redoDepth; },
/* harmony export */   undo: function() { return /* binding */ undo; },
/* harmony export */   undoDepth: function() { return /* binding */ undoDepth; }
/* harmony export */ });
/* harmony import */ var rope_sequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rope-sequence */ "./node_modules/rope-sequence/dist/index.js");
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }




// ProseMirror's history isn't simply a way to roll back to a previous
// state, because ProseMirror supports applying changes without adding
// them to the history (for example during collaboration).
//
// To this end, each 'Branch' (one for the undo history and one for
// the redo history) keeps an array of 'Items', which can optionally
// hold a step (an actual undoable change), and always hold a position
// map (which is needed to move changes below them to apply to the
// current document).
//
// An item that has both a step and a selection bookmark is the start
// of an 'event'  a group of changes that will be undone or redone at
// once. (It stores only the bookmark, since that way we don't have to
// provide a document until the selection is actually applied, which
// is useful when compressing.)
// Used to schedule history compression
var max_empty_items = 500;
var Branch = /*#__PURE__*/function () {
  function Branch(items, eventCount) {
    _classCallCheck(this, Branch);
    this.items = items;
    this.eventCount = eventCount;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  _createClass(Branch, [{
    key: "popEvent",
    value: function popEvent(state, preserveItems) {
      var _this = this;
      if (this.eventCount == 0) return null;
      var end = this.items.length;
      for (;; end--) {
        var next = this.items.get(end - 1);
        if (next.selection) {
          --end;
          break;
        }
      }
      var remap, mapFrom;
      if (preserveItems) {
        remap = this.remapping(end, this.items.length);
        mapFrom = remap.maps.length;
      }
      var transform = state.tr;
      var selection, remaining;
      var addAfter = [],
        addBefore = [];
      this.items.forEach(function (item, i) {
        if (!item.step) {
          if (!remap) {
            remap = _this.remapping(end, i + 1);
            mapFrom = remap.maps.length;
          }
          mapFrom--;
          addBefore.push(item);
          return;
        }
        if (remap) {
          addBefore.push(new Item(item.map));
          var step = item.step.map(remap.slice(mapFrom)),
            map;
          if (step && transform.maybeStep(step).doc) {
            map = transform.mapping.maps[transform.mapping.maps.length - 1];
            addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));
          }
          mapFrom--;
          if (map) remap.appendMap(map, mapFrom);
        } else {
          transform.maybeStep(item.step);
        }
        if (item.selection) {
          selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
          remaining = new Branch(_this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), _this.eventCount - 1);
          return false;
        }
      }, this.items.length, 0);
      return {
        remaining: remaining,
        transform: transform,
        selection: selection
      };
    }
    // Create a new branch with the given transform added.
  }, {
    key: "addTransform",
    value: function addTransform(transform, selection, histOptions, preserveItems) {
      var newItems = [],
        eventCount = this.eventCount;
      var oldItems = this.items,
        lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
      for (var i = 0; i < transform.steps.length; i++) {
        var step = transform.steps[i].invert(transform.docs[i]);
        var item = new Item(transform.mapping.maps[i], step, selection),
          merged = void 0;
        if (merged = lastItem && lastItem.merge(item)) {
          item = merged;
          if (i) newItems.pop();else oldItems = oldItems.slice(0, oldItems.length - 1);
        }
        newItems.push(item);
        if (selection) {
          eventCount++;
          selection = undefined;
        }
        if (!preserveItems) lastItem = item;
      }
      var overflow = eventCount - histOptions.depth;
      if (overflow > DEPTH_OVERFLOW) {
        oldItems = cutOffEvents(oldItems, overflow);
        eventCount -= overflow;
      }
      return new Branch(oldItems.append(newItems), eventCount);
    }
  }, {
    key: "remapping",
    value: function remapping(from, to) {
      var maps = new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.Mapping();
      this.items.forEach(function (item, i) {
        var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from ? maps.maps.length - item.mirrorOffset : undefined;
        maps.appendMap(item.map, mirrorPos);
      }, from, to);
      return maps;
    }
  }, {
    key: "addMaps",
    value: function addMaps(array) {
      if (this.eventCount == 0) return this;
      return new Branch(this.items.append(array.map(function (map) {
        return new Item(map);
      })), this.eventCount);
    }
    // When the collab module receives remote changes, the history has
    // to know about those, so that it can adjust the steps that were
    // rebased on top of the remote changes, and include the position
    // maps for the remote changes in its array of items.
  }, {
    key: "rebased",
    value: function rebased(rebasedTransform, rebasedCount) {
      if (!this.eventCount) return this;
      var rebasedItems = [],
        start = Math.max(0, this.items.length - rebasedCount);
      var mapping = rebasedTransform.mapping;
      var newUntil = rebasedTransform.steps.length;
      var eventCount = this.eventCount;
      this.items.forEach(function (item) {
        if (item.selection) eventCount--;
      }, start);
      var iRebased = rebasedCount;
      this.items.forEach(function (item) {
        var pos = mapping.getMirror(--iRebased);
        if (pos == null) return;
        newUntil = Math.min(newUntil, pos);
        var map = mapping.maps[pos];
        if (item.step) {
          var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
          var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
          if (selection) eventCount++;
          rebasedItems.push(new Item(map, step, selection));
        } else {
          rebasedItems.push(new Item(map));
        }
      }, start);
      var newMaps = [];
      for (var i = rebasedCount; i < newUntil; i++) newMaps.push(new Item(mapping.maps[i]));
      var items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
      var branch = new Branch(items, eventCount);
      if (branch.emptyItemCount() > max_empty_items) branch = branch.compress(this.items.length - rebasedItems.length);
      return branch;
    }
  }, {
    key: "emptyItemCount",
    value: function emptyItemCount() {
      var count = 0;
      this.items.forEach(function (item) {
        if (!item.step) count++;
      });
      return count;
    }
    // Compressing a branch means rewriting it to push the air (map-only
    // items) out. During collaboration, these naturally accumulate
    // because each remote change adds one. The `upto` argument is used
    // to ensure that only the items below a given level are compressed,
    // because `rebased` relies on a clean, untouched set of items in
    // order to associate old items with rebased steps.
  }, {
    key: "compress",
    value: function compress() {
      var upto = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;
      var remap = this.remapping(0, upto),
        mapFrom = remap.maps.length;
      var items = [],
        events = 0;
      this.items.forEach(function (item, i) {
        if (i >= upto) {
          items.push(item);
          if (item.selection) events++;
        } else if (item.step) {
          var step = item.step.map(remap.slice(mapFrom)),
            map = step && step.getMap();
          mapFrom--;
          if (map) remap.appendMap(map, mapFrom);
          if (step) {
            var selection = item.selection && item.selection.map(remap.slice(mapFrom));
            if (selection) events++;
            var newItem = new Item(map.invert(), step, selection),
              merged,
              last = items.length - 1;
            if (merged = items.length && items[last].merge(newItem)) items[last] = merged;else items.push(newItem);
          }
        } else if (item.map) {
          mapFrom--;
        }
      }, this.items.length, 0);
      return new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__["default"].from(items.reverse()), events);
    }
  }]);
  return Branch;
}();
Branch.empty = new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__["default"].empty, 0);
function cutOffEvents(items, n) {
  var cutPoint;
  items.forEach(function (item, i) {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
var Item = /*#__PURE__*/function () {
  function Item(
  // The (forward) step map for this item.
  map,
  // The inverted step
  step,
  // If this is non-null, this item is the start of a group, and
  // this selection is the starting selection for the group (the one
  // that was active before the first step was applied)
  selection,
  // If this item is the inverse of a previous mapping on the stack,
  // this points at the inverse's offset
  mirrorOffset) {
    _classCallCheck(this, Item);
    this.map = map;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  _createClass(Item, [{
    key: "merge",
    value: function merge(other) {
      if (this.step && other.step && !other.selection) {
        var step = other.step.merge(this.step);
        if (step) return new Item(step.getMap().invert(), step, this.selection);
      }
    }
  }]);
  return Item;
}(); // The value of the state field that tracks undo/redo history for that
// state. Will be stored in the plugin state when the history plugin
// is active.
var HistoryState = /*#__PURE__*/_createClass(function HistoryState(done, undone, prevRanges, prevTime, prevComposition) {
  _classCallCheck(this, HistoryState);
  this.done = done;
  this.undone = undone;
  this.prevRanges = prevRanges;
  this.prevTime = prevTime;
  this.prevComposition = prevComposition;
});
var DEPTH_OVERFLOW = 20;
// Record a transformation in undo history.
function applyTransaction(history, state, tr, options) {
  var historyTr = tr.getMeta(historyKey),
    rebased;
  if (historyTr) return historyTr.historyState;
  if (tr.getMeta(closeHistoryKey)) history = new HistoryState(history.done, history.undone, null, 0, -1);
  var appended = tr.getMeta("appendedTransaction");
  if (tr.steps.length == 0) {
    return history;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo) return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime, history.prevComposition);else return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);
  } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    // Group transforms that occur in quick succession into one event.
    var composition = tr.getMeta("composition");
    var newGroup = history.prevTime == 0 || !appended && history.prevComposition != composition && (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges));
    var prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);
  } else if (rebased = tr.getMeta("rebased")) {
    // Used by the collab module to tell the history that some of its
    // content has been rebased.
    return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);
  } else {
    return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges) return false;
  if (!transform.docChanged) return true;
  var adjacent = false;
  transform.mapping.maps[0].forEach(function (start, end) {
    for (var i = 0; i < prevRanges.length; i += 2) if (start <= prevRanges[i + 1] && end >= prevRanges[i]) adjacent = true;
  });
  return adjacent;
}
function rangesFor(map) {
  var result = [];
  map.forEach(function (_from, _to, from, to) {
    return result.push(from, to);
  });
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges) return null;
  var result = [];
  for (var i = 0; i < ranges.length; i += 2) {
    var from = mapping.map(ranges[i], 1),
      to = mapping.map(ranges[i + 1], -1);
    if (from <= to) result.push(from, to);
  }
  return result;
}
// Apply the latest event from one branch to the document and shift the event
// onto the other branch.
function histTransaction(history, state, dispatch, redo) {
  var preserveItems = mustPreserveItems(state);
  var histOptions = historyKey.get(state).spec.config;
  var pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);
  if (!pop) return;
  var selection = pop.selection.resolve(pop.transform.doc);
  var added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  var newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);
  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {
    redo: redo,
    historyState: newHist
  }).scrollIntoView());
}
var cachedPreserveItems = false,
  cachedPreserveItemsPlugins = null;
// Check whether any plugin in the given state has a
// `historyPreserveItems` property in its spec, in which case we must
// preserve steps exactly as they came in, so that they can be
// rebased.
function mustPreserveItems(state) {
  var plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (var i = 0; i < plugins.length; i++) if (plugins[i].spec.historyPreserveItems) {
      cachedPreserveItems = true;
      break;
    }
  }
  return cachedPreserveItems;
}
/**
Set a flag on the given transaction that will prevent further steps
from being appended to an existing history event (so that they
require a separate undo command to undo).
*/
function closeHistory(tr) {
  return tr.setMeta(closeHistoryKey, true);
}
var historyKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey("history");
var closeHistoryKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey("closeHistory");
/**
Returns a plugin that enables the undo history for an editor. The
plugin will track undo and redo stacks, which can be used with the
[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.

You can set an `"addToHistory"` [metadata
property](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction
to prevent it from being rolled back by undo.
*/
function history() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({
    key: historyKey,
    state: {
      init: function init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply: function apply(tr, hist, state) {
        return applyTransaction(hist, state, tr, config);
      }
    },
    config: config,
    props: {
      handleDOMEvents: {
        beforeinput: function beforeinput(view, e) {
          var inputType = e.inputType;
          var command = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command) return false;
          e.preventDefault();
          return command(view.state, view.dispatch);
        }
      }
    }
  });
}
/**
A command function that undoes the last change, if any.
*/
var undo = function undo(state, dispatch) {
  var hist = historyKey.getState(state);
  if (!hist || hist.done.eventCount == 0) return false;
  if (dispatch) histTransaction(hist, state, dispatch, false);
  return true;
};
/**
A command function that redoes the last undone change, if any.
*/
var redo = function redo(state, dispatch) {
  var hist = historyKey.getState(state);
  if (!hist || hist.undone.eventCount == 0) return false;
  if (dispatch) histTransaction(hist, state, dispatch, true);
  return true;
};
/**
The amount of undoable events available in a given state.
*/
function undoDepth(state) {
  var hist = historyKey.getState(state);
  return hist ? hist.done.eventCount : 0;
}
/**
The amount of redoable events available in a given editor state.
*/
function redoDepth(state) {
  var hist = historyKey.getState(state);
  return hist ? hist.undone.eventCount : 0;
}


/***/ }),

/***/ "./node_modules/prosemirror-keymap/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/prosemirror-keymap/dist/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   keydownHandler: function() { return /* binding */ keydownHandler; },
/* harmony export */   keymap: function() { return /* binding */ keymap; }
/* harmony export */ });
/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! w3c-keyname */ "./node_modules/w3c-keyname/index.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");


var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;
function normalizeKeyName(name) {
  var parts = name.split(/-(?!$)/),
    result = parts[parts.length - 1];
  if (result == "Space") result = " ";
  var alt, ctrl, shift, meta;
  for (var i = 0; i < parts.length - 1; i++) {
    var mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) meta = true;else if (/^a(lt)?$/i.test(mod)) alt = true;else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;else if (/^s(hift)?$/i.test(mod)) shift = true;else if (/^mod$/i.test(mod)) {
      if (mac) meta = true;else ctrl = true;
    } else throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt) result = "Alt-" + result;
  if (ctrl) result = "Ctrl-" + result;
  if (meta) result = "Meta-" + result;
  if (shift) result = "Shift-" + result;
  return result;
}
function normalize(map) {
  var copy = Object.create(null);
  for (var prop in map) copy[normalizeKeyName(prop)] = map[prop];
  return copy;
}
function modifiers(name, event) {
  var shift = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  if (event.altKey) name = "Alt-" + name;
  if (event.ctrlKey) name = "Ctrl-" + name;
  if (event.metaKey) name = "Meta-" + name;
  if (shift && event.shiftKey) name = "Shift-" + name;
  return name;
}
/**
Create a keymap plugin for the given set of bindings.

Bindings should map key names to [command](https://prosemirror.net/docs/ref/#commands)-style
functions, which will be called with `(EditorState, dispatch,
EditorView)` arguments, and should return true when they've handled
the key. Note that the view argument isn't part of the command
protocol, but can be used as an escape hatch if a binding needs to
directly interact with the UI.

Key names may be strings like `"Shift-Ctrl-Enter"`a key
identifier prefixed with zero or more modifiers. Key identifiers
are based on the strings that can appear in
[`KeyEvent.key`](https:developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).
Use lowercase letters to refer to letter keys (or uppercase letters
if you want shift to be held). You may use `"Space"` as an alias
for the `" "` name.

Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or
`a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or
`Meta-`) are recognized. For characters that are created by holding
shift, the `Shift-` prefix is implied, and should not be added
explicitly.

You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on
other platforms.

You can add multiple keymap plugins to an editor. The order in
which they appear determines their precedence (the ones early in
the array get to dispatch first).
*/
function keymap(bindings) {
  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({
    props: {
      handleKeyDown: keydownHandler(bindings)
    }
  });
}
/**
Given a set of bindings (using the same format as
[`keymap`](https://prosemirror.net/docs/ref/#keymap.keymap)), return a [keydown
handler](https://prosemirror.net/docs/ref/#view.EditorProps.handleKeyDown) that handles them.
*/
function keydownHandler(bindings) {
  var map = normalize(bindings);
  return function (view, event) {
    var name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_0__.keyName)(event),
      baseName,
      direct = map[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view)) return true;
    // A character key
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        // In case the name was already modified by shift, try looking
        // it up without its shift modifier
        var noShift = map[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view)) return true;
      }
      if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_0__.base[event.keyCode]) && baseName != name) {
        // Try falling back to the keyCode when there's a modifier
        // active or the character produced isn't ASCII, and our table
        // produces a different name from the the keyCode. See #668,
        // #1060
        var fromCode = map[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view)) return true;
      }
    }
    return false;
  };
}


/***/ }),

/***/ "./node_modules/prosemirror-model/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/prosemirror-model/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContentMatch: function() { return /* binding */ ContentMatch; },
/* harmony export */   DOMParser: function() { return /* binding */ DOMParser; },
/* harmony export */   DOMSerializer: function() { return /* binding */ DOMSerializer; },
/* harmony export */   Fragment: function() { return /* binding */ Fragment; },
/* harmony export */   Mark: function() { return /* binding */ Mark; },
/* harmony export */   MarkType: function() { return /* binding */ MarkType; },
/* harmony export */   Node: function() { return /* binding */ Node; },
/* harmony export */   NodeRange: function() { return /* binding */ NodeRange; },
/* harmony export */   NodeType: function() { return /* binding */ NodeType; },
/* harmony export */   ReplaceError: function() { return /* binding */ ReplaceError; },
/* harmony export */   ResolvedPos: function() { return /* binding */ ResolvedPos; },
/* harmony export */   Schema: function() { return /* binding */ Schema; },
/* harmony export */   Slice: function() { return /* binding */ Slice; }
/* harmony export */ });
/* harmony import */ var orderedmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! orderedmap */ "./node_modules/orderedmap/dist/index.js");
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

function _findDiffStart(a, b, pos) {
  for (var i = 0;; i++) {
    if (i == a.childCount || i == b.childCount) return a.childCount == b.childCount ? null : pos;
    var childA = a.child(i),
      childB = b.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB)) return pos;
    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++) pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      var inner = _findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null) return inner;
    }
    pos += childA.nodeSize;
  }
}
function _findDiffEnd(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount;;) {
    if (iA == 0 || iB == 0) return iA == iB ? null : {
      a: posA,
      b: posB
    };
    var childA = a.child(--iA),
      childB = b.child(--iB),
      size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB)) return {
      a: posA,
      b: posB
    };
    if (childA.isText && childA.text != childB.text) {
      var same = 0,
        minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return {
        a: posA,
        b: posB
      };
    }
    if (childA.content.size || childB.content.size) {
      var inner = _findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) return inner;
    }
    posA -= size;
    posB -= size;
  }
}

/**
A fragment represents a node's collection of child nodes.

Like nodes, fragments are persistent data structures, and you
should not mutate them or their content. Rather, you create new
instances whenever needed. The API tries to make this easy.
*/
var Fragment = /*#__PURE__*/function () {
  /**
  @internal
  */
  function Fragment(
  /**
  @internal
  */
  content, size) {
    _classCallCheck(this, Fragment);
    this.content = content;
    this.size = size || 0;
    if (size == null) for (var i = 0; i < content.length; i++) this.size += content[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  _createClass(Fragment, [{
    key: "nodesBetween",
    value: function nodesBetween(from, to, f) {
      var nodeStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var parent = arguments.length > 4 ? arguments[4] : undefined;
      for (var i = 0, pos = 0; pos < to; i++) {
        var child = this.content[i],
          end = pos + child.nodeSize;
        if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
          var start = pos + 1;
          child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);
        }
        pos = end;
      }
    }
    /**
    Call the given callback for every descendant node. `pos` will be
    relative to the start of the fragment. The callback may return
    `false` to prevent traversal of a given node's children.
    */
  }, {
    key: "descendants",
    value: function descendants(f) {
      this.nodesBetween(0, this.size, f);
    }
    /**
    Extract the text between `from` and `to`. See the same method on
    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
    */
  }, {
    key: "textBetween",
    value: function textBetween(from, to, blockSeparator, leafText) {
      var text = "",
        first = true;
      this.nodesBetween(from, to, function (node, pos) {
        var nodeText = node.isText ? node.text.slice(Math.max(from, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
        if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
          if (first) first = false;else text += blockSeparator;
        }
        text += nodeText;
      }, 0);
      return text;
    }
    /**
    Create a new fragment containing the combined content of this
    fragment and the other.
    */
  }, {
    key: "append",
    value: function append(other) {
      if (!other.size) return this;
      if (!this.size) return other;
      var last = this.lastChild,
        first = other.firstChild,
        content = this.content.slice(),
        i = 0;
      if (last.isText && last.sameMarkup(first)) {
        content[content.length - 1] = last.withText(last.text + first.text);
        i = 1;
      }
      for (; i < other.content.length; i++) content.push(other.content[i]);
      return new Fragment(content, this.size + other.size);
    }
    /**
    Cut out the sub-fragment between the two given positions.
    */
  }, {
    key: "cut",
    value: function cut(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;
      if (from == 0 && to == this.size) return this;
      var result = [],
        size = 0;
      if (to > from) for (var i = 0, pos = 0; pos < to; i++) {
        var child = this.content[i],
          end = pos + child.nodeSize;
        if (end > from) {
          if (pos < from || end > to) {
            if (child.isText) child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));else child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size += child.nodeSize;
        }
        pos = end;
      }
      return new Fragment(result, size);
    }
    /**
    @internal
    */
  }, {
    key: "cutByIndex",
    value: function cutByIndex(from, to) {
      if (from == to) return Fragment.empty;
      if (from == 0 && to == this.content.length) return this;
      return new Fragment(this.content.slice(from, to));
    }
    /**
    Create a new fragment in which the node at the given index is
    replaced by the given node.
    */
  }, {
    key: "replaceChild",
    value: function replaceChild(index, node) {
      var current = this.content[index];
      if (current == node) return this;
      var copy = this.content.slice();
      var size = this.size + node.nodeSize - current.nodeSize;
      copy[index] = node;
      return new Fragment(copy, size);
    }
    /**
    Create a new fragment by prepending the given node to this
    fragment.
    */
  }, {
    key: "addToStart",
    value: function addToStart(node) {
      return new Fragment([node].concat(this.content), this.size + node.nodeSize);
    }
    /**
    Create a new fragment by appending the given node to this
    fragment.
    */
  }, {
    key: "addToEnd",
    value: function addToEnd(node) {
      return new Fragment(this.content.concat(node), this.size + node.nodeSize);
    }
    /**
    Compare this fragment to another one.
    */
  }, {
    key: "eq",
    value: function eq(other) {
      if (this.content.length != other.content.length) return false;
      for (var i = 0; i < this.content.length; i++) if (!this.content[i].eq(other.content[i])) return false;
      return true;
    }
    /**
    The first child of the fragment, or `null` if it is empty.
    */
  }, {
    key: "firstChild",
    get: function get() {
      return this.content.length ? this.content[0] : null;
    }
    /**
    The last child of the fragment, or `null` if it is empty.
    */
  }, {
    key: "lastChild",
    get: function get() {
      return this.content.length ? this.content[this.content.length - 1] : null;
    }
    /**
    The number of child nodes in this fragment.
    */
  }, {
    key: "childCount",
    get: function get() {
      return this.content.length;
    }
    /**
    Get the child node at the given index. Raise an error when the
    index is out of range.
    */
  }, {
    key: "child",
    value: function child(index) {
      var found = this.content[index];
      if (!found) throw new RangeError("Index " + index + " out of range for " + this);
      return found;
    }
    /**
    Get the child node at the given index, if it exists.
    */
  }, {
    key: "maybeChild",
    value: function maybeChild(index) {
      return this.content[index] || null;
    }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
  }, {
    key: "forEach",
    value: function forEach(f) {
      for (var i = 0, p = 0; i < this.content.length; i++) {
        var child = this.content[i];
        f(child, p, i);
        p += child.nodeSize;
      }
    }
    /**
    Find the first position at which this fragment and another
    fragment differ, or `null` if they are the same.
    */
  }, {
    key: "findDiffStart",
    value: function findDiffStart(other) {
      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return _findDiffStart(this, other, pos);
    }
    /**
    Find the first position, searching from the end, at which this
    fragment and the given fragment differ, or `null` if they are
    the same. Since this position will not be the same in both
    nodes, an object with two separate positions is returned.
    */
  }, {
    key: "findDiffEnd",
    value: function findDiffEnd(other) {
      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;
      var otherPos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : other.size;
      return _findDiffEnd(this, other, pos, otherPos);
    }
    /**
    Find the index and inner offset corresponding to a given relative
    position in this fragment. The result object will be reused
    (overwritten) the next time the function is called. (Not public.)
    */
  }, {
    key: "findIndex",
    value: function findIndex(pos) {
      var round = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      if (pos == 0) return retIndex(0, pos);
      if (pos == this.size) return retIndex(this.content.length, pos);
      if (pos > this.size || pos < 0) throw new RangeError("Position ".concat(pos, " outside of fragment (").concat(this, ")"));
      for (var i = 0, curPos = 0;; i++) {
        var cur = this.child(i),
          end = curPos + cur.nodeSize;
        if (end >= pos) {
          if (end == pos || round > 0) return retIndex(i + 1, end);
          return retIndex(i, curPos);
        }
        curPos = end;
      }
    }
    /**
    Return a debugging string that describes this fragment.
    */
  }, {
    key: "toString",
    value: function toString() {
      return "<" + this.toStringInner() + ">";
    }
    /**
    @internal
    */
  }, {
    key: "toStringInner",
    value: function toStringInner() {
      return this.content.join(", ");
    }
    /**
    Create a JSON-serializeable representation of this fragment.
    */
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.content.length ? this.content.map(function (n) {
        return n.toJSON();
      }) : null;
    }
    /**
    Deserialize a fragment from its JSON representation.
    */
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, value) {
      if (!value) return Fragment.empty;
      if (!Array.isArray(value)) throw new RangeError("Invalid input for Fragment.fromJSON");
      return new Fragment(value.map(schema.nodeFromJSON));
    }
    /**
    Build a fragment from an array of nodes. Ensures that adjacent
    text nodes with the same marks are joined together.
    */
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      if (!array.length) return Fragment.empty;
      var joined,
        size = 0;
      for (var i = 0; i < array.length; i++) {
        var node = array[i];
        size += node.nodeSize;
        if (i && node.isText && array[i - 1].sameMarkup(node)) {
          if (!joined) joined = array.slice(0, i);
          joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
        } else if (joined) {
          joined.push(node);
        }
      }
      return new Fragment(joined || array, size);
    }
    /**
    Create a fragment from something that can be interpreted as a
    set of nodes. For `null`, it returns the empty fragment. For a
    fragment, the fragment itself. For a node or array of nodes, a
    fragment containing those nodes.
    */
  }, {
    key: "from",
    value: function from(nodes) {
      if (!nodes) return Fragment.empty;
      if (nodes instanceof Fragment) return nodes;
      if (Array.isArray(nodes)) return this.fromArray(nodes);
      if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize);
      throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
    }
  }]);
  return Fragment;
}();
/**
An empty fragment. Intended to be reused whenever a node doesn't
contain anything (rather than allocating a new empty fragment for
each leaf node).
*/
Fragment.empty = new Fragment([], 0);
var found = {
  index: 0,
  offset: 0
};
function retIndex(index, offset) {
  found.index = index;
  found.offset = offset;
  return found;
}
function compareDeep(a, b) {
  if (a === b) return true;
  if (!(a && _typeof(a) == "object") || !(b && _typeof(b) == "object")) return false;
  var array = Array.isArray(a);
  if (Array.isArray(b) != array) return false;
  if (array) {
    if (a.length != b.length) return false;
    for (var i = 0; i < a.length; i++) if (!compareDeep(a[i], b[i])) return false;
  } else {
    for (var p in a) if (!(p in b) || !compareDeep(a[p], b[p])) return false;
    for (var _p in b) if (!(_p in a)) return false;
  }
  return true;
}

/**
A mark is a piece of information that can be attached to a node,
such as it being emphasized, in code font, or a link. It has a
type and optionally a set of attributes that provide further
information (such as the target of the link). Marks are created
through a `Schema`, which controls which types exist and which
attributes they have.
*/
var Mark = /*#__PURE__*/function () {
  /**
  @internal
  */
  function Mark(
  /**
  The type of this mark.
  */
  type,
  /**
  The attributes associated with this mark.
  */
  attrs) {
    _classCallCheck(this, Mark);
    this.type = type;
    this.attrs = attrs;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  _createClass(Mark, [{
    key: "addToSet",
    value: function addToSet(set) {
      var copy,
        placed = false;
      for (var i = 0; i < set.length; i++) {
        var other = set[i];
        if (this.eq(other)) return set;
        if (this.type.excludes(other.type)) {
          if (!copy) copy = set.slice(0, i);
        } else if (other.type.excludes(this.type)) {
          return set;
        } else {
          if (!placed && other.type.rank > this.type.rank) {
            if (!copy) copy = set.slice(0, i);
            copy.push(this);
            placed = true;
          }
          if (copy) copy.push(other);
        }
      }
      if (!copy) copy = set.slice();
      if (!placed) copy.push(this);
      return copy;
    }
    /**
    Remove this mark from the given set, returning a new set. If this
    mark is not in the set, the set itself is returned.
    */
  }, {
    key: "removeFromSet",
    value: function removeFromSet(set) {
      for (var i = 0; i < set.length; i++) if (this.eq(set[i])) return set.slice(0, i).concat(set.slice(i + 1));
      return set;
    }
    /**
    Test whether this mark is in the given set of marks.
    */
  }, {
    key: "isInSet",
    value: function isInSet(set) {
      for (var i = 0; i < set.length; i++) if (this.eq(set[i])) return true;
      return false;
    }
    /**
    Test whether this mark has the same type and attributes as
    another mark.
    */
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
    }
    /**
    Convert this mark to a JSON-serializeable representation.
    */
  }, {
    key: "toJSON",
    value: function toJSON() {
      var obj = {
        type: this.type.name
      };
      for (var _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      return obj;
    }
    /**
    Deserialize a mark from JSON.
    */
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (!json) throw new RangeError("Invalid input for Mark.fromJSON");
      var type = schema.marks[json.type];
      if (!type) throw new RangeError("There is no mark type ".concat(json.type, " in this schema"));
      return type.create(json.attrs);
    }
    /**
    Test whether two sets of marks are identical.
    */
  }, {
    key: "sameSet",
    value: function sameSet(a, b) {
      if (a == b) return true;
      if (a.length != b.length) return false;
      for (var i = 0; i < a.length; i++) if (!a[i].eq(b[i])) return false;
      return true;
    }
    /**
    Create a properly sorted mark set from null, a single mark, or an
    unsorted array of marks.
    */
  }, {
    key: "setFrom",
    value: function setFrom(marks) {
      if (!marks || Array.isArray(marks) && marks.length == 0) return Mark.none;
      if (marks instanceof Mark) return [marks];
      var copy = marks.slice();
      copy.sort(function (a, b) {
        return a.type.rank - b.type.rank;
      });
      return copy;
    }
  }]);
  return Mark;
}();
/**
The empty set of marks.
*/
Mark.none = [];

/**
Error type raised by [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) when
given an invalid replacement.
*/
var ReplaceError = /*#__PURE__*/function (_Error) {
  _inherits(ReplaceError, _Error);
  function ReplaceError() {
    _classCallCheck(this, ReplaceError);
    return _callSuper(this, ReplaceError, arguments);
  }
  return _createClass(ReplaceError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
/*
ReplaceError = function(this: any, message: string) {
  let err = Error.call(this, message)
  ;(err as any).__proto__ = ReplaceError.prototype
  return err
} as any

ReplaceError.prototype = Object.create(Error.prototype)
ReplaceError.prototype.constructor = ReplaceError
ReplaceError.prototype.name = "ReplaceError"
*/
/**
A slice represents a piece cut out of a larger document. It
stores not only a fragment, but also the depth up to which nodes on
both side are open (cut through).
*/
var Slice = /*#__PURE__*/function () {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragmenti.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  function Slice(
  /**
  The slice's content.
  */
  content,
  /**
  The open depth at the start of the fragment.
  */
  openStart,
  /**
  The open depth at the end.
  */
  openEnd) {
    _classCallCheck(this, Slice);
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  _createClass(Slice, [{
    key: "size",
    get: function get() {
      return this.content.size - this.openStart - this.openEnd;
    }
    /**
    @internal
    */
  }, {
    key: "insertAt",
    value: function insertAt(pos, fragment) {
      var content = insertInto(this.content, pos + this.openStart, fragment);
      return content && new Slice(content, this.openStart, this.openEnd);
    }
    /**
    @internal
    */
  }, {
    key: "removeBetween",
    value: function removeBetween(from, to) {
      return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);
    }
    /**
    Tests whether this slice is equal to another slice.
    */
  }, {
    key: "eq",
    value: function eq(other) {
      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
    }
    /**
    @internal
    */
  }, {
    key: "toString",
    value: function toString() {
      return this.content + "(" + this.openStart + "," + this.openEnd + ")";
    }
    /**
    Convert a slice to a JSON-serializable representation.
    */
  }, {
    key: "toJSON",
    value: function toJSON() {
      if (!this.content.size) return null;
      var json = {
        content: this.content.toJSON()
      };
      if (this.openStart > 0) json.openStart = this.openStart;
      if (this.openEnd > 0) json.openEnd = this.openEnd;
      return json;
    }
    /**
    Deserialize a slice from its JSON representation.
    */
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (!json) return Slice.empty;
      var openStart = json.openStart || 0,
        openEnd = json.openEnd || 0;
      if (typeof openStart != "number" || typeof openEnd != "number") throw new RangeError("Invalid input for Slice.fromJSON");
      return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
    }
    /**
    Create a slice from a fragment by taking the maximum possible
    open value on both side of the fragment.
    */
  }, {
    key: "maxOpen",
    value: function maxOpen(fragment) {
      var openIsolating = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var openStart = 0,
        openEnd = 0;
      for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) openStart++;
      for (var _n = fragment.lastChild; _n && !_n.isLeaf && (openIsolating || !_n.type.spec.isolating); _n = _n.lastChild) openEnd++;
      return new Slice(fragment, openStart, openEnd);
    }
  }]);
  return Slice;
}();
/**
The empty slice.
*/
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(content, from, to) {
  var _content$findIndex = content.findIndex(from),
    index = _content$findIndex.index,
    offset = _content$findIndex.offset,
    child = content.maybeChild(index);
  var _content$findIndex2 = content.findIndex(to),
    indexTo = _content$findIndex2.index,
    offsetTo = _content$findIndex2.offset;
  if (offset == from || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError("Removing non-flat range");
    return content.cut(0, from).append(content.cut(to));
  }
  if (index != indexTo) throw new RangeError("Removing non-flat range");
  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));
}
function insertInto(content, dist, insert, parent) {
  var _content$findIndex3 = content.findIndex(dist),
    index = _content$findIndex3.index,
    offset = _content$findIndex3.offset,
    child = content.maybeChild(index);
  if (offset == dist || child.isText) {
    if (parent && !parent.canReplace(index, index, insert)) return null;
    return content.cut(0, dist).append(insert).append(content.cut(dist));
  }
  var inner = insertInto(child.content, dist - offset - 1, insert);
  return inner && content.replaceChild(index, child.copy(inner));
}
function _replace($from, $to, slice) {
  if (slice.openStart > $from.depth) throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice.openStart != $to.depth - slice.openEnd) throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice, 0);
}
function replaceOuter($from, $to, slice, depth) {
  var index = $from.index(depth),
    node = $from.node(depth);
  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
    var inner = replaceOuter($from, $to, slice, depth + 1);
    return node.copy(node.content.replaceChild(index, inner));
  } else if (!slice.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {
    // Simple, flat case
    var parent = $from.parent,
      content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));
  } else {
    var _prepareSliceForRepla = prepareSliceForReplace(slice, $from),
      start = _prepareSliceForRepla.start,
      end = _prepareSliceForRepla.end;
    return close(node, replaceThreeWay($from, start, end, $to, depth));
  }
}
function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type)) throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
}
function joinable($before, $after, depth) {
  var node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target) {
  var last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last])) target[last] = child.withText(target[last].text + child.text);else target.push(child);
}
function addRange($start, $end, depth, target) {
  var node = ($end || $start).node(depth);
  var startIndex = 0,
    endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (var i = startIndex; i < endIndex; i++) addNode(node.child(i), target);
  if ($end && $end.depth == depth && $end.textOffset) addNode($end.nodeBefore, target);
}
function close(node, content) {
  node.type.checkContent(content);
  return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  var content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart) addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd) addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function replaceTwoWay($from, $to, depth) {
  var content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    var type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function prepareSliceForReplace(slice, $along) {
  var extra = $along.depth - slice.openStart,
    parent = $along.node(extra);
  var node = parent.copy(slice.content);
  for (var i = extra - 1; i >= 0; i--) node = $along.node(i).copy(Fragment.from(node));
  return {
    start: node.resolveNoCache(slice.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice.openEnd - extra)
  };
}

/**
You can [_resolve_](https://prosemirror.net/docs/ref/#model.Node.resolve) a position to get more
information about it. Objects of this class represent such a
resolved position, providing various pieces of context
information, and some helper methods.

Throughout this interface, methods that take an optional `depth`
parameter will interpret undefined as `this.depth` and negative
numbers as `this.depth + value`.
*/
var ResolvedPos = /*#__PURE__*/function () {
  /**
  @internal
  */
  function ResolvedPos(
  /**
  The position that was resolved.
  */
  pos,
  /**
  @internal
  */
  path,
  /**
  The offset this position has into its parent node.
  */
  parentOffset) {
    _classCallCheck(this, ResolvedPos);
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  /**
  @internal
  */
  _createClass(ResolvedPos, [{
    key: "resolveDepth",
    value: function resolveDepth(val) {
      if (val == null) return this.depth;
      if (val < 0) return this.depth + val;
      return val;
    }
    /**
    The parent node that the position points into. Note that even if
    a position points into a text node, that node is not considered
    the parenttext nodes are flat in this model, and have no content.
    */
  }, {
    key: "parent",
    get: function get() {
      return this.node(this.depth);
    }
    /**
    The root node in which the position was resolved.
    */
  }, {
    key: "doc",
    get: function get() {
      return this.node(0);
    }
    /**
    The ancestor node at the given level. `p.node(p.depth)` is the
    same as `p.parent`.
    */
  }, {
    key: "node",
    value: function node(depth) {
      return this.path[this.resolveDepth(depth) * 3];
    }
    /**
    The index into the ancestor at the given level. If this points
    at the 3rd node in the 2nd paragraph on the top level, for
    example, `p.index(0)` is 1 and `p.index(1)` is 2.
    */
  }, {
    key: "index",
    value: function index(depth) {
      return this.path[this.resolveDepth(depth) * 3 + 1];
    }
    /**
    The index pointing after this position into the ancestor at the
    given level.
    */
  }, {
    key: "indexAfter",
    value: function indexAfter(depth) {
      depth = this.resolveDepth(depth);
      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
    }
    /**
    The (absolute) position at the start of the node at the given
    level.
    */
  }, {
    key: "start",
    value: function start(depth) {
      depth = this.resolveDepth(depth);
      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    }
    /**
    The (absolute) position at the end of the node at the given
    level.
    */
  }, {
    key: "end",
    value: function end(depth) {
      depth = this.resolveDepth(depth);
      return this.start(depth) + this.node(depth).content.size;
    }
    /**
    The (absolute) position directly before the wrapping node at the
    given level, or, when `depth` is `this.depth + 1`, the original
    position.
    */
  }, {
    key: "before",
    value: function before(depth) {
      depth = this.resolveDepth(depth);
      if (!depth) throw new RangeError("There is no position before the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
    }
    /**
    The (absolute) position directly after the wrapping node at the
    given level, or the original position when `depth` is `this.depth + 1`.
    */
  }, {
    key: "after",
    value: function after(depth) {
      depth = this.resolveDepth(depth);
      if (!depth) throw new RangeError("There is no position after the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
    }
    /**
    When this position points into a text node, this returns the
    distance between the position and the start of the text node.
    Will be zero for positions that point between nodes.
    */
  }, {
    key: "textOffset",
    get: function get() {
      return this.pos - this.path[this.path.length - 1];
    }
    /**
    Get the node directly after the position, if any. If the position
    points into a text node, only the part of that node after the
    position is returned.
    */
  }, {
    key: "nodeAfter",
    get: function get() {
      var parent = this.parent,
        index = this.index(this.depth);
      if (index == parent.childCount) return null;
      var dOff = this.pos - this.path[this.path.length - 1],
        child = parent.child(index);
      return dOff ? parent.child(index).cut(dOff) : child;
    }
    /**
    Get the node directly before the position, if any. If the
    position points into a text node, only the part of that node
    before the position is returned.
    */
  }, {
    key: "nodeBefore",
    get: function get() {
      var index = this.index(this.depth);
      var dOff = this.pos - this.path[this.path.length - 1];
      if (dOff) return this.parent.child(index).cut(0, dOff);
      return index == 0 ? null : this.parent.child(index - 1);
    }
    /**
    Get the position at the given index in the parent node at the
    given depth (which defaults to `this.depth`).
    */
  }, {
    key: "posAtIndex",
    value: function posAtIndex(index, depth) {
      depth = this.resolveDepth(depth);
      var node = this.path[depth * 3],
        pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
      for (var i = 0; i < index; i++) pos += node.child(i).nodeSize;
      return pos;
    }
    /**
    Get the marks at this position, factoring in the surrounding
    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
    position is at the start of a non-empty node, the marks of the
    node after it (if any) are returned.
    */
  }, {
    key: "marks",
    value: function marks() {
      var parent = this.parent,
        index = this.index();
      // In an empty parent, return the empty array
      if (parent.content.size == 0) return Mark.none;
      // When inside a text node, just return the text node's marks
      if (this.textOffset) return parent.child(index).marks;
      var main = parent.maybeChild(index - 1),
        other = parent.maybeChild(index);
      // If the `after` flag is true of there is no node before, make
      // the node after this position the main reference.
      if (!main) {
        var tmp = main;
        main = other;
        other = tmp;
      }
      // Use all marks in the main node, except those that have
      // `inclusive` set to false and are not present in the other node.
      var marks = main.marks;
      for (var i = 0; i < marks.length; i++) if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks))) marks = marks[i--].removeFromSet(marks);
      return marks;
    }
    /**
    Get the marks after the current position, if any, except those
    that are non-inclusive and not present at position `$end`. This
    is mostly useful for getting the set of marks to preserve after a
    deletion. Will return `null` if this position is at the end of
    its parent node or its parent node isn't a textblock (in which
    case no marks should be preserved).
    */
  }, {
    key: "marksAcross",
    value: function marksAcross($end) {
      var after = this.parent.maybeChild(this.index());
      if (!after || !after.isInline) return null;
      var marks = after.marks,
        next = $end.parent.maybeChild($end.index());
      for (var i = 0; i < marks.length; i++) if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks))) marks = marks[i--].removeFromSet(marks);
      return marks;
    }
    /**
    The depth up to which this position and the given (non-resolved)
    position share the same parent nodes.
    */
  }, {
    key: "sharedDepth",
    value: function sharedDepth(pos) {
      for (var depth = this.depth; depth > 0; depth--) if (this.start(depth) <= pos && this.end(depth) >= pos) return depth;
      return 0;
    }
    /**
    Returns a range based on the place where this position and the
    given position diverge around block content. If both point into
    the same textblock, for example, a range around that textblock
    will be returned. If they point into different blocks, the range
    around those blocks in their shared ancestor is returned. You can
    pass in an optional predicate that will be called with a parent
    node to see if a range into that parent is acceptable.
    */
  }, {
    key: "blockRange",
    value: function blockRange() {
      var other = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
      var pred = arguments.length > 1 ? arguments[1] : undefined;
      if (other.pos < this.pos) return other.blockRange(this);
      for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) return new NodeRange(this, other, d);
      return null;
    }
    /**
    Query whether the given position shares the same parent node.
    */
  }, {
    key: "sameParent",
    value: function sameParent(other) {
      return this.pos - this.parentOffset == other.pos - other.parentOffset;
    }
    /**
    Return the greater of this and the given position.
    */
  }, {
    key: "max",
    value: function max(other) {
      return other.pos > this.pos ? other : this;
    }
    /**
    Return the smaller of this and the given position.
    */
  }, {
    key: "min",
    value: function min(other) {
      return other.pos < this.pos ? other : this;
    }
    /**
    @internal
    */
  }, {
    key: "toString",
    value: function toString() {
      var str = "";
      for (var i = 1; i <= this.depth; i++) str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
      return str + ":" + this.parentOffset;
    }
    /**
    @internal
    */
  }], [{
    key: "resolve",
    value: function resolve(doc, pos) {
      if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError("Position " + pos + " out of range");
      var path = [];
      var start = 0,
        parentOffset = pos;
      for (var node = doc;;) {
        var _node$content$findInd = node.content.findIndex(parentOffset),
          index = _node$content$findInd.index,
          offset = _node$content$findInd.offset;
        var rem = parentOffset - offset;
        path.push(node, index, start + offset);
        if (!rem) break;
        node = node.child(index);
        if (node.isText) break;
        parentOffset = rem - 1;
        start += offset + 1;
      }
      return new ResolvedPos(pos, path, parentOffset);
    }
    /**
    @internal
    */
  }, {
    key: "resolveCached",
    value: function resolveCached(doc, pos) {
      for (var i = 0; i < resolveCache.length; i++) {
        var cached = resolveCache[i];
        if (cached.pos == pos && cached.doc == doc) return cached;
      }
      var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);
      resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
      return result;
    }
  }]);
  return ResolvedPos;
}();
var resolveCache = [],
  resolveCachePos = 0,
  resolveCacheSize = 12;
/**
Represents a flat range of content, i.e. one that starts and
ends in the same node.
*/
var NodeRange = /*#__PURE__*/function () {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  function NodeRange(
  /**
  A resolved position along the start of the content. May have a
  `depth` greater than this object's `depth` property, since
  these are the positions that were used to compute the range,
  not re-resolved positions directly at its boundaries.
  */
  $from,
  /**
  A position along the end of the content. See
  caveat for [`$from`](https://prosemirror.net/docs/ref/#model.NodeRange.$from).
  */
  $to,
  /**
  The depth of the node that this range points into.
  */
  depth) {
    _classCallCheck(this, NodeRange);
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  /**
  The position at the start of the range.
  */
  _createClass(NodeRange, [{
    key: "start",
    get: function get() {
      return this.$from.before(this.depth + 1);
    }
    /**
    The position at the end of the range.
    */
  }, {
    key: "end",
    get: function get() {
      return this.$to.after(this.depth + 1);
    }
    /**
    The parent node that the range points into.
    */
  }, {
    key: "parent",
    get: function get() {
      return this.$from.node(this.depth);
    }
    /**
    The start index of the range in the parent node.
    */
  }, {
    key: "startIndex",
    get: function get() {
      return this.$from.index(this.depth);
    }
    /**
    The end index of the range in the parent node.
    */
  }, {
    key: "endIndex",
    get: function get() {
      return this.$to.indexAfter(this.depth);
    }
  }]);
  return NodeRange;
}();
var emptyAttrs = Object.create(null);
/**
This class represents a node in the tree that makes up a
ProseMirror document. So a document is an instance of `Node`, with
children that are also instances of `Node`.

Nodes are persistent data structures. Instead of changing them, you
create new ones with the content you want. Old ones keep pointing
at the old document shape. This is made cheaper by sharing
structure between the old and new data as much as possible, which a
tree shape like this (without back pointers) makes easy.

**Do not** directly mutate the properties of a `Node` object. See
[the guide](/docs/guide/#doc) for more information.
*/
var Node = /*#__PURE__*/function () {
  /**
  @internal
  */
  function Node(
  /**
  The type of node that this is.
  */
  type,
  /**
  An object mapping attribute names to values. The kind of
  attributes allowed and required are
  [determined](https://prosemirror.net/docs/ref/#model.NodeSpec.attrs) by the node type.
  */
  attrs,
  // A fragment holding the node's children.
  content) {
    var marks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Mark.none;
    _classCallCheck(this, Node);
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment.empty;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  _createClass(Node, [{
    key: "nodeSize",
    get: function get() {
      return this.isLeaf ? 1 : 2 + this.content.size;
    }
    /**
    The number of children that the node has.
    */
  }, {
    key: "childCount",
    get: function get() {
      return this.content.childCount;
    }
    /**
    Get the child node at the given index. Raises an error when the
    index is out of range.
    */
  }, {
    key: "child",
    value: function child(index) {
      return this.content.child(index);
    }
    /**
    Get the child node at the given index, if it exists.
    */
  }, {
    key: "maybeChild",
    value: function maybeChild(index) {
      return this.content.maybeChild(index);
    }
    /**
    Call `f` for every child node, passing the node, its offset
    into this parent node, and its index.
    */
  }, {
    key: "forEach",
    value: function forEach(f) {
      this.content.forEach(f);
    }
    /**
    Invoke a callback for all descendant nodes recursively between
    the given two positions that are relative to start of this
    node's content. The callback is invoked with the node, its
    position relative to the original node (method receiver),
    its parent node, and its child index. When the callback returns
    false for a given node, that node's children will not be
    recursed over. The last parameter can be used to specify a
    starting position to count from.
    */
  }, {
    key: "nodesBetween",
    value: function nodesBetween(from, to, f) {
      var startPos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      this.content.nodesBetween(from, to, f, startPos, this);
    }
    /**
    Call the given callback for every descendant node. Doesn't
    descend into a node when the callback returns `false`.
    */
  }, {
    key: "descendants",
    value: function descendants(f) {
      this.nodesBetween(0, this.content.size, f);
    }
    /**
    Concatenates all the text nodes found in this fragment and its
    children.
    */
  }, {
    key: "textContent",
    get: function get() {
      return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
    }
    /**
    Get all text between positions `from` and `to`. When
    `blockSeparator` is given, it will be inserted to separate text
    from different block nodes. If `leafText` is given, it'll be
    inserted for every non-text leaf node encountered, otherwise
    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
    */
  }, {
    key: "textBetween",
    value: function textBetween(from, to, blockSeparator, leafText) {
      return this.content.textBetween(from, to, blockSeparator, leafText);
    }
    /**
    Returns this node's first child, or `null` if there are no
    children.
    */
  }, {
    key: "firstChild",
    get: function get() {
      return this.content.firstChild;
    }
    /**
    Returns this node's last child, or `null` if there are no
    children.
    */
  }, {
    key: "lastChild",
    get: function get() {
      return this.content.lastChild;
    }
    /**
    Test whether two nodes represent the same piece of document.
    */
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || this.sameMarkup(other) && this.content.eq(other.content);
    }
    /**
    Compare the markup (type, attributes, and marks) of this node to
    those of another. Returns `true` if both have the same markup.
    */
  }, {
    key: "sameMarkup",
    value: function sameMarkup(other) {
      return this.hasMarkup(other.type, other.attrs, other.marks);
    }
    /**
    Check whether this node's markup correspond to the given type,
    attributes, and marks.
    */
  }, {
    key: "hasMarkup",
    value: function hasMarkup(type, attrs, marks) {
      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
    }
    /**
    Create a new node with the same markup as this node, containing
    the given content (or empty, if no content is given).
    */
  }, {
    key: "copy",
    value: function copy() {
      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (content == this.content) return this;
      return new Node(this.type, this.attrs, content, this.marks);
    }
    /**
    Create a copy of this node, with the given set of marks instead
    of the node's own marks.
    */
  }, {
    key: "mark",
    value: function mark(marks) {
      return marks == this.marks ? this : new Node(this.type, this.attrs, this.content, marks);
    }
    /**
    Create a copy of this node with only the content between the
    given positions. If `to` is not given, it defaults to the end of
    the node.
    */
  }, {
    key: "cut",
    value: function cut(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.content.size;
      if (from == 0 && to == this.content.size) return this;
      return this.copy(this.content.cut(from, to));
    }
    /**
    Cut out the part of the document between the given positions, and
    return it as a `Slice` object.
    */
  }, {
    key: "slice",
    value: function slice(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.content.size;
      var includeParents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (from == to) return Slice.empty;
      var $from = this.resolve(from),
        $to = this.resolve(to);
      var depth = includeParents ? 0 : $from.sharedDepth(to);
      var start = $from.start(depth),
        node = $from.node(depth);
      var content = node.content.cut($from.pos - start, $to.pos - start);
      return new Slice(content, $from.depth - depth, $to.depth - depth);
    }
    /**
    Replace the part of the document between the given positions with
    the given slice. The slice must 'fit', meaning its open sides
    must be able to connect to the surrounding content, and its
    content nodes must be valid children for the node they are placed
    into. If any of this is violated, an error of type
    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
    */
  }, {
    key: "replace",
    value: function replace(from, to, slice) {
      return _replace(this.resolve(from), this.resolve(to), slice);
    }
    /**
    Find the node directly after the given position.
    */
  }, {
    key: "nodeAt",
    value: function nodeAt(pos) {
      for (var node = this;;) {
        var _node$content$findInd2 = node.content.findIndex(pos),
          index = _node$content$findInd2.index,
          offset = _node$content$findInd2.offset;
        node = node.maybeChild(index);
        if (!node) return null;
        if (offset == pos || node.isText) return node;
        pos -= offset + 1;
      }
    }
    /**
    Find the (direct) child node after the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
  }, {
    key: "childAfter",
    value: function childAfter(pos) {
      var _this$content$findInd = this.content.findIndex(pos),
        index = _this$content$findInd.index,
        offset = _this$content$findInd.offset;
      return {
        node: this.content.maybeChild(index),
        index: index,
        offset: offset
      };
    }
    /**
    Find the (direct) child node before the given offset, if any,
    and return it along with its index and offset relative to this
    node.
    */
  }, {
    key: "childBefore",
    value: function childBefore(pos) {
      if (pos == 0) return {
        node: null,
        index: 0,
        offset: 0
      };
      var _this$content$findInd2 = this.content.findIndex(pos),
        index = _this$content$findInd2.index,
        offset = _this$content$findInd2.offset;
      if (offset < pos) return {
        node: this.content.child(index),
        index: index,
        offset: offset
      };
      var node = this.content.child(index - 1);
      return {
        node: node,
        index: index - 1,
        offset: offset - node.nodeSize
      };
    }
    /**
    Resolve the given position in the document, returning an
    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
    */
  }, {
    key: "resolve",
    value: function resolve(pos) {
      return ResolvedPos.resolveCached(this, pos);
    }
    /**
    @internal
    */
  }, {
    key: "resolveNoCache",
    value: function resolveNoCache(pos) {
      return ResolvedPos.resolve(this, pos);
    }
    /**
    Test whether a given mark or mark type occurs in this document
    between the two given positions.
    */
  }, {
    key: "rangeHasMark",
    value: function rangeHasMark(from, to, type) {
      var found = false;
      if (to > from) this.nodesBetween(from, to, function (node) {
        if (type.isInSet(node.marks)) found = true;
        return !found;
      });
      return found;
    }
    /**
    True when this is a block (non-inline node)
    */
  }, {
    key: "isBlock",
    get: function get() {
      return this.type.isBlock;
    }
    /**
    True when this is a textblock node, a block node with inline
    content.
    */
  }, {
    key: "isTextblock",
    get: function get() {
      return this.type.isTextblock;
    }
    /**
    True when this node allows inline content.
    */
  }, {
    key: "inlineContent",
    get: function get() {
      return this.type.inlineContent;
    }
    /**
    True when this is an inline node (a text node or a node that can
    appear among text).
    */
  }, {
    key: "isInline",
    get: function get() {
      return this.type.isInline;
    }
    /**
    True when this is a text node.
    */
  }, {
    key: "isText",
    get: function get() {
      return this.type.isText;
    }
    /**
    True when this is a leaf node.
    */
  }, {
    key: "isLeaf",
    get: function get() {
      return this.type.isLeaf;
    }
    /**
    True when this is an atom, i.e. when it does not have directly
    editable content. This is usually the same as `isLeaf`, but can
    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
    on a node's spec (typically used when the node is displayed as
    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
    */
  }, {
    key: "isAtom",
    get: function get() {
      return this.type.isAtom;
    }
    /**
    Return a string representation of this node for debugging
    purposes.
    */
  }, {
    key: "toString",
    value: function toString() {
      if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);
      var name = this.type.name;
      if (this.content.size) name += "(" + this.content.toStringInner() + ")";
      return wrapMarks(this.marks, name);
    }
    /**
    Get the content match in this node at the given index.
    */
  }, {
    key: "contentMatchAt",
    value: function contentMatchAt(index) {
      var match = this.type.contentMatch.matchFragment(this.content, 0, index);
      if (!match) throw new Error("Called contentMatchAt on a node with invalid content");
      return match;
    }
    /**
    Test whether replacing the range between `from` and `to` (by
    child index) with the given replacement fragment (which defaults
    to the empty fragment) would leave the node's content valid. You
    can optionally pass `start` and `end` indices into the
    replacement fragment.
    */
  }, {
    key: "canReplace",
    value: function canReplace(from, to) {
      var replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Fragment.empty;
      var start = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var end = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : replacement.childCount;
      var one = this.contentMatchAt(from).matchFragment(replacement, start, end);
      var two = one && one.matchFragment(this.content, to);
      if (!two || !two.validEnd) return false;
      for (var i = start; i < end; i++) if (!this.type.allowsMarks(replacement.child(i).marks)) return false;
      return true;
    }
    /**
    Test whether replacing the range `from` to `to` (by index) with
    a node of the given type would leave the node's content valid.
    */
  }, {
    key: "canReplaceWith",
    value: function canReplaceWith(from, to, type, marks) {
      if (marks && !this.type.allowsMarks(marks)) return false;
      var start = this.contentMatchAt(from).matchType(type);
      var end = start && start.matchFragment(this.content, to);
      return end ? end.validEnd : false;
    }
    /**
    Test whether the given node's content could be appended to this
    node. If that node is empty, this will only return true if there
    is at least one node type that can appear in both nodes (to avoid
    merging completely incompatible nodes).
    */
  }, {
    key: "canAppend",
    value: function canAppend(other) {
      if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content);else return this.type.compatibleContent(other.type);
    }
    /**
    Check whether this node and its descendants conform to the
    schema, and raise error when they do not.
    */
  }, {
    key: "check",
    value: function check() {
      this.type.checkContent(this.content);
      var copy = Mark.none;
      for (var i = 0; i < this.marks.length; i++) copy = this.marks[i].addToSet(copy);
      if (!Mark.sameSet(copy, this.marks)) throw new RangeError("Invalid collection of marks for node ".concat(this.type.name, ": ").concat(this.marks.map(function (m) {
        return m.type.name;
      })));
      this.content.forEach(function (node) {
        return node.check();
      });
    }
    /**
    Return a JSON-serializeable representation of this node.
    */
  }, {
    key: "toJSON",
    value: function toJSON() {
      var obj = {
        type: this.type.name
      };
      for (var _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }
      if (this.content.size) obj.content = this.content.toJSON();
      if (this.marks.length) obj.marks = this.marks.map(function (n) {
        return n.toJSON();
      });
      return obj;
    }
    /**
    Deserialize a node from its JSON representation.
    */
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (!json) throw new RangeError("Invalid input for Node.fromJSON");
      var marks = null;
      if (json.marks) {
        if (!Array.isArray(json.marks)) throw new RangeError("Invalid mark data for Node.fromJSON");
        marks = json.marks.map(schema.markFromJSON);
      }
      if (json.type == "text") {
        if (typeof json.text != "string") throw new RangeError("Invalid text node in JSON");
        return schema.text(json.text, marks);
      }
      var content = Fragment.fromJSON(schema, json.content);
      return schema.nodeType(json.type).create(json.attrs, content, marks);
    }
  }]);
  return Node;
}();
Node.prototype.text = undefined;
var TextNode = /*#__PURE__*/function (_Node) {
  _inherits(TextNode, _Node);
  /**
  @internal
  */
  function TextNode(type, attrs, content, marks) {
    var _this;
    _classCallCheck(this, TextNode);
    _this = _callSuper(this, TextNode, [type, attrs, null, marks]);
    if (!content) throw new RangeError("Empty text nodes are not allowed");
    _this.text = content;
    return _this;
  }
  _createClass(TextNode, [{
    key: "toString",
    value: function toString() {
      if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);
      return wrapMarks(this.marks, JSON.stringify(this.text));
    }
  }, {
    key: "textContent",
    get: function get() {
      return this.text;
    }
  }, {
    key: "textBetween",
    value: function textBetween(from, to) {
      return this.text.slice(from, to);
    }
  }, {
    key: "nodeSize",
    get: function get() {
      return this.text.length;
    }
  }, {
    key: "mark",
    value: function mark(marks) {
      return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);
    }
  }, {
    key: "withText",
    value: function withText(text) {
      if (text == this.text) return this;
      return new TextNode(this.type, this.attrs, text, this.marks);
    }
  }, {
    key: "cut",
    value: function cut() {
      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.text.length;
      if (from == 0 && to == this.text.length) return this;
      return this.withText(this.text.slice(from, to));
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this.sameMarkup(other) && this.text == other.text;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var base = _get(_getPrototypeOf(TextNode.prototype), "toJSON", this).call(this);
      base.text = this.text;
      return base;
    }
  }]);
  return TextNode;
}(Node);
function wrapMarks(marks, str) {
  for (var i = marks.length - 1; i >= 0; i--) str = marks[i].type.name + "(" + str + ")";
  return str;
}

/**
Instances of this class represent a match state of a node type's
[content expression](https://prosemirror.net/docs/ref/#model.NodeSpec.content), and can be used to
find out whether further content matches here, and whether a given
position is a valid end of the node.
*/
var ContentMatch = /*#__PURE__*/function () {
  /**
  @internal
  */
  function ContentMatch(
  /**
  True when this match state represents a valid end of the node.
  */
  validEnd) {
    _classCallCheck(this, ContentMatch);
    this.validEnd = validEnd;
    /**
    @internal
    */
    this.next = [];
    /**
    @internal
    */
    this.wrapCache = [];
  }
  /**
  @internal
  */
  _createClass(ContentMatch, [{
    key: "matchType",
    value:
    /**
    Match a node type, returning a match after that node if
    successful.
    */
    function matchType(type) {
      for (var i = 0; i < this.next.length; i++) if (this.next[i].type == type) return this.next[i].next;
      return null;
    }
    /**
    Try to match a fragment. Returns the resulting match when
    successful.
    */
  }, {
    key: "matchFragment",
    value: function matchFragment(frag) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : frag.childCount;
      var cur = this;
      for (var i = start; cur && i < end; i++) cur = cur.matchType(frag.child(i).type);
      return cur;
    }
    /**
    @internal
    */
  }, {
    key: "inlineContent",
    get: function get() {
      return this.next.length != 0 && this.next[0].type.isInline;
    }
    /**
    Get the first matching node type at this match position that can
    be generated.
    */
  }, {
    key: "defaultType",
    get: function get() {
      for (var i = 0; i < this.next.length; i++) {
        var type = this.next[i].type;
        if (!(type.isText || type.hasRequiredAttrs())) return type;
      }
      return null;
    }
    /**
    @internal
    */
  }, {
    key: "compatible",
    value: function compatible(other) {
      for (var i = 0; i < this.next.length; i++) for (var j = 0; j < other.next.length; j++) if (this.next[i].type == other.next[j].type) return true;
      return false;
    }
    /**
    Try to match the given fragment, and if that fails, see if it can
    be made to match by inserting nodes in front of it. When
    successful, return a fragment of inserted nodes (which may be
    empty if nothing had to be inserted). When `toEnd` is true, only
    return a fragment if the resulting match goes to the end of the
    content expression.
    */
  }, {
    key: "fillBefore",
    value: function fillBefore(after) {
      var toEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var seen = [this];
      function search(match, types) {
        var finished = match.matchFragment(after, startIndex);
        if (finished && (!toEnd || finished.validEnd)) return Fragment.from(types.map(function (tp) {
          return tp.createAndFill();
        }));
        for (var i = 0; i < match.next.length; i++) {
          var _match$next$i = match.next[i],
            type = _match$next$i.type,
            next = _match$next$i.next;
          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
            seen.push(next);
            var _found = search(next, types.concat(type));
            if (_found) return _found;
          }
        }
        return null;
      }
      return search(this, []);
    }
    /**
    Find a set of wrapping node types that would allow a node of the
    given type to appear at this position. The result may be empty
    (when it fits directly) and will be null when no such wrapping
    exists.
    */
  }, {
    key: "findWrapping",
    value: function findWrapping(target) {
      for (var i = 0; i < this.wrapCache.length; i += 2) if (this.wrapCache[i] == target) return this.wrapCache[i + 1];
      var computed = this.computeWrapping(target);
      this.wrapCache.push(target, computed);
      return computed;
    }
    /**
    @internal
    */
  }, {
    key: "computeWrapping",
    value: function computeWrapping(target) {
      var seen = Object.create(null),
        active = [{
          match: this,
          type: null,
          via: null
        }];
      while (active.length) {
        var current = active.shift(),
          match = current.match;
        if (match.matchType(target)) {
          var result = [];
          for (var obj = current; obj.type; obj = obj.via) result.push(obj.type);
          return result.reverse();
        }
        for (var i = 0; i < match.next.length; i++) {
          var _match$next$i2 = match.next[i],
            type = _match$next$i2.type,
            next = _match$next$i2.next;
          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
            active.push({
              match: type.contentMatch,
              type: type,
              via: current
            });
            seen[type.name] = true;
          }
        }
      }
      return null;
    }
    /**
    The number of outgoing edges this node has in the finite
    automaton that describes the content expression.
    */
  }, {
    key: "edgeCount",
    get: function get() {
      return this.next.length;
    }
    /**
    Get the _n_th outgoing edge from this node in the finite
    automaton that describes the content expression.
    */
  }, {
    key: "edge",
    value: function edge(n) {
      if (n >= this.next.length) throw new RangeError("There's no ".concat(n, "th edge in this content match"));
      return this.next[n];
    }
    /**
    @internal
    */
  }, {
    key: "toString",
    value: function toString() {
      var seen = [];
      function scan(m) {
        seen.push(m);
        for (var i = 0; i < m.next.length; i++) if (seen.indexOf(m.next[i].next) == -1) scan(m.next[i].next);
      }
      scan(this);
      return seen.map(function (m, i) {
        var out = i + (m.validEnd ? "*" : " ") + " ";
        for (var _i = 0; _i < m.next.length; _i++) out += (_i ? ", " : "") + m.next[_i].type.name + "->" + seen.indexOf(m.next[_i].next);
        return out;
      }).join("\n");
    }
  }], [{
    key: "parse",
    value: function parse(string, nodeTypes) {
      var stream = new TokenStream(string, nodeTypes);
      if (stream.next == null) return ContentMatch.empty;
      var expr = parseExpr(stream);
      if (stream.next) stream.err("Unexpected trailing text");
      var match = dfa(nfa(expr));
      checkForDeadEnds(match, stream);
      return match;
    }
  }]);
  return ContentMatch;
}();
/**
@internal
*/
ContentMatch.empty = new ContentMatch(true);
var TokenStream = /*#__PURE__*/function () {
  function TokenStream(string, nodeTypes) {
    _classCallCheck(this, TokenStream);
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "") this.tokens.pop();
    if (this.tokens[0] == "") this.tokens.shift();
  }
  _createClass(TokenStream, [{
    key: "next",
    get: function get() {
      return this.tokens[this.pos];
    }
  }, {
    key: "eat",
    value: function eat(tok) {
      return this.next == tok && (this.pos++ || true);
    }
  }, {
    key: "err",
    value: function err(str) {
      throw new SyntaxError(str + " (in content expression '" + this.string + "')");
    }
  }]);
  return TokenStream;
}();
function parseExpr(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : {
    type: "choice",
    exprs: exprs
  };
}
function parseExprSeq(stream) {
  var exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : {
    type: "seq",
    exprs: exprs
  };
}
function parseExprSubscript(stream) {
  var expr = parseExprAtom(stream);
  for (;;) {
    if (stream.eat("+")) expr = {
      type: "plus",
      expr: expr
    };else if (stream.eat("*")) expr = {
      type: "star",
      expr: expr
    };else if (stream.eat("?")) expr = {
      type: "opt",
      expr: expr
    };else if (stream.eat("{")) expr = parseExprRange(stream, expr);else break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next)) stream.err("Expected number, got '" + stream.next + "'");
  var result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  var min = parseNum(stream),
    max = min;
  if (stream.eat(",")) {
    if (stream.next != "}") max = parseNum(stream);else max = -1;
  }
  if (!stream.eat("}")) stream.err("Unclosed braced range");
  return {
    type: "range",
    min: min,
    max: max,
    expr: expr
  };
}
function resolveName(stream, name) {
  var types = stream.nodeTypes,
    type = types[name];
  if (type) return [type];
  var result = [];
  for (var typeName in types) {
    var _type = types[typeName];
    if (_type.groups.indexOf(name) > -1) result.push(_type);
  }
  if (result.length == 0) stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr(stream);
    if (!stream.eat(")")) stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName(stream, stream.next).map(function (type) {
      if (stream.inline == null) stream.inline = type.isInline;else if (stream.inline != type.isInline) stream.err("Mixing inline and block content");
      return {
        type: "name",
        value: type
      };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : {
      type: "choice",
      exprs: exprs
    };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
/**
Construct an NFA from an expression as returned by the parser. The
NFA is represented as an array of states, which are themselves
arrays of edges, which are `{term, to}` objects. The first state is
the entry state and the last node is the success state.

Note that unlike typical NFAs, the edge ordering in this one is
significant, in that it is used to contruct filler content when
necessary.
*/
function nfa(expr) {
  var nfa = [[]];
  connect(compile(expr, 0), node());
  return nfa;
  function node() {
    return nfa.push([]) - 1;
  }
  function edge(from, to, term) {
    var edge = {
      term: term,
      to: to
    };
    nfa[from].push(edge);
    return edge;
  }
  function connect(edges, to) {
    edges.forEach(function (edge) {
      return edge.to = to;
    });
  }
  function compile(expr, from) {
    if (expr.type == "choice") {
      return expr.exprs.reduce(function (out, expr) {
        return out.concat(compile(expr, from));
      }, []);
    } else if (expr.type == "seq") {
      for (var i = 0;; i++) {
        var next = compile(expr.exprs[i], from);
        if (i == expr.exprs.length - 1) return next;
        connect(next, from = node());
      }
    } else if (expr.type == "star") {
      var loop = node();
      edge(from, loop);
      connect(compile(expr.expr, loop), loop);
      return [edge(loop)];
    } else if (expr.type == "plus") {
      var _loop = node();
      connect(compile(expr.expr, from), _loop);
      connect(compile(expr.expr, _loop), _loop);
      return [edge(_loop)];
    } else if (expr.type == "opt") {
      return [edge(from)].concat(compile(expr.expr, from));
    } else if (expr.type == "range") {
      var cur = from;
      for (var _i2 = 0; _i2 < expr.min; _i2++) {
        var _next = node();
        connect(compile(expr.expr, cur), _next);
        cur = _next;
      }
      if (expr.max == -1) {
        connect(compile(expr.expr, cur), cur);
      } else {
        for (var _i3 = expr.min; _i3 < expr.max; _i3++) {
          var _next2 = node();
          edge(cur, _next2);
          connect(compile(expr.expr, cur), _next2);
          cur = _next2;
        }
      }
      return [edge(cur)];
    } else if (expr.type == "name") {
      return [edge(from, undefined, expr.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a, b) {
  return b - a;
}
// Get the set of nodes reachable by null edges from `node`. Omit
// nodes with only a single null-out-edge, since they may lead to
// needless duplicated nodes.
function nullFrom(nfa, node) {
  var result = [];
  scan(node);
  return result.sort(cmp);
  function scan(node) {
    var edges = nfa[node];
    if (edges.length == 1 && !edges[0].term) return scan(edges[0].to);
    result.push(node);
    for (var i = 0; i < edges.length; i++) {
      var _edges$i = edges[i],
        term = _edges$i.term,
        to = _edges$i.to;
      if (!term && result.indexOf(to) == -1) scan(to);
    }
  }
}
// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set
// of state objects (`ContentMatch` instances) with transitions
// between them.
function dfa(nfa) {
  var labeled = Object.create(null);
  return explore(nullFrom(nfa, 0));
  function explore(states) {
    var out = [];
    states.forEach(function (node) {
      nfa[node].forEach(function (_ref) {
        var term = _ref.term,
          to = _ref.to;
        if (!term) return;
        var set;
        for (var i = 0; i < out.length; i++) if (out[i][0] == term) set = out[i][1];
        nullFrom(nfa, to).forEach(function (node) {
          if (!set) out.push([term, set = []]);
          if (set.indexOf(node) == -1) set.push(node);
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);
    for (var i = 0; i < out.length; i++) {
      var _states = out[i][1].sort(cmp);
      state.next.push({
        type: out[i][0],
        next: labeled[_states.join(",")] || explore(_states)
      });
    }
    return state;
  }
}
function checkForDeadEnds(match, stream) {
  for (var i = 0, work = [match]; i < work.length; i++) {
    var state = work[i],
      dead = !state.validEnd,
      nodes = [];
    for (var j = 0; j < state.next.length; j++) {
      var _state$next$j = state.next[j],
        type = _state$next$j.type,
        next = _state$next$j.next;
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs())) dead = false;
      if (work.indexOf(next) == -1) work.push(next);
    }
    if (dead) stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}

// For node types where all attrs have a default value (or which don't
// have any attributes), build up a single reusable default attribute
// object, and use it for all nodes that don't specify specific
// attributes.
function defaultAttrs(attrs) {
  var defaults = Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) return null;
    defaults[attrName] = attr["default"];
  }
  return defaults;
}
function _computeAttrs(attrs, value) {
  var built = Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === undefined) {
      var attr = attrs[name];
      if (attr.hasDefault) given = attr["default"];else throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function initAttrs(attrs) {
  var result = Object.create(null);
  if (attrs) for (var name in attrs) result[name] = new Attribute(attrs[name]);
  return result;
}
/**
Node types are objects allocated once per `Schema` and used to
[tag](https://prosemirror.net/docs/ref/#model.Node.type) `Node` instances. They contain information
about the node type, such as its name and what kind of node it
represents.
*/
var NodeType = /*#__PURE__*/function () {
  /**
  @internal
  */
  function NodeType(
  /**
  The name the node type has in this schema.
  */
  name,
  /**
  A link back to the `Schema` the node type belongs to.
  */
  schema,
  /**
  The spec that this type is based on
  */
  spec) {
    _classCallCheck(this, NodeType);
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    /**
    The set of marks allowed in this node. `null` means all marks
    are allowed.
    */
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  /**
  True if this is an inline type.
  */
  _createClass(NodeType, [{
    key: "isInline",
    get: function get() {
      return !this.isBlock;
    }
    /**
    True if this is a textblock type, a block that contains inline
    content.
    */
  }, {
    key: "isTextblock",
    get: function get() {
      return this.isBlock && this.inlineContent;
    }
    /**
    True for node types that allow no content.
    */
  }, {
    key: "isLeaf",
    get: function get() {
      return this.contentMatch == ContentMatch.empty;
    }
    /**
    True when this node is an atom, i.e. when it does not have
    directly editable content.
    */
  }, {
    key: "isAtom",
    get: function get() {
      return this.isLeaf || !!this.spec.atom;
    }
    /**
    The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
    */
  }, {
    key: "whitespace",
    get: function get() {
      return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
    }
    /**
    Tells you whether this node type has any required attributes.
    */
  }, {
    key: "hasRequiredAttrs",
    value: function hasRequiredAttrs() {
      for (var n in this.attrs) if (this.attrs[n].isRequired) return true;
      return false;
    }
    /**
    Indicates whether this node allows some of the same content as
    the given node type.
    */
  }, {
    key: "compatibleContent",
    value: function compatibleContent(other) {
      return this == other || this.contentMatch.compatible(other.contentMatch);
    }
    /**
    @internal
    */
  }, {
    key: "computeAttrs",
    value: function computeAttrs(attrs) {
      if (!attrs && this.defaultAttrs) return this.defaultAttrs;else return _computeAttrs(this.attrs, attrs);
    }
    /**
    Create a `Node` of this type. The given attributes are
    checked and defaulted (you can pass `null` to use the type's
    defaults entirely, if no required attributes exist). `content`
    may be a `Fragment`, a node, an array of nodes, or
    `null`. Similarly `marks` may be `null` to default to the empty
    set of marks.
    */
  }, {
    key: "create",
    value: function create() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var content = arguments.length > 1 ? arguments[1] : undefined;
      var marks = arguments.length > 2 ? arguments[2] : undefined;
      if (this.isText) throw new Error("NodeType.create can't construct text nodes");
      return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
    }
    /**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
    against the node type's content restrictions, and throw an error
    if it doesn't match.
    */
  }, {
    key: "createChecked",
    value: function createChecked() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var content = arguments.length > 1 ? arguments[1] : undefined;
      var marks = arguments.length > 2 ? arguments[2] : undefined;
      content = Fragment.from(content);
      this.checkContent(content);
      return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
    }
    /**
    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
    necessary to add nodes to the start or end of the given fragment
    to make it fit the node. If no fitting wrapping can be found,
    return null. Note that, due to the fact that required nodes can
    always be created, this will always succeed if you pass null or
    `Fragment.empty` as content.
    */
  }, {
    key: "createAndFill",
    value: function createAndFill() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var content = arguments.length > 1 ? arguments[1] : undefined;
      var marks = arguments.length > 2 ? arguments[2] : undefined;
      attrs = this.computeAttrs(attrs);
      content = Fragment.from(content);
      if (content.size) {
        var before = this.contentMatch.fillBefore(content);
        if (!before) return null;
        content = before.append(content);
      }
      var matched = this.contentMatch.matchFragment(content);
      var after = matched && matched.fillBefore(Fragment.empty, true);
      if (!after) return null;
      return new Node(this, attrs, content.append(after), Mark.setFrom(marks));
    }
    /**
    Returns true if the given fragment is valid content for this node
    type with the given attributes.
    */
  }, {
    key: "validContent",
    value: function validContent(content) {
      var result = this.contentMatch.matchFragment(content);
      if (!result || !result.validEnd) return false;
      for (var i = 0; i < content.childCount; i++) if (!this.allowsMarks(content.child(i).marks)) return false;
      return true;
    }
    /**
    Throws a RangeError if the given fragment is not valid content for this
    node type.
    @internal
    */
  }, {
    key: "checkContent",
    value: function checkContent(content) {
      if (!this.validContent(content)) throw new RangeError("Invalid content for node ".concat(this.name, ": ").concat(content.toString().slice(0, 50)));
    }
    /**
    Check whether the given mark type is allowed in this node.
    */
  }, {
    key: "allowsMarkType",
    value: function allowsMarkType(markType) {
      return this.markSet == null || this.markSet.indexOf(markType) > -1;
    }
    /**
    Test whether the given set of marks are allowed in this node.
    */
  }, {
    key: "allowsMarks",
    value: function allowsMarks(marks) {
      if (this.markSet == null) return true;
      for (var i = 0; i < marks.length; i++) if (!this.allowsMarkType(marks[i].type)) return false;
      return true;
    }
    /**
    Removes the marks that are not allowed in this node from the given set.
    */
  }, {
    key: "allowedMarks",
    value: function allowedMarks(marks) {
      if (this.markSet == null) return marks;
      var copy;
      for (var i = 0; i < marks.length; i++) {
        if (!this.allowsMarkType(marks[i].type)) {
          if (!copy) copy = marks.slice(0, i);
        } else if (copy) {
          copy.push(marks[i]);
        }
      }
      return !copy ? marks : copy.length ? copy : Mark.none;
    }
    /**
    @internal
    */
  }], [{
    key: "compile",
    value: function compile(nodes, schema) {
      var result = Object.create(null);
      nodes.forEach(function (name, spec) {
        return result[name] = new NodeType(name, schema, spec);
      });
      var topType = schema.spec.topNode || "doc";
      if (!result[topType]) throw new RangeError("Schema is missing its top node type ('" + topType + "')");
      if (!result.text) throw new RangeError("Every schema needs a 'text' type");
      for (var _ in result.text.attrs) throw new RangeError("The text node type should not have attributes");
      return result;
    }
  }]);
  return NodeType;
}(); // Attribute descriptors
var Attribute = /*#__PURE__*/function () {
  function Attribute(options) {
    _classCallCheck(this, Attribute);
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this["default"] = options["default"];
  }
  _createClass(Attribute, [{
    key: "isRequired",
    get: function get() {
      return !this.hasDefault;
    }
  }]);
  return Attribute;
}(); // Marks
/**
Like nodes, marks (which are associated with nodes to signify
things like emphasis or being part of a link) are
[tagged](https://prosemirror.net/docs/ref/#model.Mark.type) with type objects, which are
instantiated once per `Schema`.
*/
var MarkType = /*#__PURE__*/function () {
  /**
  @internal
  */
  function MarkType(
  /**
  The name of the mark type.
  */
  name,
  /**
  @internal
  */
  rank,
  /**
  The schema that this mark type instance is part of.
  */
  schema,
  /**
  The spec on which the type is based.
  */
  spec) {
    _classCallCheck(this, MarkType);
    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(spec.attrs);
    this.excluded = null;
    var defaults = defaultAttrs(this.attrs);
    this.instance = defaults ? new Mark(this, defaults) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  _createClass(MarkType, [{
    key: "create",
    value: function create() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (!attrs && this.instance) return this.instance;
      return new Mark(this, _computeAttrs(this.attrs, attrs));
    }
    /**
    @internal
    */
  }, {
    key: "removeFromSet",
    value:
    /**
    When there is a mark of this type in the given set, a new set
    without it is returned. Otherwise, the input set is returned.
    */
    function removeFromSet(set) {
      for (var i = 0; i < set.length; i++) if (set[i].type == this) {
        set = set.slice(0, i).concat(set.slice(i + 1));
        i--;
      }
      return set;
    }
    /**
    Tests whether there is a mark of this type in the given set.
    */
  }, {
    key: "isInSet",
    value: function isInSet(set) {
      for (var i = 0; i < set.length; i++) if (set[i].type == this) return set[i];
    }
    /**
    Queries whether a given mark type is
    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
    */
  }, {
    key: "excludes",
    value: function excludes(other) {
      return this.excluded.indexOf(other) > -1;
    }
  }], [{
    key: "compile",
    value: function compile(marks, schema) {
      var result = Object.create(null),
        rank = 0;
      marks.forEach(function (name, spec) {
        return result[name] = new MarkType(name, rank++, schema, spec);
      });
      return result;
    }
  }]);
  return MarkType;
}();
/**
A document schema. Holds [node](https://prosemirror.net/docs/ref/#model.NodeType) and [mark
type](https://prosemirror.net/docs/ref/#model.MarkType) objects for the nodes and marks that may
occur in conforming documents, and provides functionality for
creating and deserializing such documents.

When given, the type parameters provide the names of the nodes and
marks in this schema.
*/
var Schema = /*#__PURE__*/function () {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  function Schema(spec) {
    _classCallCheck(this, Schema);
    /**
    An object for storing whatever values modules may want to
    compute and cache per schema. (If you want to store something
    in it, try to use property names unlikely to clash.)
    */
    this.cached = Object.create(null);
    var instanceSpec = this.spec = {};
    for (var prop in spec) instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = orderedmap__WEBPACK_IMPORTED_MODULE_0__["default"].from(spec.nodes), instanceSpec.marks = orderedmap__WEBPACK_IMPORTED_MODULE_0__["default"].from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    var contentExprCache = Object.create(null);
    for (var _prop in this.nodes) {
      if (_prop in this.marks) throw new RangeError(_prop + " can not be both a node and a mark");
      var type = this.nodes[_prop],
        contentExpr = type.spec.content || "",
        markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }
    for (var _prop2 in this.marks) {
      var _type2 = this.marks[_prop2],
        excl = _type2.spec.excludes;
      _type2.excluded = excl == null ? [_type2] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  _createClass(Schema, [{
    key: "node",
    value: function node(type) {
      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var content = arguments.length > 2 ? arguments[2] : undefined;
      var marks = arguments.length > 3 ? arguments[3] : undefined;
      if (typeof type == "string") type = this.nodeType(type);else if (!(type instanceof NodeType)) throw new RangeError("Invalid node type: " + type);else if (type.schema != this) throw new RangeError("Node type from different schema used (" + type.name + ")");
      return type.createChecked(attrs, content, marks);
    }
    /**
    Create a text node in the schema. Empty text nodes are not
    allowed.
    */
  }, {
    key: "text",
    value: function text(_text, marks) {
      var type = this.nodes.text;
      return new TextNode(type, type.defaultAttrs, _text, Mark.setFrom(marks));
    }
    /**
    Create a mark with the given type and attributes.
    */
  }, {
    key: "mark",
    value: function mark(type, attrs) {
      if (typeof type == "string") type = this.marks[type];
      return type.create(attrs);
    }
    /**
    Deserialize a node from its JSON representation. This method is
    bound.
    */
  }, {
    key: "nodeFromJSON",
    value: function nodeFromJSON(json) {
      return Node.fromJSON(this, json);
    }
    /**
    Deserialize a mark from its JSON representation. This method is
    bound.
    */
  }, {
    key: "markFromJSON",
    value: function markFromJSON(json) {
      return Mark.fromJSON(this, json);
    }
    /**
    @internal
    */
  }, {
    key: "nodeType",
    value: function nodeType(name) {
      var found = this.nodes[name];
      if (!found) throw new RangeError("Unknown node type: " + name);
      return found;
    }
  }]);
  return Schema;
}();
function gatherMarks(schema, marks) {
  var found = [];
  for (var i = 0; i < marks.length; i++) {
    var name = marks[i],
      mark = schema.marks[name],
      ok = mark;
    if (mark) {
      found.push(mark);
    } else {
      for (var prop in schema.marks) {
        var _mark = schema.marks[prop];
        if (name == "_" || _mark.spec.group && _mark.spec.group.split(" ").indexOf(name) > -1) found.push(ok = _mark);
      }
    }
    if (!ok) throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }
  return found;
}

/**
A DOM parser represents a strategy for parsing DOM content into a
ProseMirror document conforming to a given schema. Its behavior is
defined by an array of [rules](https://prosemirror.net/docs/ref/#model.ParseRule).
*/
var DOMParser = /*#__PURE__*/function () {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  function DOMParser(
  /**
  The schema into which the parser parses.
  */
  schema,
  /**
  The set of [parse rules](https://prosemirror.net/docs/ref/#model.ParseRule) that the parser
  uses, in order of precedence.
  */
  rules) {
    var _this2 = this;
    _classCallCheck(this, DOMParser);
    this.schema = schema;
    this.rules = rules;
    /**
    @internal
    */
    this.tags = [];
    /**
    @internal
    */
    this.styles = [];
    rules.forEach(function (rule) {
      if (rule.tag) _this2.tags.push(rule);else if (rule.style) _this2.styles.push(rule);
    });
    // Only normalize list elements when lists in the schema can't directly contain themselves
    this.normalizeLists = !this.tags.some(function (r) {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node) return false;
      var node = schema.nodes[r.node];
      return node.contentMatch.matchType(node);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  _createClass(DOMParser, [{
    key: "parse",
    value: function parse(dom) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var context = new ParseContext(this, options, false);
      context.addAll(dom, options.from, options.to);
      return context.finish();
    }
    /**
    Parses the content of the given DOM node, like
    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
    options. But unlike that method, which produces a whole node,
    this one returns a slice that is open at the sides, meaning that
    the schema constraints aren't applied to the start of nodes to
    the left of the input and the end of nodes at the end.
    */
  }, {
    key: "parseSlice",
    value: function parseSlice(dom) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var context = new ParseContext(this, options, true);
      context.addAll(dom, options.from, options.to);
      return Slice.maxOpen(context.finish());
    }
    /**
    @internal
    */
  }, {
    key: "matchTag",
    value: function matchTag(dom, context, after) {
      for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
        var rule = this.tags[i];
        if (matches(dom, rule.tag) && (rule.namespace === undefined || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
          if (rule.getAttrs) {
            var result = rule.getAttrs(dom);
            if (result === false) continue;
            rule.attrs = result || undefined;
          }
          return rule;
        }
      }
    }
    /**
    @internal
    */
  }, {
    key: "matchStyle",
    value: function matchStyle(prop, value, context, after) {
      for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
        var rule = this.styles[i],
          style = rule.style;
        if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) ||
        // Test that the style string either precisely matches the prop,
        // or has an '=' sign after the prop, followed by the given
        // value.
        style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value)) continue;
        if (rule.getAttrs) {
          var result = rule.getAttrs(value);
          if (result === false) continue;
          rule.attrs = result || undefined;
        }
        return rule;
      }
    }
    /**
    @internal
    */
  }], [{
    key: "schemaRules",
    value: function schemaRules(schema) {
      var result = [];
      function insert(rule) {
        var priority = rule.priority == null ? 50 : rule.priority,
          i = 0;
        for (; i < result.length; i++) {
          var next = result[i],
            nextPriority = next.priority == null ? 50 : next.priority;
          if (nextPriority < priority) break;
        }
        result.splice(i, 0, rule);
      }
      var _loop2 = function _loop2(name) {
        var rules = schema.marks[name].spec.parseDOM;
        if (rules) rules.forEach(function (rule) {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark)) rule.mark = name;
        });
      };
      for (var name in schema.marks) {
        _loop2(name);
      }
      var _loop3 = function _loop3(_name) {
        var rules = schema.nodes[_name].spec.parseDOM;
        if (rules) rules.forEach(function (rule) {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark)) rule.node = _name;
        });
      };
      for (var _name in schema.nodes) {
        _loop3(_name);
      }
      return result;
    }
    /**
    Construct a DOM parser using the parsing rules listed in a
    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
    [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
    */
  }, {
    key: "fromSchema",
    value: function fromSchema(schema) {
      return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));
    }
  }]);
  return DOMParser;
}();
var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = {
  ol: true,
  ul: true
};
// Using a bitfield for node context options
var OPT_PRESERVE_WS = 1,
  OPT_PRESERVE_WS_FULL = 2,
  OPT_OPEN_LEFT = 4;
function wsOptionsFor(type, preserveWhitespace, base) {
  if (preserveWhitespace != null) return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;
}
var NodeContext = /*#__PURE__*/function () {
  function NodeContext(type, attrs,
  // Marks applied to this node itself
  marks,
  // Marks that can't apply here, but will be used in children if possible
  pendingMarks, solid, match, options) {
    _classCallCheck(this, NodeContext);
    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.pendingMarks = pendingMarks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    // Marks applied to the node's children
    this.activeMarks = Mark.none;
    // Nested Marks with same type
    this.stashMarks = [];
    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  }
  _createClass(NodeContext, [{
    key: "findWrapping",
    value: function findWrapping(node) {
      if (!this.match) {
        if (!this.type) return [];
        var fill = this.type.contentMatch.fillBefore(Fragment.from(node));
        if (fill) {
          this.match = this.type.contentMatch.matchFragment(fill);
        } else {
          var start = this.type.contentMatch,
            wrap;
          if (wrap = start.findWrapping(node.type)) {
            this.match = start;
            return wrap;
          } else {
            return null;
          }
        }
      }
      return this.match.findWrapping(node.type);
    }
  }, {
    key: "finish",
    value: function finish(openEnd) {
      if (!(this.options & OPT_PRESERVE_WS)) {
        // Strip trailing whitespace
        var last = this.content[this.content.length - 1],
          m;
        if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
          var text = last;
          if (last.text.length == m[0].length) this.content.pop();else this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
        }
      }
      var content = Fragment.from(this.content);
      if (!openEnd && this.match) content = content.append(this.match.fillBefore(Fragment.empty, true));
      return this.type ? this.type.create(this.attrs, content, this.marks) : content;
    }
  }, {
    key: "popFromStashMark",
    value: function popFromStashMark(mark) {
      for (var i = this.stashMarks.length - 1; i >= 0; i--) if (mark.eq(this.stashMarks[i])) return this.stashMarks.splice(i, 1)[0];
    }
  }, {
    key: "applyPending",
    value: function applyPending(nextType) {
      for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {
        var mark = pending[i];
        if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {
          this.activeMarks = mark.addToSet(this.activeMarks);
          this.pendingMarks = mark.removeFromSet(this.pendingMarks);
        }
      }
    }
  }, {
    key: "inlineContext",
    value: function inlineContext(node) {
      if (this.type) return this.type.inlineContent;
      if (this.content.length) return this.content[0].isInline;
      return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
    }
  }]);
  return NodeContext;
}();
var ParseContext = /*#__PURE__*/function () {
  function ParseContext(
  // The parser we are using.
  parser,
  // The options passed to this parse.
  options, isOpen) {
    _classCallCheck(this, ParseContext);
    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    var topNode = options.topNode,
      topContext;
    var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode) topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);else if (isOpen) topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);else topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }
  _createClass(ParseContext, [{
    key: "top",
    get: function get() {
      return this.nodes[this.open];
    }
    // Add a DOM node to the content. Text is inserted as text node,
    // otherwise, the node is passed to `addElement` or, if it has a
    // `style` attribute, `addElementWithStyles`.
  }, {
    key: "addDOM",
    value: function addDOM(dom) {
      if (dom.nodeType == 3) this.addTextNode(dom);else if (dom.nodeType == 1) this.addElement(dom);
    }
  }, {
    key: "withStyleRules",
    value: function withStyleRules(dom, f) {
      var style = dom.getAttribute("style");
      if (!style) return f();
      var marks = this.readStyles(parseStyles(style));
      if (!marks) return; // A style with ignore: true
      var _marks = _slicedToArray(marks, 2),
        addMarks = _marks[0],
        removeMarks = _marks[1],
        top = this.top;
      for (var i = 0; i < removeMarks.length; i++) this.removePendingMark(removeMarks[i], top);
      for (var _i4 = 0; _i4 < addMarks.length; _i4++) this.addPendingMark(addMarks[_i4]);
      f();
      for (var _i5 = 0; _i5 < addMarks.length; _i5++) this.removePendingMark(addMarks[_i5], top);
      for (var _i6 = 0; _i6 < removeMarks.length; _i6++) this.addPendingMark(removeMarks[_i6]);
    }
  }, {
    key: "addTextNode",
    value: function addTextNode(dom) {
      var value = dom.nodeValue;
      var top = this.top;
      if (top.options & OPT_PRESERVE_WS_FULL || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
        if (!(top.options & OPT_PRESERVE_WS)) {
          value = value.replace(/[ \t\r\n\u000c]+/g, " ");
          // If this starts with whitespace, and there is no node before it, or
          // a hard break, or a text node that ends with whitespace, strip the
          // leading space.
          if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
            var nodeBefore = top.content[top.content.length - 1];
            var domNodeBefore = dom.previousSibling;
            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == 'BR' || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)) value = value.slice(1);
          }
        } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
          value = value.replace(/\r?\n|\r/g, " ");
        } else {
          value = value.replace(/\r\n?/g, "\n");
        }
        if (value) this.insertNode(this.parser.schema.text(value));
        this.findInText(dom);
      } else {
        this.findInside(dom);
      }
    }
    // Try to find a handler for the given tag and use that to parse. If
    // none is found, the element's content nodes are added directly.
  }, {
    key: "addElement",
    value: function addElement(dom, matchAfter) {
      var _this3 = this;
      var name = dom.nodeName.toLowerCase(),
        ruleID;
      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom);
      var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
      if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
        this.findInside(dom);
        this.ignoreFallback(dom);
      } else if (!rule || rule.skip || rule.closeParent) {
        if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1);else if (rule && rule.skip.nodeType) dom = rule.skip;
        var sync,
          top = this.top,
          oldNeedsBlock = this.needsBlock;
        if (blockTags.hasOwnProperty(name)) {
          if (top.content.length && top.content[0].isInline && this.open) {
            this.open--;
            top = this.top;
          }
          sync = true;
          if (!top.type) this.needsBlock = true;
        } else if (!dom.firstChild) {
          this.leafFallback(dom);
          return;
        }
        if (rule && rule.skip) this.addAll(dom);else this.withStyleRules(dom, function () {
          return _this3.addAll(dom);
        });
        if (sync) this.sync(top);
        this.needsBlock = oldNeedsBlock;
      } else {
        this.withStyleRules(dom, function () {
          _this3.addElementByRule(dom, rule, rule.consuming === false ? ruleID : undefined);
        });
      }
    }
    // Called for leaf DOM nodes that would otherwise be ignored
  }, {
    key: "leafFallback",
    value: function leafFallback(dom) {
      if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent) this.addTextNode(dom.ownerDocument.createTextNode("\n"));
    }
    // Called for ignored nodes
  }, {
    key: "ignoreFallback",
    value: function ignoreFallback(dom) {
      // Ignored BR nodes should at least create an inline context
      if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent)) this.findPlace(this.parser.schema.text("-"));
    }
    // Run any style parser associated with the node's styles. Either
    // return an array of marks, or null to indicate some of the styles
    // had a rule with `ignore` set.
  }, {
    key: "readStyles",
    value: function readStyles(styles) {
      var _this4 = this;
      var add = Mark.none,
        remove = Mark.none;
      for (var i = 0; i < styles.length; i += 2) {
        var _loop4 = function _loop4(_after) {
            var rule = _this4.parser.matchStyle(styles[i], styles[i + 1], _this4, _after);
            if (!rule) {
              after = _after;
              return 0;
            } // break
            if (rule.ignore) return {
              v: null
            };
            if (rule.clearMark) {
              _this4.top.pendingMarks.concat(_this4.top.activeMarks).forEach(function (m) {
                if (rule.clearMark(m)) remove = m.addToSet(remove);
              });
            } else {
              add = _this4.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(add);
            }
            if (rule.consuming === false) _after = rule;else {
              after = _after;
              return 0;
            } // break
            after = _after;
          },
          _ret;
        for (var after = undefined;;) {
          _ret = _loop4(after);
          if (_ret === 0) break;
          if (_ret) return _ret.v;
        }
      }
      return [add, remove];
    }
    // Look up a handler for the given node. If none are found, return
    // false. Otherwise, apply it, use its return value to drive the way
    // the node's content is wrapped, and return true.
  }, {
    key: "addElementByRule",
    value: function addElementByRule(dom, rule, continueAfter) {
      var _this5 = this;
      var sync, nodeType, mark;
      if (rule.node) {
        nodeType = this.parser.schema.nodes[rule.node];
        if (!nodeType.isLeaf) {
          sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);
        } else if (!this.insertNode(nodeType.create(rule.attrs))) {
          this.leafFallback(dom);
        }
      } else {
        var markType = this.parser.schema.marks[rule.mark];
        mark = markType.create(rule.attrs);
        this.addPendingMark(mark);
      }
      var startIn = this.top;
      if (nodeType && nodeType.isLeaf) {
        this.findInside(dom);
      } else if (continueAfter) {
        this.addElement(dom, continueAfter);
      } else if (rule.getContent) {
        this.findInside(dom);
        rule.getContent(dom, this.parser.schema).forEach(function (node) {
          return _this5.insertNode(node);
        });
      } else {
        var contentDOM = dom;
        if (typeof rule.contentElement == "string") contentDOM = dom.querySelector(rule.contentElement);else if (typeof rule.contentElement == "function") contentDOM = rule.contentElement(dom);else if (rule.contentElement) contentDOM = rule.contentElement;
        this.findAround(dom, contentDOM, true);
        this.addAll(contentDOM);
      }
      if (sync && this.sync(startIn)) this.open--;
      if (mark) this.removePendingMark(mark, startIn);
    }
    // Add all child nodes between `startIndex` and `endIndex` (or the
    // whole node, if not given). If `sync` is passed, use it to
    // synchronize after every block element.
  }, {
    key: "addAll",
    value: function addAll(parent, startIndex, endIndex) {
      var index = startIndex || 0;
      for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {
        this.findAtPoint(parent, index);
        this.addDOM(dom);
      }
      this.findAtPoint(parent, index);
    }
    // Try to find a way to fit the given node type into the current
    // context. May add intermediate wrappers and/or leave non-solid
    // nodes that we're in.
  }, {
    key: "findPlace",
    value: function findPlace(node) {
      var route, sync;
      for (var depth = this.open; depth >= 0; depth--) {
        var cx = this.nodes[depth];
        var _found2 = cx.findWrapping(node);
        if (_found2 && (!route || route.length > _found2.length)) {
          route = _found2;
          sync = cx;
          if (!_found2.length) break;
        }
        if (cx.solid) break;
      }
      if (!route) return false;
      this.sync(sync);
      for (var i = 0; i < route.length; i++) this.enterInner(route[i], null, false);
      return true;
    }
    // Try to insert the given node, adjusting the context when needed.
  }, {
    key: "insertNode",
    value: function insertNode(node) {
      if (node.isInline && this.needsBlock && !this.top.type) {
        var block = this.textblockFromContext();
        if (block) this.enterInner(block);
      }
      if (this.findPlace(node)) {
        this.closeExtra();
        var top = this.top;
        top.applyPending(node.type);
        if (top.match) top.match = top.match.matchType(node.type);
        var marks = top.activeMarks;
        for (var i = 0; i < node.marks.length; i++) if (!top.type || top.type.allowsMarkType(node.marks[i].type)) marks = node.marks[i].addToSet(marks);
        top.content.push(node.mark(marks));
        return true;
      }
      return false;
    }
    // Try to start a node of the given type, adjusting the context when
    // necessary.
  }, {
    key: "enter",
    value: function enter(type, attrs, preserveWS) {
      var ok = this.findPlace(type.create(attrs));
      if (ok) this.enterInner(type, attrs, true, preserveWS);
      return ok;
    }
    // Open a node of the given type
  }, {
    key: "enterInner",
    value: function enterInner(type) {
      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var solid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var preserveWS = arguments.length > 3 ? arguments[3] : undefined;
      this.closeExtra();
      var top = this.top;
      top.applyPending(type);
      top.match = top.match && top.match.matchType(type);
      var options = wsOptionsFor(type, preserveWS, top.options);
      if (top.options & OPT_OPEN_LEFT && top.content.length == 0) options |= OPT_OPEN_LEFT;
      this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));
      this.open++;
    }
    // Make sure all nodes above this.open are finished and added to
    // their parents
  }, {
    key: "closeExtra",
    value: function closeExtra() {
      var openEnd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var i = this.nodes.length - 1;
      if (i > this.open) {
        for (; i > this.open; i--) this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
        this.nodes.length = this.open + 1;
      }
    }
  }, {
    key: "finish",
    value: function finish() {
      this.open = 0;
      this.closeExtra(this.isOpen);
      return this.nodes[0].finish(this.isOpen || this.options.topOpen);
    }
  }, {
    key: "sync",
    value: function sync(to) {
      for (var i = this.open; i >= 0; i--) if (this.nodes[i] == to) {
        this.open = i;
        return true;
      }
      return false;
    }
  }, {
    key: "currentPos",
    get: function get() {
      this.closeExtra();
      var pos = 0;
      for (var i = this.open; i >= 0; i--) {
        var content = this.nodes[i].content;
        for (var j = content.length - 1; j >= 0; j--) pos += content[j].nodeSize;
        if (i) pos++;
      }
      return pos;
    }
  }, {
    key: "findAtPoint",
    value: function findAtPoint(parent, offset) {
      if (this.find) for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset) this.find[i].pos = this.currentPos;
      }
    }
  }, {
    key: "findInside",
    value: function findInside(parent) {
      if (this.find) for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) this.find[i].pos = this.currentPos;
      }
    }
  }, {
    key: "findAround",
    value: function findAround(parent, content, before) {
      if (parent != content && this.find) for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          var pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4)) this.find[i].pos = this.currentPos;
        }
      }
    }
  }, {
    key: "findInText",
    value: function findInText(textNode) {
      if (this.find) for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode) this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
    }
    // Determines whether the given context string matches this context.
  }, {
    key: "matchesContext",
    value: function matchesContext(context) {
      var _this6 = this;
      if (context.indexOf("|") > -1) return context.split(/\s*\|\s*/).some(this.matchesContext, this);
      var parts = context.split("/");
      var option = this.options.context;
      var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
      var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
      var match = function match(i, depth) {
        for (; i >= 0; i--) {
          var part = parts[i];
          if (part == "") {
            if (i == parts.length - 1 || i == 0) continue;
            for (; depth >= minDepth; depth--) if (match(i - 1, depth)) return true;
            return false;
          } else {
            var next = depth > 0 || depth == 0 && useRoot ? _this6.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
            if (!next || next.name != part && next.groups.indexOf(part) == -1) return false;
            depth--;
          }
        }
        return true;
      };
      return match(parts.length - 1, this.open);
    }
  }, {
    key: "textblockFromContext",
    value: function textblockFromContext() {
      var $context = this.options.context;
      if ($context) for (var d = $context.depth; d >= 0; d--) {
        var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt;
      }
      for (var name in this.parser.schema.nodes) {
        var type = this.parser.schema.nodes[name];
        if (type.isTextblock && type.defaultAttrs) return type;
      }
    }
  }, {
    key: "addPendingMark",
    value: function addPendingMark(mark) {
      var found = findSameMarkInSet(mark, this.top.pendingMarks);
      if (found) this.top.stashMarks.push(found);
      this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
    }
  }, {
    key: "removePendingMark",
    value: function removePendingMark(mark, upto) {
      for (var depth = this.open; depth >= 0; depth--) {
        var level = this.nodes[depth];
        var _found3 = level.pendingMarks.lastIndexOf(mark);
        if (_found3 > -1) {
          level.pendingMarks = mark.removeFromSet(level.pendingMarks);
        } else {
          level.activeMarks = mark.removeFromSet(level.activeMarks);
          var stashMark = level.popFromStashMark(mark);
          if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) level.activeMarks = stashMark.addToSet(level.activeMarks);
        }
        if (level == upto) break;
      }
    }
  }]);
  return ParseContext;
}(); // Kludge to work around directly nested list nodes produced by some
// tools and allowed by browsers to mean that the nested list is
// actually part of the list item above it.
function normalizeList(dom) {
  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
// Apply a CSS selector.
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
// Tokenize a style attribute into property/value pairs.
function parseStyles(style) {
  var re = /\s*([\w-]+)\s*:\s*([^;]+)/g,
    m,
    result = [];
  while (m = re.exec(style)) result.push(m[1], m[2].trim());
  return result;
}
function copy(obj) {
  var copy = {};
  for (var prop in obj) copy[prop] = obj[prop];
  return copy;
}
// Used when finding a mark at the top level of a fragment parse.
// Checks whether it would be reasonable to apply a given mark type to
// a given node, by looking at the way the mark occurs in the schema.
function markMayApply(markType, nodeType) {
  var nodes = nodeType.schema.nodes;
  var _loop5 = function _loop5() {
      var parent = nodes[name];
      if (!parent.allowsMarkType(markType)) return 0; // continue
      var seen = [],
        scan = function scan(match) {
          seen.push(match);
          for (var i = 0; i < match.edgeCount; i++) {
            var _match$edge = match.edge(i),
              type = _match$edge.type,
              next = _match$edge.next;
            if (type == nodeType) return true;
            if (seen.indexOf(next) < 0 && scan(next)) return true;
          }
        };
      if (scan(parent.contentMatch)) return {
        v: true
      };
    },
    _ret2;
  for (var name in nodes) {
    _ret2 = _loop5();
    if (_ret2 === 0) continue;
    if (_ret2) return _ret2.v;
  }
}
function findSameMarkInSet(mark, set) {
  for (var i = 0; i < set.length; i++) {
    if (mark.eq(set[i])) return set[i];
  }
}

/**
A DOM serializer knows how to convert ProseMirror nodes and
marks of various types to DOM nodes.
*/
var DOMSerializer = /*#__PURE__*/function () {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  function DOMSerializer(
  /**
  The node serialization functions.
  */
  nodes,
  /**
  The mark serialization functions.
  */
  marks) {
    _classCallCheck(this, DOMSerializer);
    this.nodes = nodes;
    this.marks = marks;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  _createClass(DOMSerializer, [{
    key: "serializeFragment",
    value: function serializeFragment(fragment) {
      var _this7 = this;
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var target = arguments.length > 2 ? arguments[2] : undefined;
      if (!target) target = doc(options).createDocumentFragment();
      var top = target,
        active = [];
      fragment.forEach(function (node) {
        if (active.length || node.marks.length) {
          var keep = 0,
            rendered = 0;
          while (keep < active.length && rendered < node.marks.length) {
            var next = node.marks[rendered];
            if (!_this7.marks[next.type.name]) {
              rendered++;
              continue;
            }
            if (!next.eq(active[keep][0]) || next.type.spec.spanning === false) break;
            keep++;
            rendered++;
          }
          while (keep < active.length) top = active.pop()[1];
          while (rendered < node.marks.length) {
            var add = node.marks[rendered++];
            var markDOM = _this7.serializeMark(add, node.isInline, options);
            if (markDOM) {
              active.push([add, top]);
              top.appendChild(markDOM.dom);
              top = markDOM.contentDOM || markDOM.dom;
            }
          }
        }
        top.appendChild(_this7.serializeNodeInner(node, options));
      });
      return target;
    }
    /**
    @internal
    */
  }, {
    key: "serializeNodeInner",
    value: function serializeNodeInner(node, options) {
      var _DOMSerializer$render = DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node)),
        dom = _DOMSerializer$render.dom,
        contentDOM = _DOMSerializer$render.contentDOM;
      if (contentDOM) {
        if (node.isLeaf) throw new RangeError("Content hole not allowed in a leaf node spec");
        this.serializeFragment(node.content, options, contentDOM);
      }
      return dom;
    }
    /**
    Serialize this node to a DOM node. This can be useful when you
    need to serialize a part of a document, as opposed to the whole
    document. To serialize a whole document, use
    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
    its [content](https://prosemirror.net/docs/ref/#model.Node.content).
    */
  }, {
    key: "serializeNode",
    value: function serializeNode(node) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var dom = this.serializeNodeInner(node, options);
      for (var i = node.marks.length - 1; i >= 0; i--) {
        var wrap = this.serializeMark(node.marks[i], node.isInline, options);
        if (wrap) {
          (wrap.contentDOM || wrap.dom).appendChild(dom);
          dom = wrap.dom;
        }
      }
      return dom;
    }
    /**
    @internal
    */
  }, {
    key: "serializeMark",
    value: function serializeMark(mark, inline) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var toDOM = this.marks[mark.type.name];
      return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline));
    }
    /**
    Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
    the spec has a hole (zero) in it, `contentDOM` will point at the
    node with the hole.
    */
  }], [{
    key: "renderSpec",
    value: function renderSpec(doc, structure) {
      var xmlNS = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      if (typeof structure == "string") return {
        dom: doc.createTextNode(structure)
      };
      if (structure.nodeType != null) return {
        dom: structure
      };
      if (structure.dom && structure.dom.nodeType != null) return structure;
      var tagName = structure[0],
        space = tagName.indexOf(" ");
      if (space > 0) {
        xmlNS = tagName.slice(0, space);
        tagName = tagName.slice(space + 1);
      }
      var contentDOM;
      var dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);
      var attrs = structure[1],
        start = 1;
      if (attrs && _typeof(attrs) == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
        start = 2;
        for (var name in attrs) if (attrs[name] != null) {
          var _space = name.indexOf(" ");
          if (_space > 0) dom.setAttributeNS(name.slice(0, _space), name.slice(_space + 1), attrs[name]);else dom.setAttribute(name, attrs[name]);
        }
      }
      for (var i = start; i < structure.length; i++) {
        var child = structure[i];
        if (child === 0) {
          if (i < structure.length - 1 || i > start) throw new RangeError("Content hole must be the only child of its parent node");
          return {
            dom: dom,
            contentDOM: dom
          };
        } else {
          var _DOMSerializer$render2 = DOMSerializer.renderSpec(doc, child, xmlNS),
            inner = _DOMSerializer$render2.dom,
            innerContent = _DOMSerializer$render2.contentDOM;
          dom.appendChild(inner);
          if (innerContent) {
            if (contentDOM) throw new RangeError("Multiple content holes");
            contentDOM = innerContent;
          }
        }
      }
      return {
        dom: dom,
        contentDOM: contentDOM
      };
    }
    /**
    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
    properties in a schema's node and mark specs.
    */
  }, {
    key: "fromSchema",
    value: function fromSchema(schema) {
      return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
    }
    /**
    Gather the serializers in a schema's node specs into an object.
    This can be useful as a base to build a custom serializer from.
    */
  }, {
    key: "nodesFromSchema",
    value: function nodesFromSchema(schema) {
      var result = gatherToDOM(schema.nodes);
      if (!result.text) result.text = function (node) {
        return node.text;
      };
      return result;
    }
    /**
    Gather the serializers in a schema's mark specs into an object.
    */
  }, {
    key: "marksFromSchema",
    value: function marksFromSchema(schema) {
      return gatherToDOM(schema.marks);
    }
  }]);
  return DOMSerializer;
}();
function gatherToDOM(obj) {
  var result = {};
  for (var name in obj) {
    var toDOM = obj[name].spec.toDOM;
    if (toDOM) result[name] = toDOM;
  }
  return result;
}
function doc(options) {
  return options.document || window.document;
}


/***/ }),

/***/ "./node_modules/prosemirror-schema-list/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/prosemirror-schema-list/dist/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addListNodes: function() { return /* binding */ addListNodes; },
/* harmony export */   bulletList: function() { return /* binding */ bulletList; },
/* harmony export */   liftListItem: function() { return /* binding */ liftListItem; },
/* harmony export */   listItem: function() { return /* binding */ listItem; },
/* harmony export */   orderedList: function() { return /* binding */ orderedList; },
/* harmony export */   sinkListItem: function() { return /* binding */ sinkListItem; },
/* harmony export */   splitListItem: function() { return /* binding */ splitListItem; },
/* harmony export */   wrapInList: function() { return /* binding */ wrapInList; }
/* harmony export */ });
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.js");
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.js");
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");



var olDOM = ["ol", 0],
  ulDOM = ["ul", 0],
  liDOM = ["li", 0];
/**
An ordered list [node spec](https://prosemirror.net/docs/ref/#model.NodeSpec). Has a single
attribute, `order`, which determines the number at which the list
starts counting, and defaults to 1. Represented as an `<ol>`
element.
*/
var orderedList = {
  attrs: {
    order: {
      "default": 1
    }
  },
  parseDOM: [{
    tag: "ol",
    getAttrs: function getAttrs(dom) {
      return {
        order: dom.hasAttribute("start") ? +dom.getAttribute("start") : 1
      };
    }
  }],
  toDOM: function toDOM(node) {
    return node.attrs.order == 1 ? olDOM : ["ol", {
      start: node.attrs.order
    }, 0];
  }
};
/**
A bullet list node spec, represented in the DOM as `<ul>`.
*/
var bulletList = {
  parseDOM: [{
    tag: "ul"
  }],
  toDOM: function toDOM() {
    return ulDOM;
  }
};
/**
A list item (`<li>`) spec.
*/
var listItem = {
  parseDOM: [{
    tag: "li"
  }],
  toDOM: function toDOM() {
    return liDOM;
  },
  defining: true
};
function add(obj, props) {
  var copy = {};
  for (var prop in obj) copy[prop] = obj[prop];
  for (var _prop in props) copy[_prop] = props[_prop];
  return copy;
}
/**
Convenience function for adding list-related node types to a map
specifying the nodes for a schema. Adds
[`orderedList`](https://prosemirror.net/docs/ref/#schema-list.orderedList) as `"ordered_list"`,
[`bulletList`](https://prosemirror.net/docs/ref/#schema-list.bulletList) as `"bullet_list"`, and
[`listItem`](https://prosemirror.net/docs/ref/#schema-list.listItem) as `"list_item"`.

`itemContent` determines the content expression for the list items.
If you want the commands defined in this module to apply to your
list structure, it should have a shape like `"paragraph block*"` or
`"paragraph (ordered_list | bullet_list)*"`. `listGroup` can be
given to assign a group name to the list node types, for example
`"block"`.
*/
function addListNodes(nodes, itemContent, listGroup) {
  return nodes.append({
    ordered_list: add(orderedList, {
      content: "list_item+",
      group: listGroup
    }),
    bullet_list: add(bulletList, {
      content: "list_item+",
      group: listGroup
    }),
    list_item: add(listItem, {
      content: itemContent
    })
  });
}
/**
Returns a command function that wraps the selection in a list with
the given type an attributes. If `dispatch` is null, only return a
value to indicate whether this is possible, but don't actually
perform the change.
*/
function wrapInList(listType) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (state, dispatch) {
    var _state$selection = state.selection,
      $from = _state$selection.$from,
      $to = _state$selection.$to;
    var range = $from.blockRange($to),
      doJoin = false,
      outerRange = range;
    if (!range) return false;
    // This is at the top of an existing list item
    if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
      // Don't do anything if this is the top of the list
      if ($from.index(range.depth - 1) == 0) return false;
      var $insert = state.doc.resolve(range.start - 2);
      outerRange = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange($insert, $insert, range.depth);
      if (range.endIndex < range.parent.childCount) range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);
      doJoin = true;
    }
    var wrap = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.findWrapping)(outerRange, listType, attrs, range);
    if (!wrap) return false;
    if (dispatch) dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());
    return true;
  };
}
function doWrapInList(tr, range, wrappers, joinBefore, listType) {
  var content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;
  for (var i = wrappers.length - 1; i >= 0; i--) content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, 0, 0), wrappers.length, true));
  var found = 0;
  for (var _i = 0; _i < wrappers.length; _i++) if (wrappers[_i].type == listType) found = _i + 1;
  var splitDepth = wrappers.length - found;
  var splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0),
    parent = range.parent;
  for (var _i2 = range.startIndex, e = range.endIndex, first = true; _i2 < e; _i2++, first = false) {
    if (!first && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canSplit)(tr.doc, splitPos, splitDepth)) {
      tr.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(_i2).nodeSize;
  }
  return tr;
}
/**
Build a command that splits a non-empty textblock at the top level
of a list item by also splitting that list item.
*/
function splitListItem(itemType, itemAttrs) {
  return function (state, dispatch) {
    var _state$selection2 = state.selection,
      $from = _state$selection2.$from,
      $to = _state$selection2.$to,
      node = _state$selection2.node;
    if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) return false;
    var grandParent = $from.node(-1);
    if (grandParent.type != itemType) return false;
    if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {
      // In an empty block. If this is a nested list, the wrapping
      // list item should be split. Otherwise, bail out and let next
      // command handle lifting.
      if ($from.depth == 3 || $from.node(-3).type != itemType || $from.index(-2) != $from.node(-2).childCount - 1) return false;
      if (dispatch) {
        var wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;
        var depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;
        // Build a fragment containing empty versions of the structure
        // from the outer list item to the parent node of the cursor
        for (var d = $from.depth - depthBefore; d >= $from.depth - 3; d--) wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(wrap));
        var depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;
        // Add a second list item with an empty default start node
        wrap = wrap.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.createAndFill()));
        var start = $from.before($from.depth - (depthBefore - 1));
        var _tr = state.tr.replace(start, $from.after(-depthAfter), new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(wrap, 4 - depthBefore, 0));
        var sel = -1;
        _tr.doc.nodesBetween(start, _tr.doc.content.size, function (node, pos) {
          if (sel > -1) return false;
          if (node.isTextblock && node.content.size == 0) sel = pos + 1;
        });
        if (sel > -1) _tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Selection.near(_tr.doc.resolve(sel)));
        dispatch(_tr.scrollIntoView());
      }
      return true;
    }
    var nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
    var tr = state.tr["delete"]($from.pos, $to.pos);
    var types = nextType ? [itemAttrs ? {
      type: itemType,
      attrs: itemAttrs
    } : null, {
      type: nextType
    }] : undefined;
    if (!(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canSplit)(tr.doc, $from.pos, 2, types)) return false;
    if (dispatch) dispatch(tr.split($from.pos, 2, types).scrollIntoView());
    return true;
  };
}
/**
Create a command to lift the list item around the selection up into
a wrapping list.
*/
function liftListItem(itemType) {
  return function (state, dispatch) {
    var _state$selection3 = state.selection,
      $from = _state$selection3.$from,
      $to = _state$selection3.$to;
    var range = $from.blockRange($to, function (node) {
      return node.childCount > 0 && node.firstChild.type == itemType;
    });
    if (!range) return false;
    if (!dispatch) return true;
    if ($from.node(range.depth - 1).type == itemType)
      // Inside a parent list
      return liftToOuterList(state, dispatch, itemType, range);else
      // Outer list node
      return liftOutOfList(state, dispatch, range);
  };
}
function liftToOuterList(state, dispatch, itemType, range) {
  var tr = state.tr,
    end = range.end,
    endOfList = range.$to.end(range.depth);
  if (end < endOfList) {
    // There are siblings after the lifted items, which must become
    // children of the last item
    tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(end - 1, endOfList, end, endOfList, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
  }
  var target = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.liftTarget)(range);
  if (target == null) return false;
  tr.lift(range, target);
  var after = tr.mapping.map(end, -1) - 1;
  if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canJoin)(tr.doc, after)) tr.join(after);
  dispatch(tr.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch, range) {
  var tr = state.tr,
    list = range.parent;
  // Merge the list items into a single big item
  for (var pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr["delete"](pos - 1, pos + 1);
  }
  var $start = tr.doc.resolve(range.start),
    item = $start.nodeAfter;
  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize) return false;
  var atStart = range.startIndex == 0,
    atEnd = range.endIndex == list.childCount;
  var parent = $start.node(-1),
    indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list)))) return false;
  var start = $start.pos,
    end = start + item.nodeSize;
  // Strip off the surrounding list. At the sides where we're not at
  // the end of the list, the existing list is closed. At sides where
  // this is the end, it is overwritten to its end.
  tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice((atStart ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty))).append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr.scrollIntoView());
  return true;
}
/**
Create a command to sink the list item around the selection down
into an inner list.
*/
function sinkListItem(itemType) {
  return function (state, dispatch) {
    var _state$selection4 = state.selection,
      $from = _state$selection4.$from,
      $to = _state$selection4.$to;
    var range = $from.blockRange($to, function (node) {
      return node.childCount > 0 && node.firstChild.type == itemType;
    });
    if (!range) return false;
    var startIndex = range.startIndex;
    if (startIndex == 0) return false;
    var parent = range.parent,
      nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType) return false;
    if (dispatch) {
      var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      var inner = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(nestedBefore ? itemType.create() : null);
      var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      var before = range.start,
        after = range.end;
      dispatch(state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true)).scrollIntoView());
    }
    return true;
  };
}


/***/ }),

/***/ "./node_modules/prosemirror-state/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/prosemirror-state/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AllSelection: function() { return /* binding */ AllSelection; },
/* harmony export */   EditorState: function() { return /* binding */ EditorState; },
/* harmony export */   NodeSelection: function() { return /* binding */ NodeSelection; },
/* harmony export */   Plugin: function() { return /* binding */ Plugin; },
/* harmony export */   PluginKey: function() { return /* binding */ PluginKey; },
/* harmony export */   Selection: function() { return /* binding */ Selection; },
/* harmony export */   SelectionRange: function() { return /* binding */ SelectionRange; },
/* harmony export */   TextSelection: function() { return /* binding */ TextSelection; },
/* harmony export */   Transaction: function() { return /* binding */ Transaction; }
/* harmony export */ });
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.js");
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.js");
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


var classesById = Object.create(null);
/**
Superclass for editor selections. Every selection type should
extend this. Should not be instantiated directly.
*/
var Selection = /*#__PURE__*/function () {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  function Selection(
  /**
  The resolved anchor of the selection (the side that stays in
  place when the selection is modified).
  */
  $anchor,
  /**
  The resolved head of the selection (the side that moves when
  the selection is modified).
  */
  $head, ranges) {
    _classCallCheck(this, Selection);
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  _createClass(Selection, [{
    key: "anchor",
    get: function get() {
      return this.$anchor.pos;
    }
    /**
    The selection's head.
    */
  }, {
    key: "head",
    get: function get() {
      return this.$head.pos;
    }
    /**
    The lower bound of the selection's main range.
    */
  }, {
    key: "from",
    get: function get() {
      return this.$from.pos;
    }
    /**
    The upper bound of the selection's main range.
    */
  }, {
    key: "to",
    get: function get() {
      return this.$to.pos;
    }
    /**
    The resolved lower  bound of the selection's main range.
    */
  }, {
    key: "$from",
    get: function get() {
      return this.ranges[0].$from;
    }
    /**
    The resolved upper bound of the selection's main range.
    */
  }, {
    key: "$to",
    get: function get() {
      return this.ranges[0].$to;
    }
    /**
    Indicates whether the selection contains any content.
    */
  }, {
    key: "empty",
    get: function get() {
      var ranges = this.ranges;
      for (var i = 0; i < ranges.length; i++) if (ranges[i].$from.pos != ranges[i].$to.pos) return false;
      return true;
    }
    /**
    Get the content of this selection as a slice.
    */
  }, {
    key: "content",
    value: function content() {
      return this.$from.doc.slice(this.from, this.to, true);
    }
    /**
    Replace the selection with a slice or, if no slice is given,
    delete the selection. Will append to the given transaction.
    */
  }, {
    key: "replace",
    value: function replace(tr) {
      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;
      // Put the new selection at the position after the inserted
      // content. When that ended in an inline node, search backwards,
      // to get the position after that node. If not, search forward.
      var lastNode = content.content.lastChild,
        lastParent = null;
      for (var i = 0; i < content.openEnd; i++) {
        lastParent = lastNode;
        lastNode = lastNode.lastChild;
      }
      var mapFrom = tr.steps.length,
        ranges = this.ranges;
      for (var _i = 0; _i < ranges.length; _i++) {
        var _ranges$_i = ranges[_i],
          $from = _ranges$_i.$from,
          $to = _ranges$_i.$to,
          mapping = tr.mapping.slice(mapFrom);
        tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), _i ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : content);
        if (_i == 0) selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
      }
    }
    /**
    Replace the selection with the given node, appending the changes
    to the given transaction.
    */
  }, {
    key: "replaceWith",
    value: function replaceWith(tr, node) {
      var mapFrom = tr.steps.length,
        ranges = this.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var _ranges$i = ranges[i],
          $from = _ranges$i.$from,
          $to = _ranges$i.$to,
          mapping = tr.mapping.slice(mapFrom);
        var from = mapping.map($from.pos),
          to = mapping.map($to.pos);
        if (i) {
          tr.deleteRange(from, to);
        } else {
          tr.replaceRangeWith(from, to, node);
          selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
        }
      }
    }
    /**
    Find a valid cursor or leaf node selection starting at the given
    position and searching back if `dir` is negative, and forward if
    positive. When `textOnly` is true, only consider cursor
    selections. Will return null when no valid selection position is
    found.
    */
  }, {
    key: "getBookmark",
    value:
    /**
    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
    which is a value that can be mapped without having access to a
    current document, and later resolved to a real selection for a
    given document again. (This is used mostly by the history to
    track and restore old selections.) The default implementation of
    this method just converts the selection to a text selection and
    returns the bookmark for that.
    */
    function getBookmark() {
      return TextSelection.between(this.$anchor, this.$head).getBookmark();
    }
  }], [{
    key: "findFrom",
    value: function findFrom($pos, dir) {
      var textOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
      if (inner) return inner;
      for (var depth = $pos.depth - 1; depth >= 0; depth--) {
        var found = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
        if (found) return found;
      }
      return null;
    }
    /**
    Find a valid cursor or leaf node selection near the given
    position. Searches forward first by default, but if `bias` is
    negative, it will search backwards first.
    */
  }, {
    key: "near",
    value: function near($pos) {
      var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
    }
    /**
    Find the cursor or leaf node selection closest to the start of
    the given document. Will return an
    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
    exists.
    */
  }, {
    key: "atStart",
    value: function atStart(doc) {
      return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);
    }
    /**
    Find the cursor or leaf node selection closest to the end of the
    given document.
    */
  }, {
    key: "atEnd",
    value: function atEnd(doc) {
      return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);
    }
    /**
    Deserialize the JSON representation of a selection. Must be
    implemented for custom classes (as a static class method).
    */
  }, {
    key: "fromJSON",
    value: function fromJSON(doc, json) {
      if (!json || !json.type) throw new RangeError("Invalid input for Selection.fromJSON");
      var cls = classesById[json.type];
      if (!cls) throw new RangeError("No selection type ".concat(json.type, " defined"));
      return cls.fromJSON(doc, json);
    }
    /**
    To be able to deserialize selections from JSON, custom selection
    classes must register themselves with an ID string, so that they
    can be disambiguated. Try to pick something that's unlikely to
    clash with classes from other modules.
    */
  }, {
    key: "jsonID",
    value: function jsonID(id, selectionClass) {
      if (id in classesById) throw new RangeError("Duplicate use of selection JSON ID " + id);
      classesById[id] = selectionClass;
      selectionClass.prototype.jsonID = id;
      return selectionClass;
    }
  }]);
  return Selection;
}();
Selection.prototype.visible = true;
/**
Represents a selected range in a document.
*/
var SelectionRange = /*#__PURE__*/_createClass(
/**
Create a range.
*/
function SelectionRange(
/**
The lower bound of the range.
*/
$from,
/**
The upper bound of the range.
*/
$to) {
  _classCallCheck(this, SelectionRange);
  this.$from = $from;
  this.$to = $to;
});
var warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
/**
A text selection represents a classical editor selection, with a
head (the moving side) and anchor (immobile side), both of which
point into textblock nodes. It can be empty (a regular cursor
position).
*/
var TextSelection = /*#__PURE__*/function (_Selection) {
  _inherits(TextSelection, _Selection);
  /**
  Construct a text selection between the given points.
  */
  function TextSelection($anchor) {
    var $head = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $anchor;
    _classCallCheck(this, TextSelection);
    checkTextSelection($anchor);
    checkTextSelection($head);
    return _callSuper(this, TextSelection, [$anchor, $head]);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  _createClass(TextSelection, [{
    key: "$cursor",
    get: function get() {
      return this.$anchor.pos == this.$head.pos ? this.$head : null;
    }
  }, {
    key: "map",
    value: function map(doc, mapping) {
      var $head = doc.resolve(mapping.map(this.head));
      if (!$head.parent.inlineContent) return Selection.near($head);
      var $anchor = doc.resolve(mapping.map(this.anchor));
      return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
    }
  }, {
    key: "replace",
    value: function replace(tr) {
      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;
      _get(_getPrototypeOf(TextSelection.prototype), "replace", this).call(this, tr, content);
      if (content == prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {
        var marks = this.$from.marksAcross(this.$to);
        if (marks) tr.ensureMarks(marks);
      }
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
    }
  }, {
    key: "getBookmark",
    value: function getBookmark() {
      return new TextBookmark(this.anchor, this.head);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: "text",
        anchor: this.anchor,
        head: this.head
      };
    }
    /**
    @internal
    */
  }], [{
    key: "fromJSON",
    value: function fromJSON(doc, json) {
      if (typeof json.anchor != "number" || typeof json.head != "number") throw new RangeError("Invalid input for TextSelection.fromJSON");
      return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head));
    }
    /**
    Create a text selection from non-resolved positions.
    */
  }, {
    key: "create",
    value: function create(doc, anchor) {
      var head = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : anchor;
      var $anchor = doc.resolve(anchor);
      return new this($anchor, head == anchor ? $anchor : doc.resolve(head));
    }
    /**
    Return a text selection that spans the given positions or, if
    they aren't text positions, find a text selection near them.
    `bias` determines whether the method searches forward (default)
    or backwards (negative number) first. Will fall back to calling
    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
    doesn't contain a valid text position.
    */
  }, {
    key: "between",
    value: function between($anchor, $head, bias) {
      var dPos = $anchor.pos - $head.pos;
      if (!bias || dPos) bias = dPos >= 0 ? 1 : -1;
      if (!$head.parent.inlineContent) {
        var found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
        if (found) $head = found.$head;else return Selection.near($head, bias);
      }
      if (!$anchor.parent.inlineContent) {
        if (dPos == 0) {
          $anchor = $head;
        } else {
          $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
          if ($anchor.pos < $head.pos != dPos < 0) $anchor = $head;
        }
      }
      return new TextSelection($anchor, $head);
    }
  }]);
  return TextSelection;
}(Selection);
Selection.jsonID("text", TextSelection);
var TextBookmark = /*#__PURE__*/function () {
  function TextBookmark(anchor, head) {
    _classCallCheck(this, TextBookmark);
    this.anchor = anchor;
    this.head = head;
  }
  _createClass(TextBookmark, [{
    key: "map",
    value: function map(mapping) {
      return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
    }
  }, {
    key: "resolve",
    value: function resolve(doc) {
      return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));
    }
  }]);
  return TextBookmark;
}();
/**
A node selection is a selection that points at a single node. All
nodes marked [selectable](https://prosemirror.net/docs/ref/#model.NodeSpec.selectable) can be the
target of a node selection. In such a selection, `from` and `to`
point directly before and after the selected node, `anchor` equals
`from`, and `head` equals `to`..
*/
var NodeSelection = /*#__PURE__*/function (_Selection2) {
  _inherits(NodeSelection, _Selection2);
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  function NodeSelection($pos) {
    var _this;
    _classCallCheck(this, NodeSelection);
    var node = $pos.nodeAfter;
    var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    _this = _callSuper(this, NodeSelection, [$pos, $end]);
    _this.node = node;
    return _this;
  }
  _createClass(NodeSelection, [{
    key: "map",
    value: function map(doc, mapping) {
      var _mapping$mapResult = mapping.mapResult(this.anchor),
        deleted = _mapping$mapResult.deleted,
        pos = _mapping$mapResult.pos;
      var $pos = doc.resolve(pos);
      if (deleted) return Selection.near($pos);
      return new NodeSelection($pos);
    }
  }, {
    key: "content",
    value: function content() {
      return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(this.node), 0, 0);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return other instanceof NodeSelection && other.anchor == this.anchor;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: "node",
        anchor: this.anchor
      };
    }
  }, {
    key: "getBookmark",
    value: function getBookmark() {
      return new NodeBookmark(this.anchor);
    }
    /**
    @internal
    */
  }], [{
    key: "fromJSON",
    value: function fromJSON(doc, json) {
      if (typeof json.anchor != "number") throw new RangeError("Invalid input for NodeSelection.fromJSON");
      return new NodeSelection(doc.resolve(json.anchor));
    }
    /**
    Create a node selection from non-resolved positions.
    */
  }, {
    key: "create",
    value: function create(doc, from) {
      return new NodeSelection(doc.resolve(from));
    }
    /**
    Determines whether the given node may be selected as a node
    selection.
    */
  }, {
    key: "isSelectable",
    value: function isSelectable(node) {
      return !node.isText && node.type.spec.selectable !== false;
    }
  }]);
  return NodeSelection;
}(Selection);
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
var NodeBookmark = /*#__PURE__*/function () {
  function NodeBookmark(anchor) {
    _classCallCheck(this, NodeBookmark);
    this.anchor = anchor;
  }
  _createClass(NodeBookmark, [{
    key: "map",
    value: function map(mapping) {
      var _mapping$mapResult2 = mapping.mapResult(this.anchor),
        deleted = _mapping$mapResult2.deleted,
        pos = _mapping$mapResult2.pos;
      return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
    }
  }, {
    key: "resolve",
    value: function resolve(doc) {
      var $pos = doc.resolve(this.anchor),
        node = $pos.nodeAfter;
      if (node && NodeSelection.isSelectable(node)) return new NodeSelection($pos);
      return Selection.near($pos);
    }
  }]);
  return NodeBookmark;
}();
/**
A selection type that represents selecting the whole document
(which can not necessarily be expressed with a text selection, when
there are for example leaf block nodes at the start or end of the
document).
*/
var AllSelection = /*#__PURE__*/function (_Selection3) {
  _inherits(AllSelection, _Selection3);
  /**
  Create an all-selection over the given document.
  */
  function AllSelection(doc) {
    _classCallCheck(this, AllSelection);
    return _callSuper(this, AllSelection, [doc.resolve(0), doc.resolve(doc.content.size)]);
  }
  _createClass(AllSelection, [{
    key: "replace",
    value: function replace(tr) {
      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;
      if (content == prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {
        tr["delete"](0, tr.doc.content.size);
        var sel = Selection.atStart(tr.doc);
        if (!sel.eq(tr.selection)) tr.setSelection(sel);
      } else {
        _get(_getPrototypeOf(AllSelection.prototype), "replace", this).call(this, tr, content);
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: "all"
      };
    }
    /**
    @internal
    */
  }, {
    key: "map",
    value: function map(doc) {
      return new AllSelection(doc);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return other instanceof AllSelection;
    }
  }, {
    key: "getBookmark",
    value: function getBookmark() {
      return AllBookmark;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(doc) {
      return new AllSelection(doc);
    }
  }]);
  return AllSelection;
}(Selection);
Selection.jsonID("all", AllSelection);
var AllBookmark = {
  map: function map() {
    return this;
  },
  resolve: function resolve(doc) {
    return new AllSelection(doc);
  }
};
// FIXME we'll need some awareness of text direction when scanning for selections
// Try to find a selection inside the given node. `pos` points at the
// position where the search starts. When `text` is true, only return
// text selections.
function findSelectionIn(doc, node, pos, index, dir) {
  var text = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  if (node.inlineContent) return TextSelection.create(doc, pos);
  for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    var child = node.child(i);
    if (!child.isAtom) {
      var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner) return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd(tr, startLen, bias) {
  var last = tr.steps.length - 1;
  if (last < startLen) return;
  var step = tr.steps[last];
  if (!(step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceStep || step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep)) return;
  var map = tr.mapping.maps[last],
    end;
  map.forEach(function (_from, _to, _newFrom, newTo) {
    if (end == null) end = newTo;
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}
var UPDATED_SEL = 1,
  UPDATED_MARKS = 2,
  UPDATED_SCROLL = 4;
/**
An editor state transaction, which can be applied to a state to
create an updated state. Use
[`EditorState.tr`](https://prosemirror.net/docs/ref/#state.EditorState.tr) to create an instance.

Transactions track changes to the document (they are a subclass of
[`Transform`](https://prosemirror.net/docs/ref/#transform.Transform)), but also other state changes,
like selection updates and adjustments of the set of [stored
marks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks). In addition, you can store
metadata properties in a transaction, which are extra pieces of
information that client code or plugins can use to describe what a
transaction represents, so that they can update their [own
state](https://prosemirror.net/docs/ref/#state.StateField) accordingly.

The [editor view](https://prosemirror.net/docs/ref/#view.EditorView) uses a few metadata
properties: it will attach a property `"pointer"` with the value
`true` to selection transactions directly caused by mouse or touch
input, a `"composition"` property holding an ID identifying the
composition that caused it to transactions caused by composed DOM
input, and a `"uiEvent"` property of that may be `"paste"`,
`"cut"`, or `"drop"`.
*/
var Transaction = /*#__PURE__*/function (_Transform) {
  _inherits(Transaction, _Transform);
  /**
  @internal
  */
  function Transaction(state) {
    var _this2;
    _classCallCheck(this, Transaction);
    _this2 = _callSuper(this, Transaction, [state.doc]);
    // The step count for which the current selection is valid.
    _this2.curSelectionFor = 0;
    // Bitfield to track which aspects of the state were updated by
    // this transaction.
    _this2.updated = 0;
    // Object used to store metadata properties for the transaction.
    _this2.meta = Object.create(null);
    _this2.time = Date.now();
    _this2.curSelection = state.selection;
    _this2.storedMarks = state.storedMarks;
    return _this2;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  _createClass(Transaction, [{
    key: "selection",
    get: function get() {
      if (this.curSelectionFor < this.steps.length) {
        this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
        this.curSelectionFor = this.steps.length;
      }
      return this.curSelection;
    }
    /**
    Update the transaction's current selection. Will determine the
    selection that the editor gets when the transaction is applied.
    */
  }, {
    key: "setSelection",
    value: function setSelection(selection) {
      if (selection.$from.doc != this.doc) throw new RangeError("Selection passed to setSelection must point at the current document");
      this.curSelection = selection;
      this.curSelectionFor = this.steps.length;
      this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
      this.storedMarks = null;
      return this;
    }
    /**
    Whether the selection was explicitly updated by this transaction.
    */
  }, {
    key: "selectionSet",
    get: function get() {
      return (this.updated & UPDATED_SEL) > 0;
    }
    /**
    Set the current stored marks.
    */
  }, {
    key: "setStoredMarks",
    value: function setStoredMarks(marks) {
      this.storedMarks = marks;
      this.updated |= UPDATED_MARKS;
      return this;
    }
    /**
    Make sure the current stored marks or, if that is null, the marks
    at the selection, match the given set of marks. Does nothing if
    this is already the case.
    */
  }, {
    key: "ensureMarks",
    value: function ensureMarks(marks) {
      if (!prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks)) this.setStoredMarks(marks);
      return this;
    }
    /**
    Add a mark to the set of stored marks.
    */
  }, {
    key: "addStoredMark",
    value: function addStoredMark(mark) {
      return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
    }
    /**
    Remove a mark or mark type from the set of stored marks.
    */
  }, {
    key: "removeStoredMark",
    value: function removeStoredMark(mark) {
      return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
    }
    /**
    Whether the stored marks were explicitly set for this transaction.
    */
  }, {
    key: "storedMarksSet",
    get: function get() {
      return (this.updated & UPDATED_MARKS) > 0;
    }
    /**
    @internal
    */
  }, {
    key: "addStep",
    value: function addStep(step, doc) {
      _get(_getPrototypeOf(Transaction.prototype), "addStep", this).call(this, step, doc);
      this.updated = this.updated & ~UPDATED_MARKS;
      this.storedMarks = null;
    }
    /**
    Update the timestamp for the transaction.
    */
  }, {
    key: "setTime",
    value: function setTime(time) {
      this.time = time;
      return this;
    }
    /**
    Replace the current selection with the given slice.
    */
  }, {
    key: "replaceSelection",
    value: function replaceSelection(slice) {
      this.selection.replace(this, slice);
      return this;
    }
    /**
    Replace the selection with the given node. When `inheritMarks` is
    true and the content is inline, it inherits the marks from the
    place where it is inserted.
    */
  }, {
    key: "replaceSelectionWith",
    value: function replaceSelectionWith(node) {
      var inheritMarks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var selection = this.selection;
      if (inheritMarks) node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none));
      selection.replaceWith(this, node);
      return this;
    }
    /**
    Delete the selection.
    */
  }, {
    key: "deleteSelection",
    value: function deleteSelection() {
      this.selection.replace(this);
      return this;
    }
    /**
    Replace the given range, or the selection if no range is given,
    with a text node containing the given string.
    */
  }, {
    key: "insertText",
    value: function insertText(text, from, to) {
      var schema = this.doc.type.schema;
      if (from == null) {
        if (!text) return this.deleteSelection();
        return this.replaceSelectionWith(schema.text(text), true);
      } else {
        if (to == null) to = from;
        to = to == null ? from : to;
        if (!text) return this.deleteRange(from, to);
        var marks = this.storedMarks;
        if (!marks) {
          var $from = this.doc.resolve(from);
          marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
        }
        this.replaceRangeWith(from, to, schema.text(text, marks));
        if (!this.selection.empty) this.setSelection(Selection.near(this.selection.$to));
        return this;
      }
    }
    /**
    Store a metadata property in this transaction, keyed either by
    name or by plugin.
    */
  }, {
    key: "setMeta",
    value: function setMeta(key, value) {
      this.meta[typeof key == "string" ? key : key.key] = value;
      return this;
    }
    /**
    Retrieve a metadata property for a given name or plugin.
    */
  }, {
    key: "getMeta",
    value: function getMeta(key) {
      return this.meta[typeof key == "string" ? key : key.key];
    }
    /**
    Returns true if this transaction doesn't contain any metadata,
    and can thus safely be extended.
    */
  }, {
    key: "isGeneric",
    get: function get() {
      for (var _ in this.meta) return false;
      return true;
    }
    /**
    Indicate that the editor should scroll the selection into view
    when updated to the state produced by this transaction.
    */
  }, {
    key: "scrollIntoView",
    value: function scrollIntoView() {
      this.updated |= UPDATED_SCROLL;
      return this;
    }
    /**
    True when this transaction has had `scrollIntoView` called on it.
    */
  }, {
    key: "scrolledIntoView",
    get: function get() {
      return (this.updated & UPDATED_SCROLL) > 0;
    }
  }]);
  return Transaction;
}(prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.Transform);
function bind(f, self) {
  return !self || !f ? f : f.bind(self);
}
var FieldDesc = /*#__PURE__*/_createClass(function FieldDesc(name, desc, self) {
  _classCallCheck(this, FieldDesc);
  this.name = name;
  this.init = bind(desc.init, self);
  this.apply = bind(desc.apply, self);
});
var baseFields = [new FieldDesc("doc", {
  init: function init(config) {
    return config.doc || config.schema.topNodeType.createAndFill();
  },
  apply: function apply(tr) {
    return tr.doc;
  }
}), new FieldDesc("selection", {
  init: function init(config, instance) {
    return config.selection || Selection.atStart(instance.doc);
  },
  apply: function apply(tr) {
    return tr.selection;
  }
}), new FieldDesc("storedMarks", {
  init: function init(config) {
    return config.storedMarks || null;
  },
  apply: function apply(tr, _marks, _old, state) {
    return state.selection.$cursor ? tr.storedMarks : null;
  }
}), new FieldDesc("scrollToSelection", {
  init: function init() {
    return 0;
  },
  apply: function apply(tr, prev) {
    return tr.scrolledIntoView ? prev + 1 : prev;
  }
})];
// Object wrapping the part of a state object that stays the same
// across transactions. Stored in the state's `config` property.
var Configuration = /*#__PURE__*/_createClass(function Configuration(schema, plugins) {
  var _this3 = this;
  _classCallCheck(this, Configuration);
  this.schema = schema;
  this.plugins = [];
  this.pluginsByKey = Object.create(null);
  this.fields = baseFields.slice();
  if (plugins) plugins.forEach(function (plugin) {
    if (_this3.pluginsByKey[plugin.key]) throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
    _this3.plugins.push(plugin);
    _this3.pluginsByKey[plugin.key] = plugin;
    if (plugin.spec.state) _this3.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
  });
});
/**
The state of a ProseMirror editor is represented by an object of
this type. A state is a persistent data structureit isn't
updated, but rather a new state value is computed from an old one
using the [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) method.

A state holds a number of built-in fields, and plugins can
[define](https://prosemirror.net/docs/ref/#state.PluginSpec.state) additional fields.
*/
var EditorState = /*#__PURE__*/function () {
  /**
  @internal
  */
  function EditorState(
  /**
  @internal
  */
  config) {
    _classCallCheck(this, EditorState);
    this.config = config;
  }
  /**
  The schema of the state's document.
  */
  _createClass(EditorState, [{
    key: "schema",
    get: function get() {
      return this.config.schema;
    }
    /**
    The plugins that are active in this state.
    */
  }, {
    key: "plugins",
    get: function get() {
      return this.config.plugins;
    }
    /**
    Apply the given transaction to produce a new state.
    */
  }, {
    key: "apply",
    value: function apply(tr) {
      return this.applyTransaction(tr).state;
    }
    /**
    @internal
    */
  }, {
    key: "filterTransaction",
    value: function filterTransaction(tr) {
      var ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      for (var i = 0; i < this.config.plugins.length; i++) if (i != ignore) {
        var plugin = this.config.plugins[i];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this)) return false;
      }
      return true;
    }
    /**
    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
    returns the precise transactions that were applied (which might
    be influenced by the [transaction
    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
    plugins) along with the new state.
    */
  }, {
    key: "applyTransaction",
    value: function applyTransaction(rootTr) {
      if (!this.filterTransaction(rootTr)) return {
        state: this,
        transactions: []
      };
      var trs = [rootTr],
        newState = this.applyInner(rootTr),
        seen = null;
      // This loop repeatedly gives plugins a chance to respond to
      // transactions as new transactions are added, making sure to only
      // pass the transactions the plugin did not see before.
      for (;;) {
        var haveNew = false;
        for (var i = 0; i < this.config.plugins.length; i++) {
          var plugin = this.config.plugins[i];
          if (plugin.spec.appendTransaction) {
            var n = seen ? seen[i].n : 0,
              oldState = seen ? seen[i].state : this;
            var tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
            if (tr && newState.filterTransaction(tr, i)) {
              tr.setMeta("appendedTransaction", rootTr);
              if (!seen) {
                seen = [];
                for (var j = 0; j < this.config.plugins.length; j++) seen.push(j < i ? {
                  state: newState,
                  n: trs.length
                } : {
                  state: this,
                  n: 0
                });
              }
              trs.push(tr);
              newState = newState.applyInner(tr);
              haveNew = true;
            }
            if (seen) seen[i] = {
              state: newState,
              n: trs.length
            };
          }
        }
        if (!haveNew) return {
          state: newState,
          transactions: trs
        };
      }
    }
    /**
    @internal
    */
  }, {
    key: "applyInner",
    value: function applyInner(tr) {
      if (!tr.before.eq(this.doc)) throw new RangeError("Applying a mismatched transaction");
      var newInstance = new EditorState(this.config),
        fields = this.config.fields;
      for (var i = 0; i < fields.length; i++) {
        var field = fields[i];
        newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
      }
      return newInstance;
    }
    /**
    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
    */
  }, {
    key: "tr",
    get: function get() {
      return new Transaction(this);
    }
    /**
    Create a new state.
    */
  }, {
    key: "reconfigure",
    value:
    /**
    Create a new state based on this one, but with an adjusted set
    of active plugins. State fields that exist in both sets of
    plugins are kept unchanged. Those that no longer exist are
    dropped, and those that are new are initialized using their
    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
    configuration object..
    */
    function reconfigure(config) {
      var $config = new Configuration(this.schema, config.plugins);
      var fields = $config.fields,
        instance = new EditorState($config);
      for (var i = 0; i < fields.length; i++) {
        var name = fields[i].name;
        instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
      }
      return instance;
    }
    /**
    Serialize this state to JSON. If you want to serialize the state
    of plugins, pass an object mapping property names to use in the
    resulting JSON object to plugin objects. The argument may also be
    a string or number, in which case it is ignored, to support the
    way `JSON.stringify` calls `toString` methods.
    */
  }, {
    key: "toJSON",
    value: function toJSON(pluginFields) {
      var result = {
        doc: this.doc.toJSON(),
        selection: this.selection.toJSON()
      };
      if (this.storedMarks) result.storedMarks = this.storedMarks.map(function (m) {
        return m.toJSON();
      });
      if (pluginFields && _typeof(pluginFields) == 'object') for (var prop in pluginFields) {
        if (prop == "doc" || prop == "selection") throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        var plugin = pluginFields[prop],
          state = plugin.spec.state;
        if (state && state.toJSON) result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
      return result;
    }
    /**
    Deserialize a JSON representation of a state. `config` should
    have at least a `schema` field, and should contain array of
    plugins to initialize the state with. `pluginFields` can be used
    to deserialize the state of plugins, by associating plugin
    instances with the property names they use in the JSON object.
    */
  }], [{
    key: "create",
    value: function create(config) {
      var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
      var instance = new EditorState($config);
      for (var i = 0; i < $config.fields.length; i++) instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
      return instance;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(config, json, pluginFields) {
      if (!json) throw new RangeError("Invalid input for EditorState.fromJSON");
      if (!config.schema) throw new RangeError("Required config field 'schema' missing");
      var $config = new Configuration(config.schema, config.plugins);
      var instance = new EditorState($config);
      $config.fields.forEach(function (field) {
        if (field.name == "doc") {
          instance.doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node.fromJSON(config.schema, json.doc);
        } else if (field.name == "selection") {
          instance.selection = Selection.fromJSON(instance.doc, json.selection);
        } else if (field.name == "storedMarks") {
          if (json.storedMarks) instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
        } else {
          if (pluginFields) for (var prop in pluginFields) {
            var plugin = pluginFields[prop],
              state = plugin.spec.state;
            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
              return;
            }
          }
          instance[field.name] = field.init(config, instance);
        }
      });
      return instance;
    }
  }]);
  return EditorState;
}();
function bindProps(obj, self, target) {
  for (var prop in obj) {
    var val = obj[prop];
    if (val instanceof Function) val = val.bind(self);else if (prop == "handleDOMEvents") val = bindProps(val, self, {});
    target[prop] = val;
  }
  return target;
}
/**
Plugins bundle functionality that can be added to an editor.
They are part of the [editor state](https://prosemirror.net/docs/ref/#state.EditorState) and
may influence that state and the view that contains it.
*/
var Plugin = /*#__PURE__*/function () {
  /**
  Create a plugin.
  */
  function Plugin(
  /**
  The plugin's [spec object](https://prosemirror.net/docs/ref/#state.PluginSpec).
  */
  spec) {
    _classCallCheck(this, Plugin);
    this.spec = spec;
    /**
    The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.
    */
    this.props = {};
    if (spec.props) bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  _createClass(Plugin, [{
    key: "getState",
    value: function getState(state) {
      return state[this.key];
    }
  }]);
  return Plugin;
}();
var keys = Object.create(null);
function createKey(name) {
  if (name in keys) return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
/**
A key is used to [tag](https://prosemirror.net/docs/ref/#state.PluginSpec.key) plugins in a way
that makes it possible to find them, given an editor state.
Assigning a key does mean only one plugin of that type can be
active in a state.
*/
var PluginKey = /*#__PURE__*/function () {
  /**
  Create a plugin key.
  */
  function PluginKey() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "key";
    _classCallCheck(this, PluginKey);
    this.key = createKey(name);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  _createClass(PluginKey, [{
    key: "get",
    value: function get(state) {
      return state.config.pluginsByKey[this.key];
    }
    /**
    Get the plugin's state from an editor state.
    */
  }, {
    key: "getState",
    value: function getState(state) {
      return state[this.key];
    }
  }]);
  return PluginKey;
}();


/***/ }),

/***/ "./node_modules/prosemirror-transform/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-transform/dist/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AddMarkStep: function() { return /* binding */ AddMarkStep; },
/* harmony export */   AddNodeMarkStep: function() { return /* binding */ AddNodeMarkStep; },
/* harmony export */   AttrStep: function() { return /* binding */ AttrStep; },
/* harmony export */   DocAttrStep: function() { return /* binding */ DocAttrStep; },
/* harmony export */   MapResult: function() { return /* binding */ MapResult; },
/* harmony export */   Mapping: function() { return /* binding */ Mapping; },
/* harmony export */   RemoveMarkStep: function() { return /* binding */ RemoveMarkStep; },
/* harmony export */   RemoveNodeMarkStep: function() { return /* binding */ RemoveNodeMarkStep; },
/* harmony export */   ReplaceAroundStep: function() { return /* binding */ ReplaceAroundStep; },
/* harmony export */   ReplaceStep: function() { return /* binding */ ReplaceStep; },
/* harmony export */   Step: function() { return /* binding */ Step; },
/* harmony export */   StepMap: function() { return /* binding */ StepMap; },
/* harmony export */   StepResult: function() { return /* binding */ StepResult; },
/* harmony export */   Transform: function() { return /* binding */ Transform; },
/* harmony export */   TransformError: function() { return /* binding */ TransformError; },
/* harmony export */   canJoin: function() { return /* binding */ canJoin; },
/* harmony export */   canSplit: function() { return /* binding */ canSplit; },
/* harmony export */   dropPoint: function() { return /* binding */ dropPoint; },
/* harmony export */   findWrapping: function() { return /* binding */ findWrapping; },
/* harmony export */   insertPoint: function() { return /* binding */ insertPoint; },
/* harmony export */   joinPoint: function() { return /* binding */ joinPoint; },
/* harmony export */   liftTarget: function() { return /* binding */ liftTarget; },
/* harmony export */   replaceStep: function() { return /* binding */ replaceStep; }
/* harmony export */ });
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.js");
function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeFunction(fn) { try { return Function.toString.call(fn).indexOf("[native code]") !== -1; } catch (e) { return typeof fn === "function"; } }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


// Recovery values encode a range index and an offset. They are
// represented as numbers, because tons of them will be created when
// mapping, for example, a large number of decorations. The number's
// lower 16 bits provide the index, the remaining bits the offset.
//
// Note: We intentionally don't use bit shift operators to en- and
// decode these, since those clip to 32 bits, which we might in rare
// cases want to overflow. A 64-bit float can represent 48-bit
// integers precisely.
var lower16 = 0xffff;
var factor16 = Math.pow(2, 16);
function makeRecover(index, offset) {
  return index + offset * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
var DEL_BEFORE = 1,
  DEL_AFTER = 2,
  DEL_ACROSS = 4,
  DEL_SIDE = 8;
/**
An object representing a mapped position with extra
information.
*/
var MapResult = /*#__PURE__*/function () {
  /**
  @internal
  */
  function MapResult(
  /**
  The mapped version of the position.
  */
  pos,
  /**
  @internal
  */
  delInfo,
  /**
  @internal
  */
  recover) {
    _classCallCheck(this, MapResult);
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  _createClass(MapResult, [{
    key: "deleted",
    get: function get() {
      return (this.delInfo & DEL_SIDE) > 0;
    }
    /**
    Tells you whether the token before the mapped position was deleted.
    */
  }, {
    key: "deletedBefore",
    get: function get() {
      return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
    }
    /**
    True when the token after the mapped position was deleted.
    */
  }, {
    key: "deletedAfter",
    get: function get() {
      return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
    }
    /**
    Tells whether any of the steps mapped through deletes across the
    position (including both the token before and after the
    position).
    */
  }, {
    key: "deletedAcross",
    get: function get() {
      return (this.delInfo & DEL_ACROSS) > 0;
    }
  }]);
  return MapResult;
}();
/**
A map describing the deletions and insertions made by a step, which
can be used to find the correspondence between positions in the
pre-step version of a document and the same position in the
post-step version.
*/
var StepMap = /*#__PURE__*/function () {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  function StepMap(
  /**
  @internal
  */
  ranges) {
    var inverted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    _classCallCheck(this, StepMap);
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && StepMap.empty) return StepMap.empty;
  }
  /**
  @internal
  */
  _createClass(StepMap, [{
    key: "recover",
    value: function recover(value) {
      var diff = 0,
        index = recoverIndex(value);
      if (!this.inverted) for (var i = 0; i < index; i++) diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
      return this.ranges[index * 3] + diff + recoverOffset(value);
    }
  }, {
    key: "mapResult",
    value: function mapResult(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this._map(pos, assoc, false);
    }
  }, {
    key: "map",
    value: function map(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this._map(pos, assoc, true);
    }
    /**
    @internal
    */
  }, {
    key: "_map",
    value: function _map(pos, assoc, simple) {
      var diff = 0,
        oldIndex = this.inverted ? 2 : 1,
        newIndex = this.inverted ? 1 : 2;
      for (var i = 0; i < this.ranges.length; i += 3) {
        var start = this.ranges[i] - (this.inverted ? diff : 0);
        if (start > pos) break;
        var oldSize = this.ranges[i + oldIndex],
          newSize = this.ranges[i + newIndex],
          end = start + oldSize;
        if (pos <= end) {
          var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
          var result = start + diff + (side < 0 ? 0 : newSize);
          if (simple) return result;
          var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
          var del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
          if (assoc < 0 ? pos != start : pos != end) del |= DEL_SIDE;
          return new MapResult(result, del, recover);
        }
        diff += newSize - oldSize;
      }
      return simple ? pos + diff : new MapResult(pos + diff, 0, null);
    }
    /**
    @internal
    */
  }, {
    key: "touches",
    value: function touches(pos, recover) {
      var diff = 0,
        index = recoverIndex(recover);
      var oldIndex = this.inverted ? 2 : 1,
        newIndex = this.inverted ? 1 : 2;
      for (var i = 0; i < this.ranges.length; i += 3) {
        var start = this.ranges[i] - (this.inverted ? diff : 0);
        if (start > pos) break;
        var oldSize = this.ranges[i + oldIndex],
          end = start + oldSize;
        if (pos <= end && i == index * 3) return true;
        diff += this.ranges[i + newIndex] - oldSize;
      }
      return false;
    }
    /**
    Calls the given function on each of the changed ranges included in
    this map.
    */
  }, {
    key: "forEach",
    value: function forEach(f) {
      var oldIndex = this.inverted ? 2 : 1,
        newIndex = this.inverted ? 1 : 2;
      for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {
        var start = this.ranges[i],
          oldStart = start - (this.inverted ? diff : 0),
          newStart = start + (this.inverted ? 0 : diff);
        var oldSize = this.ranges[i + oldIndex],
          newSize = this.ranges[i + newIndex];
        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
        diff += newSize - oldSize;
      }
    }
    /**
    Create an inverted version of this map. The result can be used to
    map positions in the post-step document to the pre-step document.
    */
  }, {
    key: "invert",
    value: function invert() {
      return new StepMap(this.ranges, !this.inverted);
    }
    /**
    @internal
    */
  }, {
    key: "toString",
    value: function toString() {
      return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
    }
    /**
    Create a map that moves all positions by offset `n` (which may be
    negative). This can be useful when applying steps meant for a
    sub-document to a larger document, or vice-versa.
    */
  }], [{
    key: "offset",
    value: function offset(n) {
      return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
    }
  }]);
  return StepMap;
}();
/**
A StepMap that contains no changed ranges.
*/
StepMap.empty = new StepMap([]);
/**
A mapping represents a pipeline of zero or more [step
maps](https://prosemirror.net/docs/ref/#transform.StepMap). It has special provisions for losslessly
handling mapping positions through a series of steps in which some
steps are inverted versions of earlier steps. (This comes up when
[rebasing](/docs/guide/#transform.rebasing) steps for
collaboration or history management.)
*/
var Mapping = /*#__PURE__*/function () {
  /**
  Create a new mapping with the given position maps.
  */
  function Mapping() {
    var maps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var
    /**
    @internal
    */
    mirror = arguments.length > 1 ? arguments[1] : undefined;
    var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var to = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : maps.length;
    _classCallCheck(this, Mapping);
    this.maps = maps;
    this.mirror = mirror;
    this.from = from;
    this.to = to;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  _createClass(Mapping, [{
    key: "slice",
    value: function slice() {
      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.maps.length;
      return new Mapping(this.maps, this.mirror, from, to);
    }
    /**
    @internal
    */
  }, {
    key: "copy",
    value: function copy() {
      return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
    }
    /**
    Add a step map to the end of this mapping. If `mirrors` is
    given, it should be the index of the step map that is the mirror
    image of this one.
    */
  }, {
    key: "appendMap",
    value: function appendMap(map, mirrors) {
      this.to = this.maps.push(map);
      if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors);
    }
    /**
    Add all the step maps in a given mapping to this one (preserving
    mirroring information).
    */
  }, {
    key: "appendMapping",
    value: function appendMapping(mapping) {
      for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
        var mirr = mapping.getMirror(i);
        this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : undefined);
      }
    }
    /**
    Finds the offset of the step map that mirrors the map at the
    given offset, in this mapping (as per the second argument to
    `appendMap`).
    */
  }, {
    key: "getMirror",
    value: function getMirror(n) {
      if (this.mirror) for (var i = 0; i < this.mirror.length; i++) if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)];
    }
    /**
    @internal
    */
  }, {
    key: "setMirror",
    value: function setMirror(n, m) {
      if (!this.mirror) this.mirror = [];
      this.mirror.push(n, m);
    }
    /**
    Append the inverse of the given mapping to this one.
    */
  }, {
    key: "appendMappingInverted",
    value: function appendMappingInverted(mapping) {
      for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
        var mirr = mapping.getMirror(i);
        this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : undefined);
      }
    }
    /**
    Create an inverted version of this mapping.
    */
  }, {
    key: "invert",
    value: function invert() {
      var inverse = new Mapping();
      inverse.appendMappingInverted(this);
      return inverse;
    }
    /**
    Map a position through this mapping.
    */
  }, {
    key: "map",
    value: function map(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      if (this.mirror) return this._map(pos, assoc, true);
      for (var i = this.from; i < this.to; i++) pos = this.maps[i].map(pos, assoc);
      return pos;
    }
    /**
    Map a position through this mapping, returning a mapping
    result.
    */
  }, {
    key: "mapResult",
    value: function mapResult(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this._map(pos, assoc, false);
    }
    /**
    @internal
    */
  }, {
    key: "_map",
    value: function _map(pos, assoc, simple) {
      var delInfo = 0;
      for (var i = this.from; i < this.to; i++) {
        var map = this.maps[i],
          result = map.mapResult(pos, assoc);
        if (result.recover != null) {
          var corr = this.getMirror(i);
          if (corr != null && corr > i && corr < this.to) {
            i = corr;
            pos = this.maps[corr].recover(result.recover);
            continue;
          }
        }
        delInfo |= result.delInfo;
        pos = result.pos;
      }
      return simple ? pos : new MapResult(pos, delInfo, null);
    }
  }]);
  return Mapping;
}();
var stepsByID = Object.create(null);
/**
A step object represents an atomic change. It generally applies
only to the document it was created for, since the positions
stored in it will only make sense for that document.

New steps are defined by creating classes that extend `Step`,
overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`
methods, and registering your class with a unique
JSON-serialization identifier using
[`Step.jsonID`](https://prosemirror.net/docs/ref/#transform.Step^jsonID).
*/
var Step = /*#__PURE__*/function () {
  function Step() {
    _classCallCheck(this, Step);
  }
  _createClass(Step, [{
    key: "getMap",
    value:
    /**
    Get the step map that represents the changes made by this step,
    and which can be used to transform between positions in the old
    and the new document.
    */
    function getMap() {
      return StepMap.empty;
    }
    /**
    Try to merge this step with another one, to be applied directly
    after it. Returns the merged step when possible, null if the
    steps can't be merged.
    */
  }, {
    key: "merge",
    value: function merge(other) {
      return null;
    }
    /**
    Deserialize a step from its JSON representation. Will call
    through to the step class' own implementation of this method.
    */
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (!json || !json.stepType) throw new RangeError("Invalid input for Step.fromJSON");
      var type = stepsByID[json.stepType];
      if (!type) throw new RangeError("No step type ".concat(json.stepType, " defined"));
      return type.fromJSON(schema, json);
    }
    /**
    To be able to serialize steps to JSON, each step needs a string
    ID to attach to its JSON representation. Use this method to
    register an ID for your step classes. Try to pick something
    that's unlikely to clash with steps from other modules.
    */
  }, {
    key: "jsonID",
    value: function jsonID(id, stepClass) {
      if (id in stepsByID) throw new RangeError("Duplicate use of step JSON ID " + id);
      stepsByID[id] = stepClass;
      stepClass.prototype.jsonID = id;
      return stepClass;
    }
  }]);
  return Step;
}();
/**
The result of [applying](https://prosemirror.net/docs/ref/#transform.Step.apply) a step. Contains either a
new document or a failure value.
*/
var StepResult = /*#__PURE__*/function () {
  /**
  @internal
  */
  function StepResult(
  /**
  The transformed document, if successful.
  */
  doc,
  /**
  The failure message, if unsuccessful.
  */
  failed) {
    _classCallCheck(this, StepResult);
    this.doc = doc;
    this.failed = failed;
  }
  /**
  Create a successful step result.
  */
  _createClass(StepResult, null, [{
    key: "ok",
    value: function ok(doc) {
      return new StepResult(doc, null);
    }
    /**
    Create a failed step result.
    */
  }, {
    key: "fail",
    value: function fail(message) {
      return new StepResult(null, message);
    }
    /**
    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
    arguments. Create a successful result if it succeeds, and a
    failed one if it throws a `ReplaceError`.
    */
  }, {
    key: "fromReplace",
    value: function fromReplace(doc, from, to, slice) {
      try {
        return StepResult.ok(doc.replace(from, to, slice));
      } catch (e) {
        if (e instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError) return StepResult.fail(e.message);
        throw e;
      }
    }
  }]);
  return StepResult;
}();
function mapFragment(fragment, f, parent) {
  var mapped = [];
  for (var i = 0; i < fragment.childCount; i++) {
    var child = fragment.child(i);
    if (child.content.size) child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline) child = f(child, parent, i);
    mapped.push(child);
  }
  return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.fromArray(mapped);
}
/**
Add a mark to all inline content between two positions.
*/
var AddMarkStep = /*#__PURE__*/function (_Step) {
  _inherits(AddMarkStep, _Step);
  /**
  Create a mark step.
  */
  function AddMarkStep(
  /**
  The start of the marked range.
  */
  from,
  /**
  The end of the marked range.
  */
  to,
  /**
  The mark to add.
  */
  mark) {
    var _this;
    _classCallCheck(this, AddMarkStep);
    _this = _callSuper(this, AddMarkStep);
    _this.from = from;
    _this.to = to;
    _this.mark = mark;
    return _this;
  }
  _createClass(AddMarkStep, [{
    key: "apply",
    value: function apply(doc) {
      var _this2 = this;
      var oldSlice = doc.slice(this.from, this.to),
        $from = doc.resolve(this.from);
      var parent = $from.node($from.sharedDepth(this.to));
      var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, function (node, parent) {
        if (!node.isAtom || !parent.type.allowsMarkType(_this2.mark.type)) return node;
        return node.mark(_this2.mark.addToSet(node.marks));
      }, parent), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc, this.from, this.to, slice);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new RemoveMarkStep(this.from, this.to, this.mark);
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var from = mapping.mapResult(this.from, 1),
        to = mapping.mapResult(this.to, -1);
      if (from.deleted && to.deleted || from.pos >= to.pos) return null;
      return new AddMarkStep(from.pos, to.pos, this.mark);
    }
  }, {
    key: "merge",
    value: function merge(other) {
      if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        stepType: "addMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
    /**
    @internal
    */
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number") throw new RangeError("Invalid input for AddMarkStep.fromJSON");
      return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
  }]);
  return AddMarkStep;
}(Step);
Step.jsonID("addMark", AddMarkStep);
/**
Remove a mark from all inline content between two positions.
*/
var RemoveMarkStep = /*#__PURE__*/function (_Step2) {
  _inherits(RemoveMarkStep, _Step2);
  /**
  Create a mark-removing step.
  */
  function RemoveMarkStep(
  /**
  The start of the unmarked range.
  */
  from,
  /**
  The end of the unmarked range.
  */
  to,
  /**
  The mark to remove.
  */
  mark) {
    var _this3;
    _classCallCheck(this, RemoveMarkStep);
    _this3 = _callSuper(this, RemoveMarkStep);
    _this3.from = from;
    _this3.to = to;
    _this3.mark = mark;
    return _this3;
  }
  _createClass(RemoveMarkStep, [{
    key: "apply",
    value: function apply(doc) {
      var _this4 = this;
      var oldSlice = doc.slice(this.from, this.to);
      var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, function (node) {
        return node.mark(_this4.mark.removeFromSet(node.marks));
      }, doc), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc, this.from, this.to, slice);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new AddMarkStep(this.from, this.to, this.mark);
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var from = mapping.mapResult(this.from, 1),
        to = mapping.mapResult(this.to, -1);
      if (from.deleted && to.deleted || from.pos >= to.pos) return null;
      return new RemoveMarkStep(from.pos, to.pos, this.mark);
    }
  }, {
    key: "merge",
    value: function merge(other) {
      if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        stepType: "removeMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
    /**
    @internal
    */
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number") throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
      return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
  }]);
  return RemoveMarkStep;
}(Step);
Step.jsonID("removeMark", RemoveMarkStep);
/**
Add a mark to a specific node.
*/
var AddNodeMarkStep = /*#__PURE__*/function (_Step3) {
  _inherits(AddNodeMarkStep, _Step3);
  /**
  Create a node mark step.
  */
  function AddNodeMarkStep(
  /**
  The position of the target node.
  */
  pos,
  /**
  The mark to add.
  */
  mark) {
    var _this5;
    _classCallCheck(this, AddNodeMarkStep);
    _this5 = _callSuper(this, AddNodeMarkStep);
    _this5.pos = pos;
    _this5.mark = mark;
    return _this5;
  }
  _createClass(AddNodeMarkStep, [{
    key: "apply",
    value: function apply(doc) {
      var node = doc.nodeAt(this.pos);
      if (!node) return StepResult.fail("No node at mark step's position");
      var updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
      return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
    }
  }, {
    key: "invert",
    value: function invert(doc) {
      var node = doc.nodeAt(this.pos);
      if (node) {
        var newSet = this.mark.addToSet(node.marks);
        if (newSet.length == node.marks.length) {
          for (var i = 0; i < node.marks.length; i++) if (!node.marks[i].isInSet(newSet)) return new AddNodeMarkStep(this.pos, node.marks[i]);
          return new AddNodeMarkStep(this.pos, this.mark);
        }
      }
      return new RemoveNodeMarkStep(this.pos, this.mark);
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        stepType: "addNodeMark",
        pos: this.pos,
        mark: this.mark.toJSON()
      };
    }
    /**
    @internal
    */
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.pos != "number") throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
      return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
    }
  }]);
  return AddNodeMarkStep;
}(Step);
Step.jsonID("addNodeMark", AddNodeMarkStep);
/**
Remove a mark from a specific node.
*/
var RemoveNodeMarkStep = /*#__PURE__*/function (_Step4) {
  _inherits(RemoveNodeMarkStep, _Step4);
  /**
  Create a mark-removing step.
  */
  function RemoveNodeMarkStep(
  /**
  The position of the target node.
  */
  pos,
  /**
  The mark to remove.
  */
  mark) {
    var _this6;
    _classCallCheck(this, RemoveNodeMarkStep);
    _this6 = _callSuper(this, RemoveNodeMarkStep);
    _this6.pos = pos;
    _this6.mark = mark;
    return _this6;
  }
  _createClass(RemoveNodeMarkStep, [{
    key: "apply",
    value: function apply(doc) {
      var node = doc.nodeAt(this.pos);
      if (!node) return StepResult.fail("No node at mark step's position");
      var updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
      return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
    }
  }, {
    key: "invert",
    value: function invert(doc) {
      var node = doc.nodeAt(this.pos);
      if (!node || !this.mark.isInSet(node.marks)) return this;
      return new AddNodeMarkStep(this.pos, this.mark);
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        stepType: "removeNodeMark",
        pos: this.pos,
        mark: this.mark.toJSON()
      };
    }
    /**
    @internal
    */
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.pos != "number") throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
      return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
    }
  }]);
  return RemoveNodeMarkStep;
}(Step);
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);

/**
Replace a part of the document with a slice of new content.
*/
var ReplaceStep = /*#__PURE__*/function (_Step5) {
  _inherits(ReplaceStep, _Step5);
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  function ReplaceStep(
  /**
  The start position of the replaced range.
  */
  from,
  /**
  The end position of the replaced range.
  */
  to,
  /**
  The slice to insert.
  */
  slice) {
    var _this7;
    var structure = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    _classCallCheck(this, ReplaceStep);
    _this7 = _callSuper(this, ReplaceStep);
    _this7.from = from;
    _this7.to = to;
    _this7.slice = slice;
    _this7.structure = structure;
    return _this7;
  }
  _createClass(ReplaceStep, [{
    key: "apply",
    value: function apply(doc) {
      if (this.structure && contentBetween(doc, this.from, this.to)) return StepResult.fail("Structure replace would overwrite content");
      return StepResult.fromReplace(doc, this.from, this.to, this.slice);
    }
  }, {
    key: "getMap",
    value: function getMap() {
      return new StepMap([this.from, this.to - this.from, this.slice.size]);
    }
  }, {
    key: "invert",
    value: function invert(doc) {
      return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var from = mapping.mapResult(this.from, 1),
        to = mapping.mapResult(this.to, -1);
      if (from.deletedAcross && to.deletedAcross) return null;
      return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);
    }
  }, {
    key: "merge",
    value: function merge(other) {
      if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null;
      if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
        var slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
        return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);
      } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
        var _slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
        return new ReplaceStep(other.from, this.to, _slice, this.structure);
      } else {
        return null;
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = {
        stepType: "replace",
        from: this.from,
        to: this.to
      };
      if (this.slice.size) json.slice = this.slice.toJSON();
      if (this.structure) json.structure = true;
      return json;
    }
    /**
    @internal
    */
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number") throw new RangeError("Invalid input for ReplaceStep.fromJSON");
      return new ReplaceStep(json.from, json.to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), !!json.structure);
    }
  }]);
  return ReplaceStep;
}(Step);
Step.jsonID("replace", ReplaceStep);
/**
Replace a part of the document with a slice of content, but
preserve a range of the replaced content by moving it into the
slice.
*/
var ReplaceAroundStep = /*#__PURE__*/function (_Step6) {
  _inherits(ReplaceAroundStep, _Step6);
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  function ReplaceAroundStep(
  /**
  The start position of the replaced range.
  */
  from,
  /**
  The end position of the replaced range.
  */
  to,
  /**
  The start of preserved range.
  */
  gapFrom,
  /**
  The end of preserved range.
  */
  gapTo,
  /**
  The slice to insert.
  */
  slice,
  /**
  The position in the slice where the preserved range should be
  inserted.
  */
  insert) {
    var _this8;
    var structure = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    _classCallCheck(this, ReplaceAroundStep);
    _this8 = _callSuper(this, ReplaceAroundStep);
    _this8.from = from;
    _this8.to = to;
    _this8.gapFrom = gapFrom;
    _this8.gapTo = gapTo;
    _this8.slice = slice;
    _this8.insert = insert;
    _this8.structure = structure;
    return _this8;
  }
  _createClass(ReplaceAroundStep, [{
    key: "apply",
    value: function apply(doc) {
      if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to))) return StepResult.fail("Structure gap-replace would overwrite content");
      var gap = doc.slice(this.gapFrom, this.gapTo);
      if (gap.openStart || gap.openEnd) return StepResult.fail("Gap is not a flat range");
      var inserted = this.slice.insertAt(this.insert, gap.content);
      if (!inserted) return StepResult.fail("Content does not fit in gap");
      return StepResult.fromReplace(doc, this.from, this.to, inserted);
    }
  }, {
    key: "getMap",
    value: function getMap() {
      return new StepMap([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);
    }
  }, {
    key: "invert",
    value: function invert(doc) {
      var gap = this.gapTo - this.gapFrom;
      return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var from = mapping.mapResult(this.from, 1),
        to = mapping.mapResult(this.to, -1);
      var gapFrom = mapping.map(this.gapFrom, -1),
        gapTo = mapping.map(this.gapTo, 1);
      if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos) return null;
      return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = {
        stepType: "replaceAround",
        from: this.from,
        to: this.to,
        gapFrom: this.gapFrom,
        gapTo: this.gapTo,
        insert: this.insert
      };
      if (this.slice.size) json.slice = this.slice.toJSON();
      if (this.structure) json.structure = true;
      return json;
    }
    /**
    @internal
    */
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number") throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
      return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
    }
  }]);
  return ReplaceAroundStep;
}(Step);
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc, from, to) {
  var $from = doc.resolve(from),
    dist = to - from,
    depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    var next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf) return true;
      next = next.firstChild;
      dist--;
    }
  }
  return false;
}
function _addMark(tr, from, to, mark) {
  var removed = [],
    added = [];
  var removing, adding;
  tr.doc.nodesBetween(from, to, function (node, pos, parent) {
    if (!node.isInline) return;
    var marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      var start = Math.max(pos, from),
        end = Math.min(pos + node.nodeSize, to);
      var newSet = mark.addToSet(marks);
      for (var i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks[i])) removing.to = end;else removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
        }
      }
      if (adding && adding.to == start) adding.to = end;else added.push(adding = new AddMarkStep(start, end, mark));
    }
  });
  removed.forEach(function (s) {
    return tr.step(s);
  });
  added.forEach(function (s) {
    return tr.step(s);
  });
}
function _removeMark(tr, from, to, mark) {
  var matched = [],
    step = 0;
  tr.doc.nodesBetween(from, to, function (node, pos) {
    if (!node.isInline) return;
    step++;
    var toRemove = null;
    if (mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType) {
      var set = node.marks,
        found;
      while (found = mark.isInSet(set)) {
        (toRemove || (toRemove = [])).push(found);
        set = found.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks)) toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      var end = Math.min(pos + node.nodeSize, to);
      for (var i = 0; i < toRemove.length; i++) {
        var style = toRemove[i],
          _found = void 0;
        for (var j = 0; j < matched.length; j++) {
          var m = matched[j];
          if (m.step == step - 1 && style.eq(matched[j].style)) _found = m;
        }
        if (_found) {
          _found.to = end;
          _found.step = step;
        } else {
          matched.push({
            style: style,
            from: Math.max(pos, from),
            to: end,
            step: step
          });
        }
      }
    }
  });
  matched.forEach(function (m) {
    return tr.step(new RemoveMarkStep(m.from, m.to, m.style));
  });
}
function _clearIncompatible(tr, pos, parentType) {
  var match = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : parentType.contentMatch;
  var node = tr.doc.nodeAt(pos);
  var replSteps = [],
    cur = pos + 1;
  for (var i = 0; i < node.childCount; i++) {
    var child = node.child(i),
      end = cur + child.nodeSize;
    var allowed = match.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty));
    } else {
      match = allowed;
      for (var j = 0; j < child.marks.length; j++) if (!parentType.allowsMarkType(child.marks[j].type)) tr.step(new RemoveMarkStep(cur, end, child.marks[j]));
      if (child.isText && !parentType.spec.code) {
        var m = void 0,
          newline = /\r?\n|\r/g,
          slice = void 0;
        while (m = newline.exec(child.text)) {
          if (!slice) slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice));
        }
      }
    }
    cur = end;
  }
  if (!match.validEnd) {
    var fill = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);
    tr.replace(cur, cur, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(fill, 0, 0));
  }
  for (var _i = replSteps.length - 1; _i >= 0; _i--) tr.step(replSteps[_i]);
}
function canCut(node, start, end) {
  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
}
/**
Try to find a target depth to which the content in the given range
can be lifted. Will not go across
[isolating](https://prosemirror.net/docs/ref/#model.NodeSpec.isolating) parent nodes.
*/
function liftTarget(range) {
  var parent = range.parent;
  var content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (var depth = range.depth;; --depth) {
    var node = range.$from.node(depth);
    var index = range.$from.index(depth),
      endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index, endIndex, content)) return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break;
  }
  return null;
}
function _lift(tr, range, target) {
  var $from = range.$from,
    $to = range.$to,
    depth = range.depth;
  var gapStart = $from.before(depth + 1),
    gapEnd = $to.after(depth + 1);
  var start = gapStart,
    end = gapEnd;
  var before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty,
    openStart = 0;
  for (var d = depth, splitting = false; d > target; d--) if (splitting || $from.index(d) > 0) {
    splitting = true;
    before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(before));
    openStart++;
  } else {
    start--;
  }
  var after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty,
    openEnd = 0;
  for (var _d = depth, _splitting = false; _d > target; _d--) if (_splitting || $to.after(_d + 1) < $to.end(_d)) {
    _splitting = true;
    after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($to.node(_d).copy(after));
    openEnd++;
  } else {
    end++;
  }
  tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
/**
Try to find a valid way to wrap the content in the given range in a
node of the given type. May introduce extra nodes around and inside
the wrapper node, if necessary. Returns null if no valid wrapping
could be found. When `innerRange` is given, that range's content is
used as the content to fit into the wrapping, instead of the
content of `range`.
*/
function findWrapping(range, nodeType) {
  var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var innerRange = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : range;
  var around = findWrappingOutside(range, nodeType);
  var inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner) return null;
  return around.map(withAttrs).concat({
    type: nodeType,
    attrs: attrs
  }).concat(inner.map(withAttrs));
}
function withAttrs(type) {
  return {
    type: type,
    attrs: null
  };
}
function findWrappingOutside(range, type) {
  var parent = range.parent,
    startIndex = range.startIndex,
    endIndex = range.endIndex;
  var around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around) return null;
  var outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range, type) {
  var parent = range.parent,
    startIndex = range.startIndex,
    endIndex = range.endIndex;
  var inner = parent.child(startIndex);
  var inside = type.contentMatch.findWrapping(inner.type);
  if (!inside) return null;
  var lastType = inside.length ? inside[inside.length - 1] : type;
  var innerMatch = lastType.contentMatch;
  for (var i = startIndex; innerMatch && i < endIndex; i++) innerMatch = innerMatch.matchType(parent.child(i).type);
  if (!innerMatch || !innerMatch.validEnd) return null;
  return inside;
}
function _wrap2(tr, range, wrappers) {
  var content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;
  for (var i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      var match = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd) throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }
  var start = range.start,
    end = range.end;
  tr.step(new ReplaceAroundStep(start, end, start, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, 0, 0), wrappers.length, true));
}
function _setBlockType(tr, from, to, type, attrs) {
  if (!type.isTextblock) throw new RangeError("Type given to setBlockType should be a textblock");
  var mapFrom = tr.steps.length;
  tr.doc.nodesBetween(from, to, function (node, pos) {
    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {
      // Ensure all markup that isn't allowed in the new node type is cleared
      tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos, 1), type);
      var mapping = tr.mapping.slice(mapFrom);
      var startM = mapping.map(pos, 1),
        endM = mapping.map(pos + node.nodeSize, 1);
      tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
      return false;
    }
  });
}
function canChangeType(doc, pos, type) {
  var $pos = doc.resolve(pos),
    index = $pos.index();
  return $pos.parent.canReplaceWith(index, index + 1, type);
}
/**
Change the type, attributes, and/or marks of the node at `pos`.
When `type` isn't given, the existing node type is preserved,
*/
function _setNodeMarkup(tr, pos, type, attrs, marks) {
  var node = tr.doc.nodeAt(pos);
  if (!node) throw new RangeError("No node at given position");
  if (!type) type = node.type;
  var newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf) return tr.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content)) throw new RangeError("Invalid content for node type " + type.name);
  tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(newNode), 0, 0), 1, true));
}
/**
Check whether splitting at the given position is allowed.
*/
function canSplit(doc, pos) {
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var typesAfter = arguments.length > 3 ? arguments[3] : undefined;
  var $pos = doc.resolve(pos),
    base = $pos.depth - depth;
  var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) return false;
  for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {
    var node = $pos.node(d),
      _index = $pos.index(d);
    if (node.type.spec.isolating) return false;
    var rest = node.content.cutByIndex(_index, node.childCount);
    var overrideChild = typesAfter && typesAfter[i + 1];
    if (overrideChild) rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    var after = typesAfter && typesAfter[i] || node;
    if (!node.canReplace(_index + 1, node.childCount) || !after.type.validContent(rest)) return false;
  }
  var index = $pos.indexAfter(base);
  var baseType = typesAfter && typesAfter[0];
  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);
}
function _split(tr, pos) {
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var typesAfter = arguments.length > 3 ? arguments[3] : undefined;
  var $pos = tr.doc.resolve(pos),
    before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty,
    after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;
  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($pos.node(d).copy(before));
    var typeAfter = typesAfter && typesAfter[i];
    after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  tr.step(new ReplaceStep(pos, pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), depth, depth), true));
}
/**
Test whether the blocks before and after a given position can be
joined.
*/
function canJoin(doc, pos) {
  var $pos = doc.resolve(pos),
    index = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
}
function joinable(a, b) {
  return !!(a && b && !a.isLeaf && a.canAppend(b));
}
/**
Find an ancestor of the given position that can be joined to the
block before (or after if `dir` is positive). Returns the joinable
point, if any.
*/
function joinPoint(doc, pos) {
  var dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
  var $pos = doc.resolve(pos);
  for (var d = $pos.depth;; d--) {
    var before = void 0,
      after = void 0,
      index = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index++;
      after = $pos.node(d).maybeChild(index);
    } else {
      before = $pos.node(d).maybeChild(index - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index, index + 1)) return pos;
    if (d == 0) break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}
function _join(tr, pos, depth) {
  var step = new ReplaceStep(pos - depth, pos + depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, true);
  tr.step(step);
}
/**
Try to find a point where a node of the given type can be inserted
near `pos`, by searching up the node hierarchy when `pos` itself
isn't a valid place but is at the start or end of a node. Return
null if no position was found.
*/
function insertPoint(doc, pos, nodeType) {
  var $pos = doc.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos;
  if ($pos.parentOffset == 0) for (var d = $pos.depth - 1; d >= 0; d--) {
    var index = $pos.index(d);
    if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1);
    if (index > 0) return null;
  }
  if ($pos.parentOffset == $pos.parent.content.size) for (var _d2 = $pos.depth - 1; _d2 >= 0; _d2--) {
    var _index2 = $pos.indexAfter(_d2);
    if ($pos.node(_d2).canReplaceWith(_index2, _index2, nodeType)) return $pos.after(_d2 + 1);
    if (_index2 < $pos.node(_d2).childCount) return null;
  }
  return null;
}
/**
Finds a position at or around the given position where the given
slice can be inserted. Will look at parent nodes' nearest boundary
and try there, even if the original position wasn't directly at the
start or end of that node. Returns null when no position was found.
*/
function dropPoint(doc, pos, slice) {
  var $pos = doc.resolve(pos);
  if (!slice.content.size) return pos;
  var content = slice.content;
  for (var i = 0; i < slice.openStart; i++) content = content.firstChild.content;
  for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
    for (var d = $pos.depth; d >= 0; d--) {
      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      var parent = $pos.node(d),
        fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits) return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }
  return null;
}

/**
Fit a slice into a given position in the document, producing a
[step](https://prosemirror.net/docs/ref/#transform.Step) that inserts it. Will return null if
there's no meaningful way to insert the slice here, or inserting it
would be a no-op (an empty slice over an empty range).
*/
function replaceStep(doc, from) {
  var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : from;
  var slice = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;
  if (from == to && !slice.size) return null;
  var $from = doc.resolve(from),
    $to = doc.resolve(to);
  // Optimization -- avoid work if it's obvious that it's not needed.
  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice);
  return new Fitter($from, $to, slice).fit();
}
function fitsTrivially($from, $to, slice) {
  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);
}
// Algorithm for 'placing' the elements of a slice into a gap:
//
// We consider the content of each node that is open to the left to be
// independently placeable. I.e. in <p("foo"), p("bar")>, when the
// paragraph on the left is open, "foo" can be placed (somewhere on
// the left side of the replacement gap) independently from p("bar").
//
// This class tracks the state of the placement progress in the
// following properties:
//
//  - `frontier` holds a stack of `{type, match}` objects that
//    represent the open side of the replacement. It starts at
//    `$from`, then moves forward as content is placed, and is finally
//    reconciled with `$to`.
//
//  - `unplaced` is a slice that represents the content that hasn't
//    been placed yet.
//
//  - `placed` is a fragment of placed content. Its open-start value
//    is implicit in `$from`, and its open-end value in `frontier`.
var Fitter = /*#__PURE__*/function () {
  function Fitter($from, $to, unplaced) {
    _classCallCheck(this, Fitter);
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;
    for (var i = 0; i <= $from.depth; i++) {
      var node = $from.node(i);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i))
      });
    }
    for (var _i2 = $from.depth; _i2 > 0; _i2--) this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(_i2).copy(this.placed));
  }
  _createClass(Fitter, [{
    key: "depth",
    get: function get() {
      return this.frontier.length - 1;
    }
  }, {
    key: "fit",
    value: function fit() {
      // As long as there's unplaced content, try to place some of it.
      // If that fails, either increase the open score of the unplaced
      // slice, or drop nodes from it, and then try again.
      while (this.unplaced.size) {
        var fit = this.findFittable();
        if (fit) this.placeNodes(fit);else this.openMore() || this.dropNode();
      }
      // When there's inline content directly after the frontier _and_
      // directly after `this.$to`, we must generate a `ReplaceAround`
      // step that pulls that content into the node after the frontier.
      // That means the fitting must be done to the end of the textblock
      // node after `this.$to`, not `this.$to` itself.
      var moveInline = this.mustMoveInline(),
        placedSize = this.placed.size - this.depth - this.$from.depth;
      var $from = this.$from,
        $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
      if (!$to) return null;
      // If closing to `$to` succeeded, create a step
      var content = this.placed,
        openStart = $from.depth,
        openEnd = $to.depth;
      while (openStart && openEnd && content.childCount == 1) {
        // Normalize by dropping open parent nodes
        content = content.firstChild.content;
        openStart--;
        openEnd--;
      }
      var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);
      if (moveInline > -1) return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);
      if (slice.size || $from.pos != this.$to.pos)
        // Don't generate no-op steps
        return new ReplaceStep($from.pos, $to.pos, slice);
      return null;
    }
    // Find a position on the start spine of `this.unplaced` that has
    // content that can be moved somewhere on the frontier. Returns two
    // depths, one for the slice and one for the frontier.
  }, {
    key: "findFittable",
    value: function findFittable() {
      var startDepth = this.unplaced.openStart;
      for (var cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
        var node = cur.firstChild;
        if (cur.childCount > 1) openEnd = 0;
        if (node.type.spec.isolating && openEnd <= d) {
          startDepth = d;
          break;
        }
        cur = node.content;
      }
      // Only try wrapping nodes (pass 2) after finding a place without
      // wrapping failed.
      for (var pass = 1; pass <= 2; pass++) {
        for (var sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
          var fragment = void 0,
            parent = null;
          if (sliceDepth) {
            parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
            fragment = parent.content;
          } else {
            fragment = this.unplaced.content;
          }
          var first = fragment.firstChild;
          for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
            var _this$frontier$fronti = this.frontier[frontierDepth],
              type = _this$frontier$fronti.type,
              match = _this$frontier$fronti.match,
              _wrap = void 0,
              inject = null;
            // In pass 1, if the next node matches, or there is no next
            // node but the parents look compatible, we've found a
            // place.
            if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(first), false)) : parent && type.compatibleContent(parent.type))) return {
              sliceDepth: sliceDepth,
              frontierDepth: frontierDepth,
              parent: parent,
              inject: inject
            };
            // In pass 2, look for a set of wrapping nodes that make
            // `first` fit here.
            else if (pass == 2 && first && (_wrap = match.findWrapping(first.type))) return {
              sliceDepth: sliceDepth,
              frontierDepth: frontierDepth,
              parent: parent,
              wrap: _wrap
            };
            // Don't continue looking further up if the parent node
            // would fit here.
            if (parent && match.matchType(parent.type)) break;
          }
        }
      }
    }
  }, {
    key: "openMore",
    value: function openMore() {
      var _this$unplaced = this.unplaced,
        content = _this$unplaced.content,
        openStart = _this$unplaced.openStart,
        openEnd = _this$unplaced.openEnd;
      var inner = contentAt(content, openStart);
      if (!inner.childCount || inner.firstChild.isLeaf) return false;
      this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
      return true;
    }
  }, {
    key: "dropNode",
    value: function dropNode() {
      var _this$unplaced2 = this.unplaced,
        content = _this$unplaced2.content,
        openStart = _this$unplaced2.openStart,
        openEnd = _this$unplaced2.openEnd;
      var inner = contentAt(content, openStart);
      if (inner.childCount <= 1 && openStart > 0) {
        var openAtEnd = content.size - openStart <= openStart + inner.size;
        this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
      } else {
        this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
      }
    }
    // Move content from the unplaced slice at `sliceDepth` to the
    // frontier node at `frontierDepth`. Close that frontier node when
    // applicable.
  }, {
    key: "placeNodes",
    value: function placeNodes(_ref) {
      var sliceDepth = _ref.sliceDepth,
        frontierDepth = _ref.frontierDepth,
        parent = _ref.parent,
        inject = _ref.inject,
        wrap = _ref.wrap;
      while (this.depth > frontierDepth) this.closeFrontierNode();
      if (wrap) for (var i = 0; i < wrap.length; i++) this.openFrontierNode(wrap[i]);
      var slice = this.unplaced,
        fragment = parent ? parent.content : slice.content;
      var openStart = slice.openStart - sliceDepth;
      var taken = 0,
        add = [];
      var _this$frontier$fronti2 = this.frontier[frontierDepth],
        match = _this$frontier$fronti2.match,
        type = _this$frontier$fronti2.type;
      if (inject) {
        for (var _i3 = 0; _i3 < inject.childCount; _i3++) add.push(inject.child(_i3));
        match = match.matchFragment(inject);
      }
      // Computes the amount of (end) open nodes at the end of the
      // fragment. When 0, the parent is open, but no more. When
      // negative, nothing is open.
      var openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);
      // Scan over the fragment, fitting as many child nodes as
      // possible.
      while (taken < fragment.childCount) {
        var next = fragment.child(taken),
          matches = match.matchType(next.type);
        if (!matches) break;
        taken++;
        if (taken > 1 || openStart == 0 || next.content.size) {
          // Drop empty open nodes
          match = matches;
          add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
        }
      }
      var toEnd = taken == fragment.childCount;
      if (!toEnd) openEndCount = -1;
      this.placed = addToFragment(this.placed, frontierDepth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(add));
      this.frontier[frontierDepth].match = match;
      // If the parent types match, and the entire node was moved, and
      // it's not open, close this frontier node right away.
      if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) this.closeFrontierNode();
      // Add new frontier nodes for any open nodes at the end.
      for (var _i4 = 0, cur = fragment; _i4 < openEndCount; _i4++) {
        var node = cur.lastChild;
        this.frontier.push({
          type: node.type,
          match: node.contentMatchAt(node.childCount)
        });
        cur = node.content;
      }
      // Update `this.unplaced`. Drop the entire node from which we
      // placed it we got to its end, otherwise just drop the placed
      // nodes.
      this.unplaced = !toEnd ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
    }
  }, {
    key: "mustMoveInline",
    value: function mustMoveInline() {
      if (!this.$to.parent.isTextblock) return -1;
      var top = this.frontier[this.depth],
        level;
      if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) return -1;
      var depth = this.$to.depth,
        after = this.$to.after(depth);
      while (depth > 1 && after == this.$to.end(--depth)) ++after;
      return after;
    }
  }, {
    key: "findCloseLevel",
    value: function findCloseLevel($to) {
      scan: for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {
        var _this$frontier$i = this.frontier[i],
          match = _this$frontier$i.match,
          type = _this$frontier$i.type;
        var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
        var fit = contentAfterFits($to, i, type, match, dropInner);
        if (!fit) continue;
        for (var d = i - 1; d >= 0; d--) {
          var _this$frontier$d = this.frontier[d],
            _match = _this$frontier$d.match,
            _type = _this$frontier$d.type;
          var matches = contentAfterFits($to, d, _type, _match, true);
          if (!matches || matches.childCount) continue scan;
        }
        return {
          depth: i,
          fit: fit,
          move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to
        };
      }
    }
  }, {
    key: "close",
    value: function close($to) {
      var close = this.findCloseLevel($to);
      if (!close) return null;
      while (this.depth > close.depth) this.closeFrontierNode();
      if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit);
      $to = close.move;
      for (var d = close.depth + 1; d <= $to.depth; d++) {
        var node = $to.node(d),
          add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
        this.openFrontierNode(node.type, node.attrs, add);
      }
      return $to;
    }
  }, {
    key: "openFrontierNode",
    value: function openFrontierNode(type) {
      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var content = arguments.length > 2 ? arguments[2] : undefined;
      var top = this.frontier[this.depth];
      top.match = top.match.matchType(type);
      this.placed = addToFragment(this.placed, this.depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, content)));
      this.frontier.push({
        type: type,
        match: type.contentMatch
      });
    }
  }, {
    key: "closeFrontierNode",
    value: function closeFrontierNode() {
      var open = this.frontier.pop();
      var add = open.match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);
      if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add);
    }
  }]);
  return Fitter;
}();
function dropFromFragment(fragment, depth, count) {
  if (depth == 0) return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0) return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (var i = 0; i < depth; i++) fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0) return node;
  var frag = node.content;
  if (openStart > 1) frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type, match, open) {
  var node = $to.node(depth),
    index = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index == node.childCount && !type.compatibleContent(node.type)) return null;
  var fit = match.fillBefore(node.content, true, index);
  return fit && !invalidMarks(type, node.content, index) ? fit : null;
}
function invalidMarks(type, fragment, start) {
  for (var i = start; i < fragment.childCount; i++) if (!type.allowsMarks(fragment.child(i).marks)) return true;
  return false;
}
function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}
function _replaceRange(tr, from, to, slice) {
  if (!slice.size) return tr.deleteRange(from, to);
  var $from = tr.doc.resolve(from),
    $to = tr.doc.resolve(to);
  if (fitsTrivially($from, $to, slice)) return tr.step(new ReplaceStep(from, to, slice));
  var targetDepths = coveredDepths($from, tr.doc.resolve(to));
  // Can't replace the whole document, so remove 0 if it's present
  if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop();
  // Negative numbers represent not expansion over the whole node at
  // that depth, but replacing from $from.before(-D) to $to.pos.
  var preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  // This loop picks a preferred target depth, if one of the covering
  // depths is not outside of a defining node, and adds negative
  // depths for any depth that has $from at its start and does not
  // cross a defining node.
  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    var spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating) break;
    if (targetDepths.indexOf(d) > -1) preferredTarget = d;else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d);
  }
  // Try to fit each possible depth of the slice into each possible
  // target depth, starting with the preferred depths.
  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  var leftNodes = [],
    preferredDepth = slice.openStart;
  for (var content = slice.content, i = 0;; i++) {
    var node = content.firstChild;
    leftNodes.push(node);
    if (i == slice.openStart) break;
    content = node.content;
  }
  // Back up preferredDepth to cover defining textblocks directly
  // above it, possibly skipping a non-defining textblock.
  for (var _d3 = preferredDepth - 1; _d3 >= 0; _d3--) {
    var leftNode = leftNodes[_d3],
      def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1))) preferredDepth = _d3;else if (def || !leftNode.type.isTextblock) break;
  }
  for (var j = slice.openStart; j >= 0; j--) {
    var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);
    var insert = leftNodes[openDepth];
    if (!insert) continue;
    for (var _i5 = 0; _i5 < targetDepths.length; _i5++) {
      // Loop over possible expansion levels, starting with the
      // preferred one
      var targetDepth = targetDepths[(_i5 + preferredTargetIndex) % targetDepths.length],
        expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      var parent = $from.node(targetDepth - 1),
        index = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index, index, insert.type, insert.marks)) return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));
    }
  }
  var startSteps = tr.steps.length;
  for (var _i6 = targetDepths.length - 1; _i6 >= 0; _i6--) {
    tr.replace(from, to, slice);
    if (tr.steps.length > startSteps) break;
    var depth = targetDepths[_i6];
    if (depth < 0) continue;
    from = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    var first = fragment.firstChild;
    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
  }
  if (depth > newOpen) {
    var match = parent.contentMatchAt(0);
    var start = match.fillBefore(fragment).append(fragment);
    fragment = start.append(match.matchFragment(start).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));
  }
  return fragment;
}
function _replaceRangeWith(tr, from, to, node) {
  if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {
    var point = insertPoint(tr.doc, from, node.type);
    if (point != null) from = to = point;
  }
  tr.replaceRange(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node), 0, 0));
}
function _deleteRange(tr, from, to) {
  var $from = tr.doc.resolve(from),
    $to = tr.doc.resolve(to);
  var covered = coveredDepths($from, $to);
  for (var i = 0; i < covered.length; i++) {
    var depth = covered[i],
      last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) return tr["delete"]($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) return tr["delete"]($from.before(depth), $to.after(depth));
  }
  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d) return tr["delete"]($from.before(d), to);
  }
  tr["delete"](from, to);
}
// Returns an array of all depths for which $from - $to spans the
// whole content of the nodes at that depth.
function coveredDepths($from, $to) {
  var result = [],
    minDepth = Math.min($from.depth, $to.depth);
  for (var d = minDepth; d >= 0; d--) {
    var start = $from.start(d);
    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) break;
    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1) result.push(d);
  }
  return result;
}

/**
Update an attribute in a specific node.
*/
var AttrStep = /*#__PURE__*/function (_Step7) {
  _inherits(AttrStep, _Step7);
  /**
  Construct an attribute step.
  */
  function AttrStep(
  /**
  The position of the target node.
  */
  pos,
  /**
  The attribute to set.
  */
  attr,
  // The attribute's new value.
  value) {
    var _this9;
    _classCallCheck(this, AttrStep);
    _this9 = _callSuper(this, AttrStep);
    _this9.pos = pos;
    _this9.attr = attr;
    _this9.value = value;
    return _this9;
  }
  _createClass(AttrStep, [{
    key: "apply",
    value: function apply(doc) {
      var node = doc.nodeAt(this.pos);
      if (!node) return StepResult.fail("No node at attribute step's position");
      var attrs = Object.create(null);
      for (var name in node.attrs) attrs[name] = node.attrs[name];
      attrs[this.attr] = this.value;
      var updated = node.type.create(attrs, null, node.marks);
      return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
    }
  }, {
    key: "getMap",
    value: function getMap() {
      return StepMap.empty;
    }
  }, {
    key: "invert",
    value: function invert(doc) {
      return new AttrStep(this.pos, this.attr, doc.nodeAt(this.pos).attrs[this.attr]);
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        stepType: "attr",
        pos: this.pos,
        attr: this.attr,
        value: this.value
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.pos != "number" || typeof json.attr != "string") throw new RangeError("Invalid input for AttrStep.fromJSON");
      return new AttrStep(json.pos, json.attr, json.value);
    }
  }]);
  return AttrStep;
}(Step);
Step.jsonID("attr", AttrStep);
/**
Update an attribute in the doc node.
*/
var DocAttrStep = /*#__PURE__*/function (_Step8) {
  _inherits(DocAttrStep, _Step8);
  /**
  Construct an attribute step.
  */
  function DocAttrStep(
  /**
  The attribute to set.
  */
  attr,
  // The attribute's new value.
  value) {
    var _this10;
    _classCallCheck(this, DocAttrStep);
    _this10 = _callSuper(this, DocAttrStep);
    _this10.attr = attr;
    _this10.value = value;
    return _this10;
  }
  _createClass(DocAttrStep, [{
    key: "apply",
    value: function apply(doc) {
      var attrs = Object.create(null);
      for (var name in doc.attrs) attrs[name] = doc.attrs[name];
      attrs[this.attr] = this.value;
      var updated = doc.type.create(attrs, doc.content, doc.marks);
      return StepResult.ok(updated);
    }
  }, {
    key: "getMap",
    value: function getMap() {
      return StepMap.empty;
    }
  }, {
    key: "invert",
    value: function invert(doc) {
      return new DocAttrStep(this.attr, doc.attrs[this.attr]);
    }
  }, {
    key: "map",
    value: function map(mapping) {
      return this;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        stepType: "docAttr",
        attr: this.attr,
        value: this.value
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.attr != "string") throw new RangeError("Invalid input for DocAttrStep.fromJSON");
      return new DocAttrStep(json.attr, json.value);
    }
  }]);
  return DocAttrStep;
}(Step);
Step.jsonID("docAttr", DocAttrStep);

/**
@internal
*/
var TransformError = /*#__PURE__*/function (_Error) {
  _inherits(TransformError, _Error);
  function TransformError() {
    _classCallCheck(this, TransformError);
    return _callSuper(this, TransformError, arguments);
  }
  return _createClass(TransformError);
}( /*#__PURE__*/_wrapNativeSuper(Error));
TransformError = function TransformError(message) {
  var err = Error.call(this, message);
  err.__proto__ = TransformError.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
/**
Abstraction to build up and track an array of
[steps](https://prosemirror.net/docs/ref/#transform.Step) representing a document transformation.

Most transforming methods return the `Transform` object itself, so
that they can be chained.
*/
var Transform = /*#__PURE__*/function () {
  /**
  Create a transform that starts with the given document.
  */
  function Transform(
  /**
  The current document (the result of applying the steps in the
  transform).
  */
  doc) {
    _classCallCheck(this, Transform);
    this.doc = doc;
    /**
    The steps in this transform.
    */
    this.steps = [];
    /**
    The documents before each of the steps.
    */
    this.docs = [];
    /**
    A mapping with the maps for each of the steps in this transform.
    */
    this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  _createClass(Transform, [{
    key: "before",
    get: function get() {
      return this.docs.length ? this.docs[0] : this.doc;
    }
    /**
    Apply a new step in this transform, saving the result. Throws an
    error when the step fails.
    */
  }, {
    key: "step",
    value: function step(_step) {
      var result = this.maybeStep(_step);
      if (result.failed) throw new TransformError(result.failed);
      return this;
    }
    /**
    Try to apply a step in this transformation, ignoring it if it
    fails. Returns the step result.
    */
  }, {
    key: "maybeStep",
    value: function maybeStep(step) {
      var result = step.apply(this.doc);
      if (!result.failed) this.addStep(step, result.doc);
      return result;
    }
    /**
    True when the document has been changed (when there are any
    steps).
    */
  }, {
    key: "docChanged",
    get: function get() {
      return this.steps.length > 0;
    }
    /**
    @internal
    */
  }, {
    key: "addStep",
    value: function addStep(step, doc) {
      this.docs.push(this.doc);
      this.steps.push(step);
      this.mapping.appendMap(step.getMap());
      this.doc = doc;
    }
    /**
    Replace the part of the document between `from` and `to` with the
    given `slice`.
    */
  }, {
    key: "replace",
    value: function replace(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;
      var slice = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;
      var step = replaceStep(this.doc, from, to, slice);
      if (step) this.step(step);
      return this;
    }
    /**
    Replace the given range with the given content, which may be a
    fragment, node, or array of nodes.
    */
  }, {
    key: "replaceWith",
    value: function replaceWith(from, to, content) {
      return this.replace(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(content), 0, 0));
    }
    /**
    Delete the content between the given positions.
    */
  }, {
    key: "delete",
    value: function _delete(from, to) {
      return this.replace(from, to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty);
    }
    /**
    Insert the given content at the given position.
    */
  }, {
    key: "insert",
    value: function insert(pos, content) {
      return this.replaceWith(pos, pos, content);
    }
    /**
    Replace a range of the document with a given slice, using
    `from`, `to`, and the slice's
    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
    than fixed start and end points. This method may grow the
    replaced area or close open nodes in the slice in order to get a
    fit that is more in line with WYSIWYG expectations, by dropping
    fully covered parent nodes of the replaced region when they are
    marked [non-defining as
    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
    open parent node from the slice that _is_ marked as [defining
    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
    
    This is the method, for example, to handle paste. The similar
    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
    primitive tool which will _not_ move the start and end of its given
    range, and is useful in situations where you need more precise
    control over what happens.
    */
  }, {
    key: "replaceRange",
    value: function replaceRange(from, to, slice) {
      _replaceRange(this, from, to, slice);
      return this;
    }
    /**
    Replace the given range with a node, but use `from` and `to` as
    hints, rather than precise positions. When from and to are the same
    and are at the start or end of a parent node in which the given
    node doesn't fit, this method may _move_ them out towards a parent
    that does allow the given node to be placed. When the given range
    completely covers a parent node, this method may completely replace
    that parent node.
    */
  }, {
    key: "replaceRangeWith",
    value: function replaceRangeWith(from, to, node) {
      _replaceRangeWith(this, from, to, node);
      return this;
    }
    /**
    Delete the given range, expanding it to cover fully covered
    parent nodes until a valid replace is found.
    */
  }, {
    key: "deleteRange",
    value: function deleteRange(from, to) {
      _deleteRange(this, from, to);
      return this;
    }
    /**
    Split the content in the given range off from its parent, if there
    is sibling content before or after it, and move it up the tree to
    the depth specified by `target`. You'll probably want to use
    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
    sure the lift is valid.
    */
  }, {
    key: "lift",
    value: function lift(range, target) {
      _lift(this, range, target);
      return this;
    }
    /**
    Join the blocks around the given position. If depth is 2, their
    last and first siblings are also joined, and so on.
    */
  }, {
    key: "join",
    value: function join(pos) {
      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      _join(this, pos, depth);
      return this;
    }
    /**
    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
    The wrappers are assumed to be valid in this position, and should
    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
    */
  }, {
    key: "wrap",
    value: function wrap(range, wrappers) {
      _wrap2(this, range, wrappers);
      return this;
    }
    /**
    Set the type of all textblocks (partly) between `from` and `to` to
    the given node type with the given attributes.
    */
  }, {
    key: "setBlockType",
    value: function setBlockType(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;
      var type = arguments.length > 2 ? arguments[2] : undefined;
      var attrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      _setBlockType(this, from, to, type, attrs);
      return this;
    }
    /**
    Change the type, attributes, and/or marks of the node at `pos`.
    When `type` isn't given, the existing node type is preserved,
    */
  }, {
    key: "setNodeMarkup",
    value: function setNodeMarkup(pos, type) {
      var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var marks = arguments.length > 3 ? arguments[3] : undefined;
      _setNodeMarkup(this, pos, type, attrs, marks);
      return this;
    }
    /**
    Set a single attribute on a given node to a new value.
    The `pos` addresses the document content. Use `setDocAttribute`
    to set attributes on the document itself.
    */
  }, {
    key: "setNodeAttribute",
    value: function setNodeAttribute(pos, attr, value) {
      this.step(new AttrStep(pos, attr, value));
      return this;
    }
    /**
    Set a single attribute on the document to a new value.
    */
  }, {
    key: "setDocAttribute",
    value: function setDocAttribute(attr, value) {
      this.step(new DocAttrStep(attr, value));
      return this;
    }
    /**
    Add a mark to the node at position `pos`.
    */
  }, {
    key: "addNodeMark",
    value: function addNodeMark(pos, mark) {
      this.step(new AddNodeMarkStep(pos, mark));
      return this;
    }
    /**
    Remove a mark (or a mark of the given type) from the node at
    position `pos`.
    */
  }, {
    key: "removeNodeMark",
    value: function removeNodeMark(pos, mark) {
      if (!(mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark)) {
        var node = this.doc.nodeAt(pos);
        if (!node) throw new RangeError("No node at position " + pos);
        mark = mark.isInSet(node.marks);
        if (!mark) return this;
      }
      this.step(new RemoveNodeMarkStep(pos, mark));
      return this;
    }
    /**
    Split the node at the given position, and optionally, if `depth` is
    greater than one, any number of nodes above that. By default, the
    parts split off will inherit the node type of the original node.
    This can be changed by passing an array of types and attributes to
    use after the split.
    */
  }, {
    key: "split",
    value: function split(pos) {
      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var typesAfter = arguments.length > 2 ? arguments[2] : undefined;
      _split(this, pos, depth, typesAfter);
      return this;
    }
    /**
    Add the given mark to the inline content between `from` and `to`.
    */
  }, {
    key: "addMark",
    value: function addMark(from, to, mark) {
      _addMark(this, from, to, mark);
      return this;
    }
    /**
    Remove marks from inline nodes between `from` and `to`. When
    `mark` is a single mark, remove precisely that mark. When it is
    a mark type, remove all marks of that type. When it is null,
    remove all marks of any type.
    */
  }, {
    key: "removeMark",
    value: function removeMark(from, to, mark) {
      _removeMark(this, from, to, mark);
      return this;
    }
    /**
    Removes all marks and nodes from the content of the node at
    `pos` that don't match the given new parent node type. Accepts
    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
    third argument.
    */
  }, {
    key: "clearIncompatible",
    value: function clearIncompatible(pos, parentType, match) {
      _clearIncompatible(this, pos, parentType, match);
      return this;
    }
  }]);
  return Transform;
}();


/***/ }),

/***/ "./node_modules/prosemirror-view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/prosemirror-view/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Decoration: function() { return /* binding */ Decoration; },
/* harmony export */   DecorationSet: function() { return /* binding */ DecorationSet; },
/* harmony export */   EditorView: function() { return /* binding */ EditorView; },
/* harmony export */   __endComposition: function() { return /* binding */ __endComposition; },
/* harmony export */   __parseFromClipboard: function() { return /* binding */ __parseFromClipboard; },
/* harmony export */   __serializeForClipboard: function() { return /* binding */ __serializeForClipboard; }
/* harmony export */ });
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.js");
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.js");
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.js");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }



var domIndex = function domIndex(node) {
  for (var index = 0;; index++) {
    node = node.previousSibling;
    if (!node) return index;
  }
};
var parentNode = function parentNode(node) {
  var parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
var reusedRange = null;
// Note that this will always return the same range, because DOM range
// objects are every expensive, and keep slowing down subsequent DOM
// updates, for some reason.
var textRange = function textRange(node, from, to) {
  var range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from || 0);
  return range;
};
// Scans forward and backward through DOM positions equivalent to the
// given one to see if the two are in the same place (i.e. after a
// text node vs at the end of that text node)
var isEquivalentPosition = function isEquivalentPosition(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};
var atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off, targetNode, targetOff, dir) {
  for (;;) {
    if (node == targetNode && off == targetOff) return true;
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      var parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false") return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.contentEditable == "false") return false;
      off = dir < 0 ? nodeSize(node) : 0;
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isOnEdge(node, offset, parent) {
  for (var atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {
    if (node == parent) return true;
    var index = domIndex(node);
    node = node.parentNode;
    if (!node) return false;
    atStart = atStart && index == 0;
    atEnd = atEnd && index == nodeSize(node);
  }
}
function hasBlockDesc(dom) {
  var desc;
  for (var cur = dom; cur; cur = cur.parentNode) if (desc = cur.pmViewDesc) break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523
// (isCollapsed inappropriately returns true in shadow dom)
var selectionCollapsed = function selectionCollapsed(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key) {
  var event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc) {
  var elt = doc.activeElement;
  while (elt && elt.shadowRoot) elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc, x, y) {
  if (doc.caretPositionFromPoint) {
    try {
      // Firefox throws for this call in hard-to-predict circumstances (#994)
      var pos = doc.caretPositionFromPoint(x, y);
      if (pos) return {
        node: pos.offsetNode,
        offset: pos.offset
      };
    } catch (_) {}
  }
  if (doc.caretRangeFromPoint) {
    var range = doc.caretRangeFromPoint(x, y);
    if (range) return {
      node: range.startContainer,
      offset: range.startOffset
    };
  }
}
var nav = typeof navigator != "undefined" ? navigator : null;
var doc = typeof document != "undefined" ? document : null;
var agent = nav && nav.userAgent || "";
var ie_edge = /Edge\/(\d+)/.exec(agent);
var ie_upto10 = /MSIE \d/.exec(agent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
var ie = !!(ie_upto10 || ie_11up || ie_edge);
var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
var gecko = !ie && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);
var chrome = !!_chrome;
var chrome_version = _chrome ? +_chrome[1] : 0;
var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
// Is true for both iOS and iPadOS for convenience
var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
var mac = ios || (nav ? /Mac/.test(nav.platform) : false);
var windows = nav ? /Win/.test(nav.platform) : false;
var android = /Android \d/.test(agent);
var webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;
var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc) {
  return {
    left: 0,
    right: doc.documentElement.clientWidth,
    top: 0,
    bottom: doc.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  var rect = node.getBoundingClientRect();
  // Adjust for elements with style "transform: scale()"
  var scaleX = rect.width / node.offsetWidth || 1;
  var scaleY = rect.height / node.offsetHeight || 1;
  // Make sure scrollbar width isn't included in the rectangle
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  var scrollThreshold = view.someProp("scrollThreshold") || 0,
    scrollMargin = view.someProp("scrollMargin") || 5;
  var doc = view.dom.ownerDocument;
  for (var parent = startDOM || view.dom;; parent = parentNode(parent)) {
    if (!parent) break;
    if (parent.nodeType != 1) continue;
    var elt = parent;
    var atTop = elt == doc.body;
    var bounding = atTop ? windowRect(doc) : clientRect(elt);
    var moveX = 0,
      moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top")) moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom")) moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left")) moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));else if (rect.right > bounding.right - getSide(scrollThreshold, "right")) moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc.defaultView.scrollBy(moveX, moveY);
      } else {
        var startX = elt.scrollLeft,
          startY = elt.scrollTop;
        if (moveY) elt.scrollTop += moveY;
        if (moveX) elt.scrollLeft += moveX;
        var dX = elt.scrollLeft - startX,
          dY = elt.scrollTop - startY;
        rect = {
          left: rect.left - dX,
          top: rect.top - dY,
          right: rect.right - dX,
          bottom: rect.bottom - dY
        };
      }
    }
    if (atTop || /^(fixed|sticky)$/.test(getComputedStyle(parent).position)) break;
  }
}
// Store the scroll position of the editor's parent nodes, along with
// the top position of an element near the top of the editor, which
// will be used to make sure the visible viewport remains stable even
// when the size of the content above changes.
function storeScrollPos(view) {
  var rect = view.dom.getBoundingClientRect(),
    startY = Math.max(0, rect.top);
  var refDOM, refTop;
  for (var x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    var dom = view.root.elementFromPoint(x, y);
    if (!dom || dom == view.dom || !view.dom.contains(dom)) continue;
    var localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return {
    refDOM: refDOM,
    refTop: refTop,
    stack: scrollStack(view.dom)
  };
}
function scrollStack(dom) {
  var stack = [],
    doc = dom.ownerDocument;
  for (var cur = dom; cur; cur = parentNode(cur)) {
    stack.push({
      dom: cur,
      top: cur.scrollTop,
      left: cur.scrollLeft
    });
    if (dom == doc) break;
  }
  return stack;
}
// Reset the scroll position of the editor's parent nodes to that what
// it was before, when storeScrollPos was called.
function resetScrollPos(_ref) {
  var refDOM = _ref.refDOM,
    refTop = _ref.refTop,
    stack = _ref.stack;
  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (var i = 0; i < stack.length; i++) {
    var _stack$i = stack[i],
      dom = _stack$i.dom,
      top = _stack$i.top,
      left = _stack$i.left;
    if (dom.scrollTop != top + dTop) dom.scrollTop = top + dTop;
    if (dom.scrollLeft != left) dom.scrollLeft = left;
  }
}
var preventScrollSupported = null;
// Feature-detects support for .focus({preventScroll: true}), and uses
// a fallback kludge when not supported.
function focusPreventScroll(dom) {
  if (dom.setActive) return dom.setActive(); // in IE
  if (preventScrollSupported) return dom.focus(preventScrollSupported);
  var stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = {
        preventScroll: true
      };
      return true;
    }
  } : undefined);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  var closest,
    dxClosest = 2e8,
    coordsClosest,
    offset = 0;
  var rowBot = coords.top,
    rowTop = coords.top;
  var firstBelow, coordsBelow;
  for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    var rects = void 0;
    if (child.nodeType == 1) rects = child.getClientRects();else if (child.nodeType == 3) rects = textRange(child).getClientRects();else continue;
    for (var i = 0; i < rects.length; i++) {
      var rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx) offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = {
          left: Math.max(rect.left, Math.min(rect.right, coords.left)),
          top: rect.top
        };
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) offset = childIndex + 1;
    }
  }
  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest && closest.nodeType == 3) return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1) return {
    node: node,
    offset: offset
  };
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node, coords) {
  var len = node.nodeValue.length;
  var range = document.createRange();
  for (var i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    var rect = singleRect(range, 1);
    if (rect.top == rect.bottom) continue;
    if (inRect(coords, rect)) return {
      node: node,
      offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)
    };
  }
  return {
    node: node,
    offset: 0
  };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  var parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  var _findOffsetInNode = findOffsetInNode(elt, coords),
    node = _findOffsetInNode.node,
    offset = _findOffsetInNode.offset,
    bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    var rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset, bias);
}
function posFromCaret(view, node, offset, coords) {
  // Browser (in caretPosition/RangeFromPoint) will agressively
  // normalize towards nearby inline nodes. Since we are interested in
  // positions between block nodes too, we first walk up the hierarchy
  // of nodes to see if there are block nodes that the coordinates
  // fall outside of. If so, we take the position before/after that
  // block. If not, we call `posFromDOM` on the raw node/offset.
  var outsideBlock = -1;
  for (var cur = node, sawBlock = false;;) {
    if (cur == view.dom) break;
    var desc = view.docView.nearestDesc(cur, true);
    if (!desc) return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent && !sawBlock || !desc.contentDOM)) {
      var rect = desc.dom.getBoundingClientRect();
      if (desc.node.isBlock && desc.parent && !sawBlock) {
        sawBlock = true;
        if (rect.left > coords.left || rect.top > coords.top) outsideBlock = desc.posBefore;else if (rect.right < coords.left || rect.bottom < coords.top) outsideBlock = desc.posAfter;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        // If we are inside a leaf, return the side of the leaf closer to the coords
        var before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);
}
function elementFromPoint(element, coords, box) {
  var len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;) {
      var child = element.childNodes[i];
      if (child.nodeType == 1) {
        var rects = child.getClientRects();
        for (var j = 0; j < rects.length; j++) {
          var rect = rects[j];
          if (inRect(coords, rect)) return elementFromPoint(child, coords, rect);
        }
      }
      if ((i = (i + 1) % len) == startI) break;
    }
  }
  return element;
}
// Given an x,y position on the editor, get the position in the document.
function _posAtCoords(view, coords) {
  var doc = view.dom.ownerDocument,
    node,
    offset = 0;
  var caret = caretFromPoint(doc, coords.left, coords.top);
  if (caret) {
    node = caret.node;
    offset = caret.offset;
  }
  var elt = (view.root.elementFromPoint ? view.root : doc).elementFromPoint(coords.left, coords.top);
  var pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    var box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box)) return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt) return null;
  }
  // Safari's caretRangeFromPoint returns nonsense when on a draggable element
  if (safari) {
    for (var p = elt; node && p; p = parentNode(p)) if (p.draggable) node = undefined;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko && node.nodeType == 1) {
      // Firefox will sometimes return offsets into <input> nodes, which
      // have no actual children, from caretPositionFromPoint (#953)
      offset = Math.min(offset, node.childNodes.length);
      // It'll also move the returned position before image nodes,
      // even if those are behind it.
      if (offset < node.childNodes.length) {
        var next = node.childNodes[offset],
          _box;
        if (next.nodeName == "IMG" && (_box = next.getBoundingClientRect()).right <= coords.left && _box.bottom > coords.top) offset++;
      }
    }
    var prev;
    // When clicking above the right side of an uneditable node, Chrome will report a cursor position after that node.
    if (webkit && offset && node.nodeType == 1 && (prev = node.childNodes[offset - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top) offset--;
    // Suspiciously specific kludge to work around caret*FromPoint
    // never returning a position at the end of the document
    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom) pos = view.state.doc.content.size;
    // Ignore positions directly after a BR, since caret*FromPoint
    // 'round up' positions that would be more accurately placed
    // before the BR node.
    else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR") pos = posFromCaret(view, node, offset, coords);
  }
  if (pos == null) pos = posFromElement(view, elt, coords);
  var desc = view.docView.nearestDesc(elt, true);
  return {
    pos: pos,
    inside: desc ? desc.posAtStart - desc.border : -1
  };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  var rects = target.getClientRects();
  if (rects.length) {
    var first = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first)) return first;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
// Given a position in the document model, get a bounding box of the
// character at that position, relative to the window.
function _coordsAtPos(view, pos, side) {
  var _view$docView$domFrom = view.docView.domFromPos(pos, side < 0 ? -1 : 1),
    node = _view$docView$domFrom.node,
    offset = _view$docView$domFrom.offset,
    atom = _view$docView$domFrom.atom;
  var supportEmptyRange = webkit || gecko;
  if (node.nodeType == 3) {
    // These browsers support querying empty text ranges. Prefer that in
    // bidi context or when at the end of a node.
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {
      var rect = singleRect(textRange(node, offset, offset), side);
      // Firefox returns bad results (the position before the space)
      // when querying a position directly after line-broken
      // whitespace. Detect this situation and and kludge around it
      if (gecko && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
        var rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);
        if (rectBefore.top == rect.top) {
          var rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
          if (rectAfter.top != rect.top) return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      var from = offset,
        to = offset,
        takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset == node.nodeValue.length) {
        from--;
        takeSide = 1;
      } else if (side < 0) {
        from--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);
    }
  }
  var $dom = view.state.doc.resolve(pos - (atom || 0));
  // Return a horizontal line in block context
  if (!$dom.parent.inlineContent) {
    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
      var before = node.childNodes[offset - 1];
      if (before.nodeType == 1) return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom == null && offset < nodeSize(node)) {
      var after = node.childNodes[offset];
      if (after.nodeType == 1) return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  // Inline, not in text node (this is not Bidi-safe)
  if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
    var _before = node.childNodes[offset - 1];
    var target = _before.nodeType == 3 ? textRange(_before, nodeSize(_before) - (supportEmptyRange ? 0 : 1))
    // BR nodes tend to only return the rectangle before them.
    // Only use them if they are the last element in their parent
    : _before.nodeType == 1 && (_before.nodeName != "BR" || !_before.nextSibling) ? _before : null;
    if (target) return flattenV(singleRect(target, 1), false);
  }
  if (atom == null && offset < nodeSize(node)) {
    var _after = node.childNodes[offset];
    while (_after.pmViewDesc && _after.pmViewDesc.ignoreForCoords) _after = _after.nextSibling;
    var _target = !_after ? null : _after.nodeType == 3 ? textRange(_after, 0, supportEmptyRange ? 0 : 1) : _after.nodeType == 1 ? _after : null;
    if (_target) return flattenV(singleRect(_target, -1), true);
  }
  // All else failed, just try to get a rectangle for the target node
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left) {
  if (rect.width == 0) return rect;
  var x = left ? rect.left : rect.right;
  return {
    top: rect.top,
    bottom: rect.bottom,
    left: x,
    right: x
  };
}
function flattenH(rect, top) {
  if (rect.height == 0) return rect;
  var y = top ? rect.top : rect.bottom;
  return {
    top: y,
    bottom: y,
    left: rect.left,
    right: rect.right
  };
}
function withFlushedState(view, state, f) {
  var viewState = view.state,
    active = view.root.activeElement;
  if (viewState != state) view.updateState(state);
  if (active != view.dom) view.focus();
  try {
    return f();
  } finally {
    if (viewState != state) view.updateState(viewState);
    if (active != view.dom && active) active.focus();
  }
}
// Whether vertical position motion in a given direction
// from a position would leave a text block.
function endOfTextblockVertical(view, state, dir) {
  var sel = state.selection;
  var $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, function () {
    var _view$docView$domFrom2 = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1),
      dom = _view$docView$domFrom2.node;
    for (;;) {
      var nearest = view.docView.nearestDesc(dom, true);
      if (!nearest) break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    var coords = _coordsAtPos(view, $pos.pos, 1);
    for (var child = dom.firstChild; child; child = child.nextSibling) {
      var boxes = void 0;
      if (child.nodeType == 1) boxes = child.getClientRects();else if (child.nodeType == 3) boxes = textRange(child, 0, child.nodeValue.length).getClientRects();else continue;
      for (var i = 0; i < boxes.length; i++) {
        var box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2)) return false;
      }
    }
    return true;
  });
}
var maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  var $head = state.selection.$head;
  if (!$head.parent.isTextblock) return false;
  var offset = $head.parentOffset,
    atStart = !offset,
    atEnd = offset == $head.parent.content.size;
  var sel = view.domSelection();
  // If the textblock is all LTR, or the browser doesn't support
  // Selection.modify (Edge), fall back to a primitive approach
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify) return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, function () {
    // This is a huge hack, but appears to be the best we can
    // currently do: use `Selection.modify` to move the selection by
    // one character, and see if that moves the cursor out of the
    // textblock (or doesn't move it at all, when at the start/end of
    // the document).
    var _view$domSelectionRan = view.domSelectionRange(),
      oldNode = _view$domSelectionRan.focusNode,
      oldOff = _view$domSelectionRan.focusOffset,
      anchorNode = _view$domSelectionRan.anchorNode,
      anchorOffset = _view$domSelectionRan.anchorOffset;
    var oldBidiLevel = sel.caretBidiLevel // Only for Firefox
    ;
    sel.modify("move", dir, "character");
    var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    var _view$domSelectionRan2 = view.domSelectionRange(),
      newNode = _view$domSelectionRan2.focusNode,
      newOff = _view$domSelectionRan2.focusOffset;
    var result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    // Restore the previous selection
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend) sel.extend(oldNode, oldOff);
    } catch (_) {}
    if (oldBidiLevel != null) sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
var cachedState = null;
var cachedDir = null;
var cachedResult = false;
function _endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir) return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}

// View descriptions are data structures that describe the DOM that is
// used to represent the editor's content. They are used for:
//
// - Incremental redrawing when the document changes
//
// - Figuring out what part of the document a given DOM position
//   corresponds to
//
// - Wiring in custom implementations of the editing interface for a
//   given node
//
// They form a doubly-linked mutable tree, starting at `view.docView`.
var NOT_DIRTY = 0,
  CHILD_DIRTY = 1,
  CONTENT_DIRTY = 2,
  NODE_DIRTY = 3;
// Superclass for the various kinds of descriptions. Defines their
// basic structure and shared methods.
var ViewDesc = /*#__PURE__*/function () {
  function ViewDesc(parent, children, dom,
  // This is the node that holds the child views. It may be null for
  // descs that don't have children.
  contentDOM) {
    _classCallCheck(this, ViewDesc);
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    // An expando property on the DOM node provides a link back to its
    // description.
    dom.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  _createClass(ViewDesc, [{
    key: "matchesWidget",
    value: function matchesWidget(widget) {
      return false;
    }
  }, {
    key: "matchesMark",
    value: function matchesMark(mark) {
      return false;
    }
  }, {
    key: "matchesNode",
    value: function matchesNode(node, outerDeco, innerDeco) {
      return false;
    }
  }, {
    key: "matchesHack",
    value: function matchesHack(nodeName) {
      return false;
    }
    // When parsing in-editor content (in domchange.js), we allow
    // descriptions to determine the parse rules that should be used to
    // parse them.
  }, {
    key: "parseRule",
    value: function parseRule() {
      return null;
    }
    // Used by the editor's event handler to ignore events that come
    // from certain descs.
  }, {
    key: "stopEvent",
    value: function stopEvent(event) {
      return false;
    }
    // The size of the content represented by this desc.
  }, {
    key: "size",
    get: function get() {
      var size = 0;
      for (var i = 0; i < this.children.length; i++) size += this.children[i].size;
      return size;
    }
    // For block nodes, this represents the space taken up by their
    // start/end tokens.
  }, {
    key: "border",
    get: function get() {
      return 0;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.parent = undefined;
      if (this.dom.pmViewDesc == this) this.dom.pmViewDesc = undefined;
      for (var i = 0; i < this.children.length; i++) this.children[i].destroy();
    }
  }, {
    key: "posBeforeChild",
    value: function posBeforeChild(child) {
      for (var i = 0, pos = this.posAtStart;; i++) {
        var cur = this.children[i];
        if (cur == child) return pos;
        pos += cur.size;
      }
    }
  }, {
    key: "posBefore",
    get: function get() {
      return this.parent.posBeforeChild(this);
    }
  }, {
    key: "posAtStart",
    get: function get() {
      return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
    }
  }, {
    key: "posAfter",
    get: function get() {
      return this.posBefore + this.size;
    }
  }, {
    key: "posAtEnd",
    get: function get() {
      return this.posAtStart + this.size - 2 * this.border;
    }
  }, {
    key: "localPosFromDOM",
    value: function localPosFromDOM(dom, offset, bias) {
      // If the DOM position is in the content, use the child desc after
      // it to figure out a position.
      if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
        if (bias < 0) {
          var domBefore, desc;
          if (dom == this.contentDOM) {
            domBefore = dom.childNodes[offset - 1];
          } else {
            while (dom.parentNode != this.contentDOM) dom = dom.parentNode;
            domBefore = dom.previousSibling;
          }
          while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) domBefore = domBefore.previousSibling;
          return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
        } else {
          var domAfter, _desc;
          if (dom == this.contentDOM) {
            domAfter = dom.childNodes[offset];
          } else {
            while (dom.parentNode != this.contentDOM) dom = dom.parentNode;
            domAfter = dom.nextSibling;
          }
          while (domAfter && !((_desc = domAfter.pmViewDesc) && _desc.parent == this)) domAfter = domAfter.nextSibling;
          return domAfter ? this.posBeforeChild(_desc) : this.posAtEnd;
        }
      }
      // Otherwise, use various heuristics, falling back on the bias
      // parameter, to determine whether to return the position at the
      // start or at the end of this view desc.
      var atEnd;
      if (dom == this.dom && this.contentDOM) {
        atEnd = offset > domIndex(this.contentDOM);
      } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
        atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
      } else if (this.dom.firstChild) {
        if (offset == 0) for (var search = dom;; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }
          if (search.previousSibling) break;
        }
        if (atEnd == null && offset == dom.childNodes.length) for (var _search = dom;; _search = _search.parentNode) {
          if (_search == this.dom) {
            atEnd = true;
            break;
          }
          if (_search.nextSibling) break;
        }
      }
      return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
    }
  }, {
    key: "nearestDesc",
    value: function nearestDesc(dom) {
      var onlyNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      for (var first = true, cur = dom; cur; cur = cur.parentNode) {
        var desc = this.getDesc(cur),
          nodeDOM = void 0;
        if (desc && (!onlyNodes || desc.node)) {
          // If dom is outside of this desc's nodeDOM, don't count it.
          if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom)) first = false;else return desc;
        }
      }
    }
  }, {
    key: "getDesc",
    value: function getDesc(dom) {
      var desc = dom.pmViewDesc;
      for (var cur = desc; cur; cur = cur.parent) if (cur == this) return desc;
    }
  }, {
    key: "posFromDOM",
    value: function posFromDOM(dom, offset, bias) {
      for (var scan = dom; scan; scan = scan.parentNode) {
        var desc = this.getDesc(scan);
        if (desc) return desc.localPosFromDOM(dom, offset, bias);
      }
      return -1;
    }
    // Find the desc for the node after the given pos, if any. (When a
    // parent node overrode rendering, there might not be one.)
  }, {
    key: "descAt",
    value: function descAt(pos) {
      for (var i = 0, offset = 0; i < this.children.length; i++) {
        var child = this.children[i],
          end = offset + child.size;
        if (offset == pos && end != offset) {
          while (!child.border && child.children.length) child = child.children[0];
          return child;
        }
        if (pos < end) return child.descAt(pos - offset - child.border);
        offset = end;
      }
    }
  }, {
    key: "domFromPos",
    value: function domFromPos(pos, side) {
      if (!this.contentDOM) return {
        node: this.dom,
        offset: 0,
        atom: pos + 1
      };
      // First find the position in the child array
      var i = 0,
        offset = 0;
      for (var curPos = 0; i < this.children.length; i++) {
        var child = this.children[i],
          end = curPos + child.size;
        if (end > pos || child instanceof TrailingHackViewDesc) {
          offset = pos - curPos;
          break;
        }
        curPos = end;
      }
      // If this points into the middle of a child, call through
      if (offset) return this.children[i].domFromPos(offset - this.children[i].border, side);
      // Go back if there were any zero-length widgets with side >= 0 before this point
      for (var prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {}
      // Scan towards the first useable node
      if (side <= 0) {
        var _prev,
          enter = true;
        for (;; i--, enter = false) {
          _prev = i ? this.children[i - 1] : null;
          if (!_prev || _prev.dom.parentNode == this.contentDOM) break;
        }
        if (_prev && side && enter && !_prev.border && !_prev.domAtom) return _prev.domFromPos(_prev.size, side);
        return {
          node: this.contentDOM,
          offset: _prev ? domIndex(_prev.dom) + 1 : 0
        };
      } else {
        var next,
          _enter = true;
        for (;; i++, _enter = false) {
          next = i < this.children.length ? this.children[i] : null;
          if (!next || next.dom.parentNode == this.contentDOM) break;
        }
        if (next && _enter && !next.border && !next.domAtom) return next.domFromPos(0, side);
        return {
          node: this.contentDOM,
          offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length
        };
      }
    }
    // Used to find a DOM range in a single parent for a given changed
    // range.
  }, {
    key: "parseRange",
    value: function parseRange(from, to) {
      var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      if (this.children.length == 0) return {
        node: this.contentDOM,
        from: from,
        to: to,
        fromOffset: 0,
        toOffset: this.contentDOM.childNodes.length
      };
      var fromOffset = -1,
        toOffset = -1;
      for (var offset = base, i = 0;; i++) {
        var child = this.children[i],
          end = offset + child.size;
        if (fromOffset == -1 && from <= end) {
          var childBase = offset + child.border;
          // FIXME maybe descend mark views to parse a narrower range?
          if (from >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM)) return child.parseRange(from, to, childBase);
          from = offset;
          for (var j = i; j > 0; j--) {
            var prev = this.children[j - 1];
            if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
              fromOffset = domIndex(prev.dom) + 1;
              break;
            }
            from -= prev.size;
          }
          if (fromOffset == -1) fromOffset = 0;
        }
        if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {
          to = end;
          for (var _j = i + 1; _j < this.children.length; _j++) {
            var next = this.children[_j];
            if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
              toOffset = domIndex(next.dom);
              break;
            }
            to += next.size;
          }
          if (toOffset == -1) toOffset = this.contentDOM.childNodes.length;
          break;
        }
        offset = end;
      }
      return {
        node: this.contentDOM,
        from: from,
        to: to,
        fromOffset: fromOffset,
        toOffset: toOffset
      };
    }
  }, {
    key: "emptyChildAt",
    value: function emptyChildAt(side) {
      if (this.border || !this.contentDOM || !this.children.length) return false;
      var child = this.children[side < 0 ? 0 : this.children.length - 1];
      return child.size == 0 || child.emptyChildAt(side);
    }
  }, {
    key: "domAfterPos",
    value: function domAfterPos(pos) {
      var _this$domFromPos = this.domFromPos(pos, 0),
        node = _this$domFromPos.node,
        offset = _this$domFromPos.offset;
      if (node.nodeType != 1 || offset == node.childNodes.length) throw new RangeError("No node after pos " + pos);
      return node.childNodes[offset];
    }
    // View descs are responsible for setting any selection that falls
    // entirely inside of them, so that custom implementations can do
    // custom things with the selection. Note that this falls apart when
    // a selection starts in such a node and ends in another, in which
    // case we just use whatever domFromPos produces as a best effort.
  }, {
    key: "setSelection",
    value: function setSelection(anchor, head, root) {
      var force = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      // If the selection falls entirely in a child, give it to that child
      var from = Math.min(anchor, head),
        to = Math.max(anchor, head);
      for (var i = 0, offset = 0; i < this.children.length; i++) {
        var child = this.children[i],
          end = offset + child.size;
        if (from > offset && to < end) return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force);
        offset = end;
      }
      var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
      var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
      var domSel = root.getSelection();
      var brKludge = false;
      // On Firefox, using Selection.collapse to put the cursor after a
      // BR node for some reason doesn't always work (#1073). On Safari,
      // the cursor sometimes inexplicable visually lags behind its
      // reported position in such situations (#1092).
      if ((gecko || safari) && anchor == head) {
        var _anchorDOM = anchorDOM,
          node = _anchorDOM.node,
          _offset = _anchorDOM.offset;
        if (node.nodeType == 3) {
          brKludge = !!(_offset && node.nodeValue[_offset - 1] == "\n");
          // Issue #1128
          if (brKludge && _offset == node.nodeValue.length) {
            for (var scan = node, after; scan; scan = scan.parentNode) {
              if (after = scan.nextSibling) {
                if (after.nodeName == "BR") anchorDOM = headDOM = {
                  node: after.parentNode,
                  offset: domIndex(after) + 1
                };
                break;
              }
              var desc = scan.pmViewDesc;
              if (desc && desc.node && desc.node.isBlock) break;
            }
          }
        } else {
          var prev = node.childNodes[_offset - 1];
          brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
        }
      }
      // Firefox can act strangely when the selection is in front of an
      // uneditable node. See #1163 and https://bugzilla.mozilla.org/show_bug.cgi?id=1709536
      if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
        var _after2 = domSel.focusNode.childNodes[domSel.focusOffset];
        if (_after2 && _after2.contentEditable == "false") force = true;
      }
      if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) return;
      // Selection.extend can be used to create an 'inverted' selection
      // (one where the focus is before the anchor), but not all
      // browsers support it yet.
      var domSelExtended = false;
      if ((domSel.extend || anchor == head) && !brKludge) {
        domSel.collapse(anchorDOM.node, anchorDOM.offset);
        try {
          if (anchor != head) domSel.extend(headDOM.node, headDOM.offset);
          domSelExtended = true;
        } catch (_) {
          // In some cases with Chrome the selection is empty after calling
          // collapse, even when it should be valid. This appears to be a bug, but
          // it is difficult to isolate. If this happens fallback to the old path
          // without using extend.
          // Similarly, this could crash on Safari if the editor is hidden, and
          // there was no selection.
        }
      }
      if (!domSelExtended) {
        if (anchor > head) {
          var tmp = anchorDOM;
          anchorDOM = headDOM;
          headDOM = tmp;
        }
        var range = document.createRange();
        range.setEnd(headDOM.node, headDOM.offset);
        range.setStart(anchorDOM.node, anchorDOM.offset);
        domSel.removeAllRanges();
        domSel.addRange(range);
      }
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      return !this.contentDOM && mutation.type != "selection";
    }
  }, {
    key: "contentLost",
    get: function get() {
      return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
    }
    // Remove a subtree of the element tree that has been touched
    // by a DOM change, so that the next update will redraw it.
  }, {
    key: "markDirty",
    value: function markDirty(from, to) {
      for (var offset = 0, i = 0; i < this.children.length; i++) {
        var child = this.children[i],
          end = offset + child.size;
        if (offset == end ? from <= end && to >= offset : from < end && to > offset) {
          var startInside = offset + child.border,
            endInside = end - child.border;
          if (from >= startInside && to <= endInside) {
            this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
            if (from == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM)) child.dirty = NODE_DIRTY;else child.markDirty(from - startInside, to - startInside);
            return;
          } else {
            child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
          }
        }
        offset = end;
      }
      this.dirty = CONTENT_DIRTY;
    }
  }, {
    key: "markParentsDirty",
    value: function markParentsDirty() {
      var level = 1;
      for (var node = this.parent; node; node = node.parent, level++) {
        var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
        if (node.dirty < dirty) node.dirty = dirty;
      }
    }
  }, {
    key: "domAtom",
    get: function get() {
      return false;
    }
  }, {
    key: "ignoreForCoords",
    get: function get() {
      return false;
    }
  }]);
  return ViewDesc;
}(); // A widget desc represents a widget decoration, which is a DOM node
// drawn between the document nodes.
var WidgetViewDesc = /*#__PURE__*/function (_ViewDesc) {
  _inherits(WidgetViewDesc, _ViewDesc);
  function WidgetViewDesc(parent, widget, view, pos) {
    var _this;
    _classCallCheck(this, WidgetViewDesc);
    var self,
      dom = widget.type.toDOM;
    if (typeof dom == "function") dom = dom(view, function () {
      if (!self) return pos;
      if (self.parent) return self.parent.posBeforeChild(self);
    });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        var wrap = document.createElement("span");
        wrap.appendChild(dom);
        dom = wrap;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    _this = _callSuper(this, WidgetViewDesc, [parent, [], dom, null]);
    _this.widget = widget;
    _this.widget = widget;
    self = _assertThisInitialized(_this);
    return _this;
  }
  _createClass(WidgetViewDesc, [{
    key: "matchesWidget",
    value: function matchesWidget(widget) {
      return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
    }
  }, {
    key: "parseRule",
    value: function parseRule() {
      return {
        ignore: true
      };
    }
  }, {
    key: "stopEvent",
    value: function stopEvent(event) {
      var stop = this.widget.spec.stopEvent;
      return stop ? stop(event) : false;
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      return mutation.type != "selection" || this.widget.spec.ignoreSelection;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.widget.type.destroy(this.dom);
      _get(_getPrototypeOf(WidgetViewDesc.prototype), "destroy", this).call(this);
    }
  }, {
    key: "domAtom",
    get: function get() {
      return true;
    }
  }, {
    key: "side",
    get: function get() {
      return this.widget.type.side;
    }
  }]);
  return WidgetViewDesc;
}(ViewDesc);
var CompositionViewDesc = /*#__PURE__*/function (_ViewDesc2) {
  _inherits(CompositionViewDesc, _ViewDesc2);
  function CompositionViewDesc(parent, dom, textDOM, text) {
    var _this2;
    _classCallCheck(this, CompositionViewDesc);
    _this2 = _callSuper(this, CompositionViewDesc, [parent, [], dom, null]);
    _this2.textDOM = textDOM;
    _this2.text = text;
    return _this2;
  }
  _createClass(CompositionViewDesc, [{
    key: "size",
    get: function get() {
      return this.text.length;
    }
  }, {
    key: "localPosFromDOM",
    value: function localPosFromDOM(dom, offset) {
      if (dom != this.textDOM) return this.posAtStart + (offset ? this.size : 0);
      return this.posAtStart + offset;
    }
  }, {
    key: "domFromPos",
    value: function domFromPos(pos) {
      return {
        node: this.textDOM,
        offset: pos
      };
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mut) {
      return mut.type === 'characterData' && mut.target.nodeValue == mut.oldValue;
    }
  }]);
  return CompositionViewDesc;
}(ViewDesc); // A mark desc represents a mark. May have multiple children,
// depending on how the mark is split. Note that marks are drawn using
// a fixed nesting order, for simplicity and predictability, so in
// some cases they will be split more often than would appear
// necessary.
var MarkViewDesc = /*#__PURE__*/function (_ViewDesc3) {
  _inherits(MarkViewDesc, _ViewDesc3);
  function MarkViewDesc(parent, mark, dom, contentDOM) {
    var _this3;
    _classCallCheck(this, MarkViewDesc);
    _this3 = _callSuper(this, MarkViewDesc, [parent, [], dom, contentDOM]);
    _this3.mark = mark;
    return _this3;
  }
  _createClass(MarkViewDesc, [{
    key: "parseRule",
    value: function parseRule() {
      if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView) return null;
      return {
        mark: this.mark.type.name,
        attrs: this.mark.attrs,
        contentElement: this.contentDOM
      };
    }
  }, {
    key: "matchesMark",
    value: function matchesMark(mark) {
      return this.dirty != NODE_DIRTY && this.mark.eq(mark);
    }
  }, {
    key: "markDirty",
    value: function markDirty(from, to) {
      _get(_getPrototypeOf(MarkViewDesc.prototype), "markDirty", this).call(this, from, to);
      // Move dirty info to nearest node view
      if (this.dirty != NOT_DIRTY) {
        var parent = this.parent;
        while (!parent.node) parent = parent.parent;
        if (parent.dirty < this.dirty) parent.dirty = this.dirty;
        this.dirty = NOT_DIRTY;
      }
    }
  }, {
    key: "slice",
    value: function slice(from, to, view) {
      var copy = MarkViewDesc.create(this.parent, this.mark, true, view);
      var nodes = this.children,
        size = this.size;
      if (to < size) nodes = replaceNodes(nodes, to, size, view);
      if (from > 0) nodes = replaceNodes(nodes, 0, from, view);
      for (var i = 0; i < nodes.length; i++) nodes[i].parent = copy;
      copy.children = nodes;
      return copy;
    }
  }], [{
    key: "create",
    value: function create(parent, mark, inline, view) {
      var custom = view.nodeViews[mark.type.name];
      var spec = custom && custom(mark, view, inline);
      if (!spec || !spec.dom) spec = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));
      return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);
    }
  }]);
  return MarkViewDesc;
}(ViewDesc); // Node view descs are the main, most common type of view desc, and
// correspond to an actual node in the document. Unlike mark descs,
// they populate their child array themselves.
var NodeViewDesc = /*#__PURE__*/function (_ViewDesc4) {
  _inherits(NodeViewDesc, _ViewDesc4);
  function NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    var _this4;
    _classCallCheck(this, NodeViewDesc);
    _this4 = _callSuper(this, NodeViewDesc, [parent, [], dom, contentDOM]);
    _this4.node = node;
    _this4.outerDeco = outerDeco;
    _this4.innerDeco = innerDeco;
    _this4.nodeDOM = nodeDOM;
    return _this4;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  _createClass(NodeViewDesc, [{
    key: "parseRule",
    value: function parseRule() {
      var _this5 = this;
      // Experimental kludge to allow opt-in re-parsing of nodes
      if (this.node.type.spec.reparseInView) return null;
      // FIXME the assumption that this can always return the current
      // attrs means that if the user somehow manages to change the
      // attrs in the dom, that won't be picked up. Not entirely sure
      // whether this is a problem
      var rule = {
        node: this.node.type.name,
        attrs: this.node.attrs
      };
      if (this.node.type.whitespace == "pre") rule.preserveWhitespace = "full";
      if (!this.contentDOM) {
        rule.getContent = function () {
          return _this5.node.content;
        };
      } else if (!this.contentLost) {
        rule.contentElement = this.contentDOM;
      } else {
        // Chrome likes to randomly recreate parent nodes when
        // backspacing things. When that happens, this tries to find the
        // new parent.
        for (var i = this.children.length - 1; i >= 0; i--) {
          var child = this.children[i];
          if (this.dom.contains(child.dom.parentNode)) {
            rule.contentElement = child.dom.parentNode;
            break;
          }
        }
        if (!rule.contentElement) rule.getContent = function () {
          return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;
        };
      }
      return rule;
    }
  }, {
    key: "matchesNode",
    value: function matchesNode(node, outerDeco, innerDeco) {
      return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
    }
  }, {
    key: "size",
    get: function get() {
      return this.node.nodeSize;
    }
  }, {
    key: "border",
    get: function get() {
      return this.node.isLeaf ? 0 : 1;
    }
    // Syncs `this.children` to match `this.node.content` and the local
    // decorations, possibly introducing nesting for marks. Then, in a
    // separate step, syncs the DOM inside `this.contentDOM` to
    // `this.children`.
  }, {
    key: "updateChildren",
    value: function updateChildren(view, pos) {
      var _this6 = this;
      var inline = this.node.inlineContent,
        off = pos;
      var composition = view.composing ? this.localCompositionInfo(view, pos) : null;
      var localComposition = composition && composition.pos > -1 ? composition : null;
      var compositionInChild = composition && composition.pos < 0;
      var updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
      iterDeco(this.node, this.innerDeco, function (widget, i, insideNode) {
        if (widget.spec.marks) updater.syncToMarks(widget.spec.marks, inline, view);else if (widget.type.side >= 0 && !insideNode) updater.syncToMarks(i == _this6.node.childCount ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none : _this6.node.child(i).marks, inline, view);
        // If the next node is a desc matching this widget, reuse it,
        // otherwise insert the widget as a new view desc.
        updater.placeWidget(widget, view, off);
      }, function (child, outerDeco, innerDeco, i) {
        // Make sure the wrapping mark descs match the node's marks.
        updater.syncToMarks(child.marks, inline, view);
        // Try several strategies for drawing this node
        var compIndex;
        if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;else {
          // Add it as a new view
          updater.addNode(child, outerDeco, innerDeco, view, off);
        }
        off += child.nodeSize;
      });
      // Drop all remaining descs after the current position.
      updater.syncToMarks([], inline, view);
      if (this.node.isTextblock) updater.addTextblockHacks();
      updater.destroyRest();
      // Sync the DOM if anything changed
      if (updater.changed || this.dirty == CONTENT_DIRTY) {
        // May have to protect focused DOM from being changed if a composition is active
        if (localComposition) this.protectLocalComposition(view, localComposition);
        renderDescs(this.contentDOM, this.children, view);
        if (ios) iosHacks(this.dom);
      }
    }
  }, {
    key: "localCompositionInfo",
    value: function localCompositionInfo(view, pos) {
      // Only do something if both the selection and a focused text node
      // are inside of this node
      var _view$state$selection = view.state.selection,
        from = _view$state$selection.from,
        to = _view$state$selection.to;
      if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || from < pos || to > pos + this.node.content.size) return null;
      var sel = view.domSelectionRange();
      var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
      if (!textNode || !this.dom.contains(textNode.parentNode)) return null;
      if (this.node.inlineContent) {
        // Find the text in the focused node in the node, stop if it's not
        // there (may have been modified through other means, in which
        // case it should overwritten)
        var text = textNode.nodeValue;
        var textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);
        return textPos < 0 ? null : {
          node: textNode,
          pos: textPos,
          text: text
        };
      } else {
        return {
          node: textNode,
          pos: -1,
          text: ""
        };
      }
    }
  }, {
    key: "protectLocalComposition",
    value: function protectLocalComposition(view, _ref2) {
      var node = _ref2.node,
        pos = _ref2.pos,
        text = _ref2.text;
      // The node is already part of a local view desc, leave it there
      if (this.getDesc(node)) return;
      // Create a composition view for the orphaned nodes
      var topNode = node;
      for (;; topNode = topNode.parentNode) {
        if (topNode.parentNode == this.contentDOM) break;
        while (topNode.previousSibling) topNode.parentNode.removeChild(topNode.previousSibling);
        while (topNode.nextSibling) topNode.parentNode.removeChild(topNode.nextSibling);
        if (topNode.pmViewDesc) topNode.pmViewDesc = undefined;
      }
      var desc = new CompositionViewDesc(this, topNode, node, text);
      view.input.compositionNodes.push(desc);
      // Patch up this.children to contain the composition view
      this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
    }
    // If this desc must be updated to match the given node decoration,
    // do so and return true.
  }, {
    key: "update",
    value: function update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node)) return false;
      this.updateInner(node, outerDeco, innerDeco, view);
      return true;
    }
  }, {
    key: "updateInner",
    value: function updateInner(node, outerDeco, innerDeco, view) {
      this.updateOuterDeco(outerDeco);
      this.node = node;
      this.innerDeco = innerDeco;
      if (this.contentDOM) this.updateChildren(view, this.posAtStart);
      this.dirty = NOT_DIRTY;
    }
  }, {
    key: "updateOuterDeco",
    value: function updateOuterDeco(outerDeco) {
      if (sameOuterDeco(outerDeco, this.outerDeco)) return;
      var needsWrap = this.nodeDOM.nodeType != 1;
      var oldDOM = this.dom;
      this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
      if (this.dom != oldDOM) {
        oldDOM.pmViewDesc = undefined;
        this.dom.pmViewDesc = this;
      }
      this.outerDeco = outerDeco;
    }
    // Mark this node as being the selected node.
  }, {
    key: "selectNode",
    value: function selectNode() {
      if (this.nodeDOM.nodeType == 1) this.nodeDOM.classList.add("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable) this.dom.draggable = true;
    }
    // Remove selected node marking from this node.
  }, {
    key: "deselectNode",
    value: function deselectNode() {
      if (this.nodeDOM.nodeType == 1) this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable) this.dom.removeAttribute("draggable");
    }
  }, {
    key: "domAtom",
    get: function get() {
      return this.node.isAtom;
    }
  }], [{
    key: "create",
    value: function create(parent, node, outerDeco, innerDeco, view, pos) {
      var custom = view.nodeViews[node.type.name],
        descObj;
      var spec = custom && custom(node, view, function () {
        // (This is a function that allows the custom view to find its
        // own position)
        if (!descObj) return pos;
        if (descObj.parent) return descObj.parent.posBeforeChild(descObj);
      }, outerDeco, innerDeco);
      var dom = spec && spec.dom,
        contentDOM = spec && spec.contentDOM;
      if (node.isText) {
        if (!dom) dom = document.createTextNode(node.text);else if (dom.nodeType != 3) throw new RangeError("Text must be rendered as a DOM text node");
      } else if (!dom) {
        var _DOMSerializer$render = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node));
        dom = _DOMSerializer$render.dom;
        contentDOM = _DOMSerializer$render.contentDOM;
      }
      if (!contentDOM && !node.isText && dom.nodeName != "BR") {
        // Chrome gets confused by <br contenteditable=false>
        if (!dom.hasAttribute("contenteditable")) dom.contentEditable = "false";
        if (node.type.spec.draggable) dom.draggable = true;
      }
      var nodeDOM = dom;
      dom = applyOuterDeco(dom, outerDeco, node);
      if (spec) return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);else if (node.isText) return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);else return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
    }
  }]);
  return NodeViewDesc;
}(ViewDesc); // Create a view desc for the top-level document node, to be exported
// and used by the view class.
function docViewDesc(doc, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc);
  var docView = new NodeViewDesc(undefined, doc, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM) docView.updateChildren(view, 0);
  return docView;
}
var TextViewDesc = /*#__PURE__*/function (_NodeViewDesc) {
  _inherits(TextViewDesc, _NodeViewDesc);
  function TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    _classCallCheck(this, TextViewDesc);
    return _callSuper(this, TextViewDesc, [parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0]);
  }
  _createClass(TextViewDesc, [{
    key: "parseRule",
    value: function parseRule() {
      var skip = this.nodeDOM.parentNode;
      while (skip && skip != this.dom && !skip.pmIsDeco) skip = skip.parentNode;
      return {
        skip: skip || true
      };
    }
  }, {
    key: "update",
    value: function update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node)) return false;
      this.updateOuterDeco(outerDeco);
      if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
        this.nodeDOM.nodeValue = node.text;
        if (view.trackWrites == this.nodeDOM) view.trackWrites = null;
      }
      this.node = node;
      this.dirty = NOT_DIRTY;
      return true;
    }
  }, {
    key: "inParent",
    value: function inParent() {
      var parentDOM = this.parent.contentDOM;
      for (var n = this.nodeDOM; n; n = n.parentNode) if (n == parentDOM) return true;
      return false;
    }
  }, {
    key: "domFromPos",
    value: function domFromPos(pos) {
      return {
        node: this.nodeDOM,
        offset: pos
      };
    }
  }, {
    key: "localPosFromDOM",
    value: function localPosFromDOM(dom, offset, bias) {
      if (dom == this.nodeDOM) return this.posAtStart + Math.min(offset, this.node.text.length);
      return _get(_getPrototypeOf(TextViewDesc.prototype), "localPosFromDOM", this).call(this, dom, offset, bias);
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      return mutation.type != "characterData" && mutation.type != "selection";
    }
  }, {
    key: "slice",
    value: function slice(from, to, view) {
      var node = this.node.cut(from, to),
        dom = document.createTextNode(node.text);
      return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
    }
  }, {
    key: "markDirty",
    value: function markDirty(from, to) {
      _get(_getPrototypeOf(TextViewDesc.prototype), "markDirty", this).call(this, from, to);
      if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length)) this.dirty = NODE_DIRTY;
    }
  }, {
    key: "domAtom",
    get: function get() {
      return false;
    }
  }]);
  return TextViewDesc;
}(NodeViewDesc); // A dummy desc used to tag trailing BR or IMG nodes created to work
// around contentEditable terribleness.
var TrailingHackViewDesc = /*#__PURE__*/function (_ViewDesc5) {
  _inherits(TrailingHackViewDesc, _ViewDesc5);
  function TrailingHackViewDesc() {
    _classCallCheck(this, TrailingHackViewDesc);
    return _callSuper(this, TrailingHackViewDesc, arguments);
  }
  _createClass(TrailingHackViewDesc, [{
    key: "parseRule",
    value: function parseRule() {
      return {
        ignore: true
      };
    }
  }, {
    key: "matchesHack",
    value: function matchesHack(nodeName) {
      return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
    }
  }, {
    key: "domAtom",
    get: function get() {
      return true;
    }
  }, {
    key: "ignoreForCoords",
    get: function get() {
      return this.dom.nodeName == "IMG";
    }
  }]);
  return TrailingHackViewDesc;
}(ViewDesc); // A separate subclass is used for customized node views, so that the
// extra checks only have to be made for nodes that are actually
// customized.
var CustomNodeViewDesc = /*#__PURE__*/function (_NodeViewDesc2) {
  _inherits(CustomNodeViewDesc, _NodeViewDesc2);
  function CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    var _this7;
    _classCallCheck(this, CustomNodeViewDesc);
    _this7 = _callSuper(this, CustomNodeViewDesc, [parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos]);
    _this7.spec = spec;
    return _this7;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  _createClass(CustomNodeViewDesc, [{
    key: "update",
    value: function update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY) return false;
      if (this.spec.update) {
        var result = this.spec.update(node, outerDeco, innerDeco);
        if (result) this.updateInner(node, outerDeco, innerDeco, view);
        return result;
      } else if (!this.contentDOM && !node.isLeaf) {
        return false;
      } else {
        return _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "update", this).call(this, node, outerDeco, innerDeco, view);
      }
    }
  }, {
    key: "selectNode",
    value: function selectNode() {
      this.spec.selectNode ? this.spec.selectNode() : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "selectNode", this).call(this);
    }
  }, {
    key: "deselectNode",
    value: function deselectNode() {
      this.spec.deselectNode ? this.spec.deselectNode() : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "deselectNode", this).call(this);
    }
  }, {
    key: "setSelection",
    value: function setSelection(anchor, head, root, force) {
      this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "setSelection", this).call(this, anchor, head, root, force);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.spec.destroy) this.spec.destroy();
      _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "destroy", this).call(this);
    }
  }, {
    key: "stopEvent",
    value: function stopEvent(event) {
      return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "ignoreMutation", this).call(this, mutation);
    }
  }]);
  return CustomNodeViewDesc;
}(NodeViewDesc); // Sync the content of the given DOM node with the nodes associated
// with the given array of view descs, recursing into mark descs
// because this should sync the subtree for a whole node at a time.
function renderDescs(parentDOM, descs, view) {
  var dom = parentDOM.firstChild,
    written = false;
  for (var i = 0; i < descs.length; i++) {
    var desc = descs[i],
      childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      var pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM) view.trackWrites = null;
}
var OuterDecoLevel = function OuterDecoLevel(nodeName) {
  if (nodeName) this.nodeName = nodeName;
};
OuterDecoLevel.prototype = Object.create(null);
var noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0) return noDeco;
  var top = needsWrap ? noDeco[0] : new OuterDecoLevel(),
    result = [top];
  for (var i = 0; i < outerDeco.length; i++) {
    var attrs = outerDeco[i].type.attrs;
    if (!attrs) continue;
    if (attrs.nodeName) result.push(top = new OuterDecoLevel(attrs.nodeName));
    for (var name in attrs) {
      var val = attrs[name];
      if (val == null) continue;
      if (needsWrap && result.length == 1) result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class") top["class"] = (top["class"] ? top["class"] + " " : "") + val;else if (name == "style") top.style = (top.style ? top.style + ";" : "") + val;else if (name != "nodeName") top[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  // Shortcut for trivial case
  if (prevComputed == noDeco && curComputed == noDeco) return nodeDOM;
  var curDOM = nodeDOM;
  for (var i = 0; i < curComputed.length; i++) {
    var deco = curComputed[i],
      prev = prevComputed[i];
    if (i) {
      var parent = void 0;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (var name in prev) if (name != "class" && name != "style" && name != "nodeName" && !(name in cur)) dom.removeAttribute(name);
  for (var _name in cur) if (_name != "class" && _name != "style" && _name != "nodeName" && cur[_name] != prev[_name]) dom.setAttribute(_name, cur[_name]);
  if (prev["class"] != cur["class"]) {
    var prevList = prev["class"] ? prev["class"].split(" ").filter(Boolean) : [];
    var curList = cur["class"] ? cur["class"].split(" ").filter(Boolean) : [];
    for (var i = 0; i < prevList.length; i++) if (curList.indexOf(prevList[i]) == -1) dom.classList.remove(prevList[i]);
    for (var _i = 0; _i < curList.length; _i++) if (prevList.indexOf(curList[_i]) == -1) dom.classList.add(curList[_i]);
    if (dom.classList.length == 0) dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g,
        m;
      while (m = prop.exec(prev.style)) dom.style.removeProperty(m[1]);
    }
    if (cur.style) dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length) return false;
  for (var i = 0; i < a.length; i++) if (!a[i].type.eq(b[i].type)) return false;
  return true;
}
// Remove a DOM node and return its next sibling.
function rm(dom) {
  var next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
// Helper class for incrementally updating a tree of mark descs and
// the widget and node descs inside of them.
var ViewTreeUpdater = /*#__PURE__*/function () {
  function ViewTreeUpdater(top, lock, view) {
    _classCallCheck(this, ViewTreeUpdater);
    this.lock = lock;
    this.view = view;
    // Index into `this.top`'s child array, represents the current
    // update position.
    this.index = 0;
    // When entering a mark, the current top and index are pushed
    // onto this.
    this.stack = [];
    // Tracks whether anything was changed
    this.changed = false;
    this.top = top;
    this.preMatch = preMatch(top.node.content, top);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  _createClass(ViewTreeUpdater, [{
    key: "destroyBetween",
    value: function destroyBetween(start, end) {
      if (start == end) return;
      for (var i = start; i < end; i++) this.top.children[i].destroy();
      this.top.children.splice(start, end - start);
      this.changed = true;
    }
    // Destroy all remaining children in `this.top`.
  }, {
    key: "destroyRest",
    value: function destroyRest() {
      this.destroyBetween(this.index, this.top.children.length);
    }
    // Sync the current stack of mark descs with the given array of
    // marks, reusing existing mark descs when possible.
  }, {
    key: "syncToMarks",
    value: function syncToMarks(marks, inline, view) {
      var keep = 0,
        depth = this.stack.length >> 1;
      var maxKeep = Math.min(depth, marks.length);
      while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false) keep++;
      while (keep < depth) {
        this.destroyRest();
        this.top.dirty = NOT_DIRTY;
        this.index = this.stack.pop();
        this.top = this.stack.pop();
        depth--;
      }
      while (depth < marks.length) {
        this.stack.push(this.top, this.index + 1);
        var found = -1;
        for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
          var next = this.top.children[i];
          if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
            found = i;
            break;
          }
        }
        if (found > -1) {
          if (found > this.index) {
            this.changed = true;
            this.destroyBetween(this.index, found);
          }
          this.top = this.top.children[this.index];
        } else {
          var markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
          this.top.children.splice(this.index, 0, markDesc);
          this.top = markDesc;
          this.changed = true;
        }
        this.index = 0;
        depth++;
      }
    }
    // Try to find a node desc matching the given data. Skip over it and
    // return true when successful.
  }, {
    key: "findNodeMatch",
    value: function findNodeMatch(node, outerDeco, innerDeco, index) {
      var found = -1,
        targetDesc;
      if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
        found = this.top.children.indexOf(targetDesc, this.index);
      } else {
        for (var i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
          var child = this.top.children[i];
          if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
            found = i;
            break;
          }
        }
      }
      if (found < 0) return false;
      this.destroyBetween(this.index, found);
      this.index++;
      return true;
    }
  }, {
    key: "updateNodeAt",
    value: function updateNodeAt(node, outerDeco, innerDeco, index, view) {
      var child = this.top.children[index];
      if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM) child.dirty = CONTENT_DIRTY;
      if (!child.update(node, outerDeco, innerDeco, view)) return false;
      this.destroyBetween(this.index, index);
      this.index++;
      return true;
    }
  }, {
    key: "findIndexWithChild",
    value: function findIndexWithChild(domNode) {
      for (;;) {
        var parent = domNode.parentNode;
        if (!parent) return -1;
        if (parent == this.top.contentDOM) {
          var desc = domNode.pmViewDesc;
          if (desc) for (var i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc) return i;
          }
          return -1;
        }
        domNode = parent;
      }
    }
    // Try to update the next node, if any, to the given data. Checks
    // pre-matches to avoid overwriting nodes that could still be used.
  }, {
    key: "updateNextNode",
    value: function updateNextNode(node, outerDeco, innerDeco, view, index, pos) {
      for (var i = this.index; i < this.top.children.length; i++) {
        var next = this.top.children[i];
        if (next instanceof NodeViewDesc) {
          var _preMatch = this.preMatch.matched.get(next);
          if (_preMatch != null && _preMatch != index) return false;
          var nextDOM = next.dom,
            updated = void 0;
          // Can't update if nextDOM is or contains this.lock, except if
          // it's a text node whose content already matches the new text
          // and whose decorations match the new ones.
          var locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
          if (!locked && next.update(node, outerDeco, innerDeco, view)) {
            this.destroyBetween(this.index, i);
            if (next.dom != nextDOM) this.changed = true;
            this.index++;
            return true;
          } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
            this.top.children[this.index] = updated;
            if (updated.contentDOM) {
              updated.dirty = CONTENT_DIRTY;
              updated.updateChildren(view, pos + 1);
              updated.dirty = NOT_DIRTY;
            }
            this.changed = true;
            this.index++;
            return true;
          }
          break;
        }
      }
      return false;
    }
    // When a node with content is replaced by a different node with
    // identical content, move over its children.
  }, {
    key: "recreateWrapper",
    value: function recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
      if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content)) return null;
      var wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
      if (wrapper.contentDOM) {
        wrapper.children = next.children;
        next.children = [];
        var _iterator = _createForOfIteratorHelper(wrapper.children),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var ch = _step.value;
            ch.parent = wrapper;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      next.destroy();
      return wrapper;
    }
    // Insert the node as a newly created node desc.
  }, {
    key: "addNode",
    value: function addNode(node, outerDeco, innerDeco, view, pos) {
      var desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
      if (desc.contentDOM) desc.updateChildren(view, pos + 1);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }, {
    key: "placeWidget",
    value: function placeWidget(widget, view, pos) {
      var next = this.index < this.top.children.length ? this.top.children[this.index] : null;
      if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
        this.index++;
      } else {
        var desc = new WidgetViewDesc(this.top, widget, view, pos);
        this.top.children.splice(this.index++, 0, desc);
        this.changed = true;
      }
    }
    // Make sure a textblock looks and behaves correctly in
    // contentEditable.
  }, {
    key: "addTextblockHacks",
    value: function addTextblockHacks() {
      var lastChild = this.top.children[this.index - 1],
        parent = this.top;
      while (lastChild instanceof MarkViewDesc) {
        parent = lastChild;
        lastChild = parent.children[parent.children.length - 1];
      }
      if (!lastChild ||
      // Empty textblock
      !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
        // Avoid bugs in Safari's cursor drawing (#1165) and Chrome's mouse selection (#1152)
        if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false") this.addHackNode("IMG", parent);
        this.addHackNode("BR", this.top);
      }
    }
  }, {
    key: "addHackNode",
    value: function addHackNode(nodeName, parent) {
      if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
        this.index++;
      } else {
        var dom = document.createElement(nodeName);
        if (nodeName == "IMG") {
          dom.className = "ProseMirror-separator";
          dom.alt = "";
        }
        if (nodeName == "BR") dom.className = "ProseMirror-trailingBreak";
        var hack = new TrailingHackViewDesc(this.top, [], dom, null);
        if (parent != this.top) parent.children.push(hack);else parent.children.splice(this.index++, 0, hack);
        this.changed = true;
      }
    }
  }, {
    key: "isLocked",
    value: function isLocked(node) {
      return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
    }
  }]);
  return ViewTreeUpdater;
}(); // Iterate from the end of the fragment and array of descs to find
// directly matching ones, in order to avoid overeagerly reusing those
// for other nodes. Returns the fragment index of the first node that
// is part of the sequence of matched nodes at the end of the
// fragment.
function preMatch(frag, parentDesc) {
  var curDesc = parentDesc,
    descI = curDesc.children.length;
  var fI = frag.childCount,
    matched = new Map(),
    matches = [];
  outer: while (fI > 0) {
    var desc = void 0;
    for (;;) {
      if (descI) {
        var next = curDesc.children[descI - 1];
        if (next instanceof MarkViewDesc) {
          curDesc = next;
          descI = next.children.length;
        } else {
          desc = next;
          descI--;
          break;
        }
      } else if (curDesc == parentDesc) {
        break outer;
      } else {
        // FIXME
        descI = curDesc.parent.children.indexOf(curDesc);
        curDesc = curDesc.parent;
      }
    }
    var node = desc.node;
    if (!node) continue;
    if (node != frag.child(fI - 1)) break;
    --fI;
    matched.set(desc, fI);
    matches.push(desc);
  }
  return {
    index: fI,
    matched: matched,
    matches: matches.reverse()
  };
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
// This function abstracts iterating over the nodes and decorations in
// a fragment. Calls `onNode` for each node, with its local and child
// decorations. Splits text nodes when there is a decoration starting
// or ending inside of them. Calls `onWidget` for each widget.
function iterDeco(parent, deco, onWidget, onNode) {
  var locals = deco.locals(parent),
    offset = 0;
  // Simple, cheap variant for when there are no local decorations
  if (locals.length == 0) {
    for (var i = 0; i < parent.childCount; i++) {
      var child = parent.child(i);
      onNode(child, locals, deco.forChild(offset, child), i);
      offset += child.nodeSize;
    }
    return;
  }
  var decoIndex = 0,
    active = [],
    restNode = null;
  for (var parentIndex = 0;;) {
    var widget = void 0,
      widgets = void 0;
    while (decoIndex < locals.length && locals[decoIndex].to == offset) {
      var next = locals[decoIndex++];
      if (next.widget) {
        if (!widget) widget = next;else (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (var _i2 = 0; _i2 < widgets.length; _i2++) onWidget(widgets[_i2], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    var _child = void 0,
      index = void 0;
    if (restNode) {
      index = -1;
      _child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index = parentIndex;
      _child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (var _i3 = 0; _i3 < active.length; _i3++) if (active[_i3].to <= offset) active.splice(_i3--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset) active.push(locals[decoIndex++]);
    var end = offset + _child.nodeSize;
    if (_child.isText) {
      var cutAt = end;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt) cutAt = locals[decoIndex].from;
      for (var _i4 = 0; _i4 < active.length; _i4++) if (active[_i4].to < cutAt) cutAt = active[_i4].to;
      if (cutAt < end) {
        restNode = _child.cut(cutAt - offset);
        _child = _child.cut(0, cutAt - offset);
        end = cutAt;
        index = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end) decoIndex++;
    }
    var outerDeco = _child.isInline && !_child.isLeaf ? active.filter(function (d) {
      return !d.inline;
    }) : active.slice();
    onNode(_child, outerDeco, deco.forChild(offset, _child), index);
    offset = end;
  }
}
// List markers in Mobile Safari will mysteriously disappear
// sometimes. This works around that.
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    var oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function nearbyTextNode(node, offset) {
  for (;;) {
    if (node.nodeType == 3) return node;
    if (node.nodeType == 1 && offset > 0) {
      if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3) return node.childNodes[offset];
      node = node.childNodes[offset - 1];
      offset = nodeSize(node);
    } else if (node.nodeType == 1 && offset < node.childNodes.length) {
      node = node.childNodes[offset];
      offset = 0;
    } else {
      return null;
    }
  }
}
// Find a piece of text in an inline fragment, overlapping from-to
function findTextInFragment(frag, text, from, to) {
  for (var i = 0, pos = 0; i < frag.childCount && pos <= to;) {
    var child = frag.child(i++),
      childStart = pos;
    pos += child.nodeSize;
    if (!child.isText) continue;
    var str = child.text;
    while (i < frag.childCount) {
      var next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText) break;
      str += next.text;
    }
    if (pos >= from) {
      if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text) return to - text.length;
      var found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
      if (found >= 0 && found + text.length + childStart >= from) return childStart + found;
      if (from == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text) return to;
    }
  }
  return -1;
}
// Replace range from-to in an array of view descs with replacement
// (may be null to just delete). This goes very much against the grain
// of the rest of this code, which tends to create nodes with the
// right shape in one go, rather than messing with them after
// creation, but is necessary in the composition hack.
function replaceNodes(nodes, from, to, view, replacement) {
  var result = [];
  for (var i = 0, off = 0; i < nodes.length; i++) {
    var child = nodes[i],
      start = off,
      end = off += child.size;
    if (start >= to || end <= from) {
      result.push(child);
    } else {
      if (start < from) result.push(child.slice(0, from - start, view));
      if (replacement) {
        result.push(replacement);
        replacement = undefined;
      }
      if (end > to) result.push(child.slice(to - start, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view) {
  var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var domSel = view.domSelectionRange(),
    doc = view.state.doc;
  if (!domSel.focusNode) return null;
  var nearestDesc = view.docView.nearestDesc(domSel.focusNode),
    inWidget = nearestDesc && nearestDesc.size == 0;
  var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0) return null;
  var $head = doc.resolve(head),
    $anchor,
    selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc && !nearestDesc.node) nearestDesc = nearestDesc.parent;
    var nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      var pos = nearestDesc.posBefore;
      selection = new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(head == pos ? $head : doc.resolve(pos));
    }
  } else {
    var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    if (anchor < 0) return null;
    $anchor = doc.resolve(anchor);
  }
  if (!selection) {
    var bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view) {
  var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view)) return;
  // The delayed drag selection causes issues with Cell Selections
  // in Safari. And the drag selection delay is to workarond issues
  // which only present in Chrome.
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    var domSel = view.domSelectionRange(),
      curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    var anchor = sel.anchor,
      head = sel.head,
      resetEditableFrom,
      resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection)) {
      if (!sel.$from.parent.inlineContent) resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent) resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom) resetEditable(resetEditableFrom);
      if (resetEditableTo) resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document) removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
// Kludge to work around Webkit not allowing a selection to start/end
// between non-editable block nodes. We briefly make something
// editable, set the selection, then set it uneditable again.
var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  var _view$docView$domFrom3 = view.docView.domFromPos(pos, 0),
    node = _view$docView$domFrom3.node,
    offset = _view$docView$domFrom3.offset;
  var after = offset < node.childNodes.length ? node.childNodes[offset] : null;
  var before = offset ? node.childNodes[offset - 1] : null;
  if (safari && after && after.contentEditable == "false") return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after) return setEditable(after);else if (before) return setEditable(before);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  var doc = view.dom.ownerDocument;
  doc.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  var domSel = view.domSelectionRange();
  var node = domSel.anchorNode,
    offset = domSel.anchorOffset;
  doc.addEventListener("selectionchange", view.input.hideSelectionGuard = function () {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
      doc.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(function () {
        if (!editorOwnsSelection(view) || view.state.selection.visible) view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  var domSel = view.domSelection(),
    range = document.createRange();
  var node = view.cursorWrapper.dom,
    img = node.nodeName == "IMG";
  if (img) range.setEnd(node.parentNode, domIndex(node) + 1);else range.setEnd(node, 0);
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);
  // Kludge to kill 'control selection' in IE11 when selecting an
  // invisible cursor wrapper, since that would result in those weird
  // resize handles and a selection that considers the absolutely
  // positioned wrapper, rather than the root editable node, the
  // focused element.
  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {
    var desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc) desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
// Clear all DOM statefulness of the last node selection.
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent) view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = undefined;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", function (f) {
    return f(view, $anchor, $head);
  }) || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus()) return false;
  return hasSelection(view);
}
function hasSelection(view) {
  var sel = view.domSelectionRange();
  if (!sel.anchorNode) return false;
  try {
    // Firefox will raise 'permission denied' errors when accessing
    // properties of `sel.anchorNode` when it's in a generated CSS
    // element.
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  var domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  var _state$selection = state.selection,
    $anchor = _state$selection.$anchor,
    $head = _state$selection.$head;
  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {
    if (mods.indexOf("s") > -1) {
      var $head = sel.$head,
        node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node || node.isText || !node.isLeaf) return false;
      var $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
      return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      var next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) return apply(view, next);
      return false;
    } else if (!(mac && mods.indexOf("m") > -1)) {
      var _$head = sel.$head,
        _node = _$head.textOffset ? null : dir < 0 ? _$head.nodeBefore : _$head.nodeAfter,
        desc;
      if (!_node || _node.isText) return false;
      var nodePos = dir < 0 ? _$head.pos - _node.nodeSize : _$head.pos;
      if (!(_node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) return false;
      if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(_node)) {
        return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(dir < 0 ? view.state.doc.resolve(_$head.pos - _node.nodeSize) : _$head));
      } else if (webkit) {
        // Chrome and Safari will introduce extra pointless cursor
        // positions around inline uneditable nodes, so we have to
        // take over and move the cursor past them (#937)
        return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + _node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && sel.node.isInline) {
    return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    var _next = moveSelectionBlock(view.state, dir);
    if (_next) return apply(view, _next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom, dir) {
  var desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
// Make sure the cursor isn't directly after one or more ignored
// nodes, which will confuse the browser's cursor motion logic.
function skipIgnoredNodesBefore(view) {
  var sel = view.domSelectionRange();
  var node = sel.focusNode,
    offset = sel.focusOffset;
  if (!node) return;
  var moveNode,
    moveOffset,
    force = false;
  // Gecko will do odd things when the selection is directly in front
  // of a non-editable node, so in that case, move it into the next
  // node if possible. Issue prosemirror/prosemirror#832.
  if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset], -1)) force = true;
  for (;;) {
    if (offset > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        var before = node.childNodes[offset - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node;
          moveOffset = --offset;
        } else if (before.nodeType == 3) {
          node = before;
          offset = node.nodeValue.length;
        } else break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      var prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom) break;
        offset = 0;
      } else {
        node = prev;
        offset = nodeLen(node);
      }
    }
  }
  if (force) setSelFocus(view, node, offset);else if (moveNode) setSelFocus(view, moveNode, moveOffset);
}
// Make sure the cursor isn't directly before one or more ignored
// nodes.
function skipIgnoredNodesAfter(view) {
  var sel = view.domSelectionRange();
  var node = sel.focusNode,
    offset = sel.focusOffset;
  if (!node) return;
  var len = nodeLen(node);
  var moveNode, moveOffset;
  for (;;) {
    if (offset < len) {
      if (node.nodeType != 1) break;
      var after = node.childNodes[offset];
      if (isIgnorable(after, 1)) {
        moveNode = node;
        moveOffset = ++offset;
      } else break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      var next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom) break;
        offset = len = 0;
      } else {
        node = next;
        offset = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode) setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node, offset) {
  while (node && offset == node.childNodes.length && !hasBlockDesc(node)) {
    offset = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset < node.childNodes.length) {
    var next = node.childNodes[offset];
    if (next.nodeType == 3) return next;
    if (next.nodeType == 1 && next.contentEditable == "false") break;
    node = next;
    offset = 0;
  }
}
function textNodeBefore(node, offset) {
  while (node && !offset && !hasBlockDesc(node)) {
    offset = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset) {
    var next = node.childNodes[offset - 1];
    if (next.nodeType == 3) return next;
    if (next.nodeType == 1 && next.contentEditable == "false") break;
    node = next;
    offset = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset) {
  if (node.nodeType != 3) {
    var before, after;
    if (after = textNodeAfter(node, offset)) {
      node = after;
      offset = 0;
    } else if (before = textNodeBefore(node, offset)) {
      node = before;
      offset = before.nodeValue.length;
    }
  }
  var sel = view.domSelection();
  if (selectionCollapsed(sel)) {
    var range = document.createRange();
    range.setEnd(node, offset);
    range.setStart(node, offset);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset);
  }
  view.domObserver.setCurSelection();
  var state = view.state;
  // If no state update ends up happening, reset the selection.
  setTimeout(function () {
    if (view.state == state) selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  var $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows) && $pos.parent.inlineContent) {
    var coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      var before = view.coordsAtPos(pos - 1);
      var mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1) return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      var after = view.coordsAtPos(pos + 1);
      var _mid = (after.top + after.bottom) / 2;
      if (_mid > coords.top && _mid < coords.bottom && Math.abs(after.left - coords.left) > 1) return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  var computed = getComputedStyle(view.dom).direction;
  return computed == "rtl" ? "rtl" : "ltr";
}
// Check whether vertical selection motion would involve node
// selections. If so, apply it (if not, the result is left to the
// browser)
function selectVertically(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty || mods.indexOf("s") > -1) return false;
  if (mac && mods.indexOf("m") > -1) return false;
  var $from = sel.$from,
    $to = sel.$to;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    var next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) return apply(view, next);
  }
  if (!$from.parent.inlineContent) {
    var side = dir < 0 ? $from : $to;
    var beyond = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(side, dir) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection)) return true;
  var _view$state$selection2 = view.state.selection,
    $head = _view$state$selection2.$head,
    $anchor = _view$state$selection2.$anchor,
    empty = _view$state$selection2.empty;
  if (!$head.sameParent($anchor)) return true;
  if (!empty) return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) return true;
  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    var tr = view.state.tr;
    if (dir < 0) tr["delete"]($head.pos - nextNode.nodeSize, $head.pos);else tr["delete"]($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821
// In which Safari (and at some point in the past, Chrome) does really
// wrong things when the down arrow is pressed when the cursor is
// directly at the start of a textblock and has an uneditable node
// after it
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0) return false;
  var _view$domSelectionRan3 = view.domSelectionRange(),
    focusNode = _view$domSelectionRan3.focusNode,
    focusOffset = _view$domSelectionRan3.focusOffset;
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    var child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(function () {
      return switchEditable(view, child, "false");
    }, 20);
  }
  return false;
}
// A backdrop key mapping used to make sure we always suppress keys
// that have a dangerous default effect, even if the commands they are
// bound to return false, and to make sure that cursor-motion keys
// find a cursor (as opposed to a node selection) when pressed. For
// cursor-motion keys, the code in the handlers also takes care of
// block selections.
function getMods(event) {
  var result = "";
  if (event.ctrlKey) result += "c";
  if (event.metaKey) result += "m";
  if (event.altKey) result += "a";
  if (event.shiftKey) result += "s";
  return result;
}
function captureKeyDown(view, event) {
  var code = event.keyCode,
    mods = getMods(event);
  if (code == 8 || mac && code == 72 && mods == "c") {
    // Backspace, Ctrl-h on Mac
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code == 46 && !event.shiftKey || mac && code == 68 && mods == "c") {
    // Delete, Ctrl-d on Mac
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code == 13 || code == 27) {
    // Enter, Esc
    return true;
  } else if (code == 37 || mac && code == 66 && mods == "c") {
    // Left arrow, Ctrl-b on Mac
    var dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 39 || mac && code == 70 && mods == "c") {
    // Right arrow, Ctrl-f on Mac
    var _dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, _dir, mods) || skipIgnoredNodes(view, _dir);
  } else if (code == 38 || mac && code == 80 && mods == "c") {
    // Up arrow, Ctrl-p on Mac
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code == 40 || mac && code == 78 && mods == "c") {
    // Down arrow, Ctrl-n on Mac
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    // Mod-[biyz]
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice) {
  view.someProp("transformCopied", function (f) {
    slice = f(slice, view);
  });
  var context = [],
    _slice = slice,
    content = _slice.content,
    openStart = _slice.openStart,
    openEnd = _slice.openEnd;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    var node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  var serializer = view.someProp("clipboardSerializer") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(view.state.schema);
  var doc = detachedDoc(),
    wrap = doc.createElement("div");
  wrap.appendChild(serializer.serializeFragment(content, {
    document: doc
  }));
  var firstChild = wrap.firstChild,
    needsWrap,
    wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (var i = needsWrap.length - 1; i >= 0; i--) {
      var wrapper = doc.createElement(needsWrap[i]);
      while (wrap.firstChild) wrapper.appendChild(wrap.firstChild);
      wrap.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1) firstChild.setAttribute("data-pm-slice", "".concat(openStart, " ").concat(openEnd).concat(wrappers ? " -".concat(wrappers) : "", " ").concat(JSON.stringify(context)));
  var text = view.someProp("clipboardTextSerializer", function (f) {
    return f(slice, view);
  }) || slice.content.textBetween(0, slice.content.size, "\n\n");
  return {
    dom: wrap,
    text: text
  };
}
// Read a slice of content from the clipboard (or drop data).
function parseFromClipboard(view, text, html, plainText, $context) {
  var inCode = $context.parent.type.spec.code;
  var dom, slice;
  if (!html && !text) return null;
  var asText = text && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", function (f) {
      text = f(text, inCode || plainText, view);
    });
    if (inCode) return text ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;
    var parsed = view.someProp("clipboardTextParser", function (f) {
      return f(text, $context, plainText, view);
    });
    if (parsed) {
      slice = parsed;
    } else {
      var marks = $context.marks();
      var schema = view.state.schema,
        serializer = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach(function (block) {
        var p = dom.appendChild(document.createElement("p"));
        if (block) p.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", function (f) {
      html = f(html, view);
    });
    dom = readHTML(html);
    if (webkit) restoreReplacedSpaces(dom);
  }
  var contextNode = dom && dom.querySelector("[data-pm-slice]");
  var sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3]) for (var i = +sliceData[3]; i > 0; i--) {
    var child = dom.firstChild;
    while (child && child.nodeType != 1) child = child.nextSibling;
    if (!child) break;
    dom = child;
  }
  if (!slice) {
    var parser = view.someProp("clipboardParser") || view.someProp("domParser") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);
    slice = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode: function ruleFromNode(dom) {
        if (dom.nodeName == "BR" && !dom.nextSibling && dom.parentNode && !inlineParents.test(dom.parentNode.nodeName)) return {
          ignore: true
        };
        return null;
      }
    });
  }
  if (sliceData) {
    slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    // HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent
    slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);
    if (slice.openStart || slice.openEnd) {
      var openStart = 0,
        openEnd = 0;
      for (var node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {}
      for (var _node2 = slice.content.lastChild; openEnd < slice.openEnd && !_node2.type.spec.isolating; openEnd++, _node2 = _node2.lastChild) {}
      slice = closeSlice(slice, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", function (f) {
    slice = f(slice, view);
  });
  return slice;
}
var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
// Takes a slice parsed with parseSlice, which means there hasn't been
// any content-expression checking done on the top nodes, tries to
// find a parent node in the current context that might fit the nodes,
// and if successful, rebuilds the slice so that it fits into that parent.
//
// This addresses the problem that Transform.replace expects a
// coherent slice, and will fail to place a set of siblings that don't
// fit anywhere in the schema.
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2) return fragment;
  var _loop = function _loop() {
      var parent = $context.node(d);
      var match = parent.contentMatchAt($context.index(d));
      var lastWrap,
        result = [];
      fragment.forEach(function (node) {
        if (!result) return;
        var wrap = match.findWrapping(node.type),
          inLast;
        if (!wrap) return result = null;
        if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {
          result[result.length - 1] = inLast;
        } else {
          if (result.length) result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
          var wrapped = withWrappers(node, wrap);
          result.push(wrapped);
          match = match.matchType(wrapped.type);
          lastWrap = wrap;
        }
      });
      if (result) return {
        v: prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(result)
      };
    },
    _ret;
  for (var d = $context.depth; d >= 0; d--) {
    _ret = _loop();
    if (_ret) return _ret.v;
  }
  return fragment;
}
function withWrappers(node, wrap) {
  var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  for (var i = wrap.length - 1; i >= from; i--) node = wrap[i].create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node));
  return node;
}
// Used to group adjacent nodes wrapped in similar parents by
// normalizeSiblings into the same parent node
function addToSibling(wrap, lastWrap, node, sibling, depth) {
  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
    var inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner) return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    var match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1])) return sibling.copy(sibling.content.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(withWrappers(node, wrap, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0) return node;
  var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  var fill = node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from, to, depth, openEnd) {
  var node = side < 0 ? fragment.firstChild : fragment.lastChild,
    inner = node.content;
  if (fragment.childCount > 1) openEnd = 0;
  if (depth < to - 1) inner = closeRange(inner, side, from, to, depth + 1, openEnd);
  if (depth >= from) inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice, openStart, openEnd) {
  if (openStart < slice.openStart) slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);
  if (openEnd < slice.openEnd) slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);
  return slice;
}
// Trick from jQuery -- some elements must be wrapped in other
// elements for innerHTML to work. I.e. if you do `div.innerHTML =
// "<td>..</td>"` the table cells are ignored.
var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
function readHTML(html) {
  var metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas) html = html.slice(metas[0].length);
  var elt = detachedDoc().createElement("div");
  var firstTag = /<([a-z][^>\s]+)/i.exec(html),
    wrap;
  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) html = wrap.map(function (n) {
    return "<" + n + ">";
  }).join("") + html + wrap.map(function (n) {
    return "</" + n + ">";
  }).reverse().join("");
  elt.innerHTML = html;
  if (wrap) for (var i = 0; i < wrap.length; i++) elt = elt.querySelector(wrap[i]) || elt;
  return elt;
}
// Webkit browsers do some hard-to-predict replacement of regular
// spaces with non-breaking spaces when putting content on the
// clipboard. This tries to convert such non-breaking spaces (which
// will be wrapped in a plain span on Chrome, a span with class
// Apple-converted-space on Safari) back to regular spaces.
function restoreReplacedSpaces(dom) {
  var nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode) node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice, context) {
  if (!slice.size) return slice;
  var schema = slice.content.firstChild.type.schema,
    array;
  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice;
  }
  var content = slice.content,
    openStart = slice.openStart,
    openEnd = slice.openEnd;
  for (var i = array.length - 2; i >= 0; i -= 2) {
    var type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs()) break;
    content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(array[i + 1], content));
    openStart++;
    openEnd++;
  }
  return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);
}

// A collection of DOM events that occur within the editor, and callback functions
// to invoke when the event fires.
var handlers = {};
var editHandlers = {};
var passiveHandlers = {
  touchstart: true,
  touchmove: true
};
var InputState = /*#__PURE__*/_createClass(function InputState() {
  _classCallCheck(this, InputState);
  this.shiftKey = false;
  this.mouseDown = null;
  this.lastKeyCode = null;
  this.lastKeyCodeTime = 0;
  this.lastClick = {
    time: 0,
    x: 0,
    y: 0,
    type: ""
  };
  this.lastSelectionOrigin = null;
  this.lastSelectionTime = 0;
  this.lastIOSEnter = 0;
  this.lastIOSEnterFallbackTimeout = -1;
  this.lastFocus = 0;
  this.lastTouch = 0;
  this.lastAndroidDelete = 0;
  this.composing = false;
  this.composingTimeout = -1;
  this.compositionNodes = [];
  this.compositionEndedAt = -2e8;
  this.compositionID = 1;
  // Set to a composition ID when there are pending changes at compositionend
  this.compositionPendingChanges = 0;
  this.domChangeCount = 0;
  this.eventHandlers = Object.create(null);
  this.hideSelectionGuard = null;
});
function initInput(view) {
  var _loop2 = function _loop2() {
    var handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = function (event) {
      if (eventBelongsToView(view, event) && !runCustomHandler(view, event) && (view.editable || !(event.type in editHandlers))) handler(view, event);
    }, passiveHandlers[event] ? {
      passive: true
    } : undefined);
  };
  for (var event in handlers) {
    _loop2();
  }
  // On Safari, for reasons beyond my understanding, adding an input
  // event handler makes an issue where the composition vanishes when
  // you press enter go away.
  if (safari) view.dom.addEventListener("input", function () {
    return null;
  });
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (var type in view.input.eventHandlers) view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", function (currentHandlers) {
    for (var type in currentHandlers) if (!view.input.eventHandlers[type]) view.dom.addEventListener(type, view.input.eventHandlers[type] = function (event) {
      return runCustomHandler(view, event);
    });
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", function (handlers) {
    var handler = handlers[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles) return true;
  if (event.defaultPrevented) return false;
  for (var node = event.target; node != view.dom; node = node.parentNode) if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event)) return false;
  return true;
}
function _dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers))) handlers[event.type](view, event);
}
editHandlers.keydown = function (view, _event) {
  var event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event)) return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  // Suppress enter key events on Chrome Android, because those tend
  // to be part of a confused sequence of composition events fired,
  // and handling them eagerly tends to corrupt the input.
  if (android && chrome && event.keyCode == 13) return;
  if (event.keyCode != 229) view.domObserver.forceFlush();
  // On iOS, if we preventDefault enter key presses, the virtual
  // keyboard gets confused. So the hack here is to set a flag that
  // makes the DOM change code recognize that what just happens should
  // be replaced by whatever the Enter key handlers do.
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    var now = Date.now();
    view.input.lastIOSEnter = now;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(function () {
      if (view.input.lastIOSEnter == now) {
        view.someProp("handleKeyDown", function (f) {
          return f(view, keyEvent(13, "Enter"));
        });
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", function (f) {
    return f(view, event);
  }) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = function (view, event) {
  if (event.keyCode == 16) view.input.shiftKey = false;
};
editHandlers.keypress = function (view, _event) {
  var event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey) return;
  if (view.someProp("handleKeyPress", function (f) {
    return f(view, event);
  })) {
    event.preventDefault();
    return;
  }
  var sel = view.state.selection;
  if (!(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || !sel.$from.sameParent(sel.$to)) {
    var text = String.fromCharCode(event.charCode);
    if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", function (f) {
      return f(view, sel.$from.pos, sel.$to.pos, text);
    })) view.dispatch(view.state.tr.insertText(text).scrollIntoView());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return {
    left: event.clientX,
    top: event.clientY
  };
}
function isNear(event, click) {
  var dx = click.x - event.clientX,
    dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1) return false;
  var $pos = view.state.doc.resolve(inside);
  var _loop3 = function _loop3(i) {
      if (view.someProp(propName, function (f) {
        return i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false);
      })) return {
        v: true
      };
    },
    _ret2;
  for (var i = $pos.depth + 1; i > 0; i--) {
    _ret2 = _loop3(i);
    if (_ret2) return _ret2.v;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused) view.focus();
  var tr = view.state.tr.setSelection(selection);
  if (origin == "pointer") tr.setMeta("pointer", true);
  view.dispatch(tr);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1) return false;
  var $pos = view.state.doc.resolve(inside),
    node = $pos.nodeAfter;
  if (node && node.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {
    updateSelection(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos), "pointer");
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1) return false;
  var sel = view.state.selection,
    selectedNode,
    selectAt;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) selectedNode = sel.node;
  var $pos = view.state.doc.resolve(inside);
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) selectAt = $pos.before(sel.$from.depth);else selectAt = $pos.before(i);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", function (f) {
    return f(view, pos, event);
  }) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", function (f) {
    return f(view, pos, event);
  });
}
function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", function (f) {
    return f(view, pos, event);
  }) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0) return false;
  var doc = view.state.doc;
  if (inside == -1) {
    if (doc.inlineContent) {
      updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, 0, doc.content.size), "pointer");
      return true;
    }
    return false;
  }
  var $pos = doc.resolve(inside);
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    var nodePos = $pos.before(i);
    if (node.inlineContent) updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), "pointer");else if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(doc, nodePos), "pointer");else continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
var selectNodeModifier = mac ? "metaKey" : "ctrlKey";
handlers.mousedown = function (view, _event) {
  var event = _event;
  view.input.shiftKey = event.shiftKey;
  var flushed = forceDOMFlush(view);
  var now = Date.now(),
    type = "singleClick";
  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
    if (view.input.lastClick.type == "singleClick") type = "doubleClick";else if (view.input.lastClick.type == "doubleClick") type = "tripleClick";
  }
  view.input.lastClick = {
    time: now,
    x: event.clientX,
    y: event.clientY,
    type: type
  };
  var pos = view.posAtCoords(eventCoords(event));
  if (!pos) return;
  if (type == "singleClick") {
    if (view.input.mouseDown) view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
var MouseDown = /*#__PURE__*/function () {
  function MouseDown(view, pos, event, flushed) {
    var _this8 = this;
    _classCallCheck(this, MouseDown);
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    var targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      var $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    var target = flushed ? null : event.target;
    var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc ? targetDesc.dom : null;
    var selection = view.state.selection;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && selection.from <= targetPos && selection.to > targetPos) this.mightDrag = {
      node: targetNode,
      pos: targetPos,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
    };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr) this.target.draggable = true;
      if (this.mightDrag.setUneditable) setTimeout(function () {
        if (_this8.view.input.mouseDown == _this8) _this8.target.setAttribute("contentEditable", "false");
      }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  _createClass(MouseDown, [{
    key: "done",
    value: function done() {
      var _this9 = this;
      this.view.root.removeEventListener("mouseup", this.up);
      this.view.root.removeEventListener("mousemove", this.move);
      if (this.mightDrag && this.target) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr) this.target.removeAttribute("draggable");
        if (this.mightDrag.setUneditable) this.target.removeAttribute("contentEditable");
        this.view.domObserver.start();
      }
      if (this.delayedSelectionSync) setTimeout(function () {
        return selectionToDOM(_this9.view);
      });
      this.view.input.mouseDown = null;
    }
  }, {
    key: "up",
    value: function up(event) {
      this.done();
      if (!this.view.dom.contains(event.target)) return;
      var pos = this.pos;
      if (this.view.state.doc != this.startDoc) pos = this.view.posAtCoords(eventCoords(event));
      this.updateAllowDefault(event);
      if (this.allowDefault || !pos) {
        setSelectionOrigin(this.view, "pointer");
      } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
        event.preventDefault();
      } else if (event.button == 0 && (this.flushed ||
      // Safari ignores clicks on draggable elements
      safari && this.mightDrag && !this.mightDrag.node.isAtom ||
      // Chrome will sometimes treat a node selection as a
      // cursor, but still report that the node is selected
      // when asked through getSelection. You'll then get a
      // situation where clicking at the point where that
      // (hidden) cursor is doesn't change the selection, and
      // thus doesn't get a reaction from ProseMirror. This
      // works around that.
      chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
        updateSelection(this.view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
        event.preventDefault();
      } else {
        setSelectionOrigin(this.view, "pointer");
      }
    }
  }, {
    key: "move",
    value: function move(event) {
      this.updateAllowDefault(event);
      setSelectionOrigin(this.view, "pointer");
      if (event.buttons == 0) this.done();
    }
  }, {
    key: "updateAllowDefault",
    value: function updateAllowDefault(event) {
      if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) this.allowDefault = true;
    }
  }]);
  return MouseDown;
}();
handlers.touchstart = function (view) {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = function (view) {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = function (view) {
  return forceDOMFlush(view);
};
function inOrNearComposition(view, event) {
  if (view.composing) return true;
  // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
  // On Japanese input method editors (IMEs), the Enter key is used to confirm character
  // selection. On Safari, when Enter is pressed, compositionend and keydown events are
  // emitted. The keydown event triggers newline insertion, which we don't want.
  // This method returns true if the keydown event should be ignored.
  // We only ignore it once, as pressing Enter a second time *should* insert a newline.
  // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.
  // This guards against the case where compositionend is triggered without the keyboard
  // (e.g. character confirmation may be done with the mouse), and keydown is triggered
  // afterwards- we wouldn't want to ignore the keydown event in this case.
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
// Drop active composition after 5 seconds of inactivity on Android
var timeoutComposition = android ? 5000 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = function (view) {
  if (!view.composing) {
    view.domObserver.flush();
    var state = view.state,
      $pos = state.selection.$from;
    if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function (m) {
      return m.type.spec.inclusive === false;
    }))) {
      // Need to wrap the cursor in mark nodes different from the ones in the DOM context
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);
      // In firefox, if the cursor is after but outside a marked node,
      // the inserted text won't inherit the marks. So this moves it
      // inside if necessary.
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        var sel = view.domSelectionRange();
        for (var node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {
          var before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];
          if (!before) break;
          if (before.nodeType == 3) {
            view.domSelection().collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = function (view, event) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    if (view.input.compositionPendingChanges) Promise.resolve().then(function () {
      return view.domObserver.flush();
    });
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1) view.input.composingTimeout = setTimeout(function () {
    return endComposition(view);
  }, delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0) view.input.compositionNodes.pop().markParentsDirty();
}
function timestampFromCustomEvent() {
  var event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
/**
@internal
*/
function endComposition(view) {
  var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (android && view.domObserver.flushingSoon >= 0) return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (forceUpdate || view.docView && view.docView.dirty) {
    var sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection)) view.dispatch(view.state.tr.setSelection(sel));else view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  // The extra wrapper is somehow necessary on IE/Edge to prevent the
  // content from being mangled when it is put onto the clipboard
  if (!view.dom.parentNode) return;
  var wrap = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap.appendChild(dom);
  wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
  var sel = getSelection(),
    range = document.createRange();
  range.selectNodeContents(dom);
  // Done because IE will fire a selectionchange moving the selection
  // to its start when removeAllRanges is called and the editor still
  // has focus (which will mess up the editor's selection state).
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(function () {
    if (wrap.parentNode) wrap.parentNode.removeChild(wrap);
    view.focus();
  }, 50);
}
// This is very crude, but unfortunately both these browsers _pretend_
// that they have a clipboard APIall the objects and methods are
// there, they just don't work, and they are hard to test.
var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = function (view, _event) {
  var event = _event;
  var sel = view.state.selection,
    cut = event.type == "cut";
  if (sel.empty) return;
  // IE and Edge's clipboard interface is completely broken
  var data = brokenClipboardAPI ? null : event.clipboardData;
  var slice = sel.content(),
    _serializeForClipboar = serializeForClipboard(view, slice),
    dom = _serializeForClipboar.dom,
    text = _serializeForClipboar.text;
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }
  if (cut) view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice) {
  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode) return;
  var plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText) target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  var plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(function () {
    view.focus();
    if (target.parentNode) target.parentNode.removeChild(target);
    if (plainText) doPaste(view, target.value, null, plain, event);else doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text, html, preferPlain, event) {
  var slice = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", function (f) {
    return f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty);
  })) return true;
  if (!slice) return false;
  var singleNode = sliceSingleNode(slice);
  var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText(clipboardData) {
  var text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text) return text;
  var uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = function (view, _event) {
  var event = _event;
  // Handling paste from JavaScript during composition is very poorly
  // handled by browsers, so as a dodgy but preferable kludge, we just
  // let the browser do its native thing there, except on Android,
  // where the editor is almost always composing.
  if (view.composing && !android) return;
  var data = brokenClipboardAPI ? null : event.clipboardData;
  var plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event)) event.preventDefault();else capturePaste(view, event);
};
var Dragging = /*#__PURE__*/_createClass(function Dragging(slice, move, node) {
  _classCallCheck(this, Dragging);
  this.slice = slice;
  this.move = move;
  this.node = node;
});
var dragCopyModifier = mac ? "altKey" : "ctrlKey";
handlers.dragstart = function (view, _event) {
  var event = _event;
  var mouseDown = view.input.mouseDown;
  if (mouseDown) mouseDown.done();
  if (!event.dataTransfer) return;
  var sel = view.state.selection;
  var pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  var node;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection ? sel.to - 1 : sel.to)) ;else if (mouseDown && mouseDown.mightDrag) {
    node = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    var desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView) node = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, desc.posBefore);
  }
  var slice = (node || view.state.selection).content(),
    _serializeForClipboar2 = serializeForClipboard(view, slice),
    dom = _serializeForClipboar2.dom,
    text = _serializeForClipboar2.text;
  event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  // See https://github.com/ProseMirror/prosemirror/issues/1156
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI) event.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging(slice, !event[dragCopyModifier], node);
};
handlers.dragend = function (view) {
  var dragging = view.dragging;
  window.setTimeout(function () {
    if (view.dragging == dragging) view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = function (_, e) {
  return e.preventDefault();
};
editHandlers.drop = function (view, _event) {
  var event = _event;
  var dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer) return;
  var eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos) return;
  var $mouse = view.state.doc.resolve(eventPos.pos);
  var slice = dragging && dragging.slice;
  if (slice) {
    view.someProp("transformPasted", function (f) {
      slice = f(slice, view);
    });
  } else {
    slice = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  var move = !!(dragging && !event[dragCopyModifier]);
  if (view.someProp("handleDrop", function (f) {
    return f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, move);
  })) {
    event.preventDefault();
    return;
  }
  if (!slice) return;
  event.preventDefault();
  var insertPos = slice ? (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__.dropPoint)(view.state.doc, $mouse.pos, slice) : $mouse.pos;
  if (insertPos == null) insertPos = $mouse.pos;
  var tr = view.state.tr;
  if (move) {
    var node = dragging.node;
    if (node) node.replace(tr);else tr.deleteSelection();
  }
  var pos = tr.mapping.map(insertPos);
  var isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
  var beforeInsert = tr.doc;
  if (isNode) tr.replaceRangeWith(pos, pos, slice.content.firstChild);else tr.replaceRange(pos, pos, slice);
  if (tr.doc.eq(beforeInsert)) return;
  var $pos = tr.doc.resolve(pos);
  if (isNode && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {
    tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos));
  } else {
    var end = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function (_from, _to, _newFrom, newTo) {
      return end = newTo;
    });
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
  }
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};
handlers.focus = function (view) {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(function () {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange())) selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = function (view, _event) {
  var event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget)) view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = function (view, _event) {
  var event = _event;
  // We should probably do more with beforeinput events, but support
  // is so spotty that I'm still waiting to see where they are going.
  // Very specific hack to deal with backspace sometimes failing on
  // Chrome Android when after an uneditable node.
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    var domChangeCount = view.input.domChangeCount;
    setTimeout(function () {
      if (view.input.domChangeCount != domChangeCount) return; // Event already had some effect
      // This bug tends to close the virtual keyboard, so we refocus
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", function (f) {
        return f(view, keyEvent(8, "Backspace"));
      })) return;
      var $cursor = view.state.selection.$cursor;
      // Crude approximation of backspace behavior when no command handled it
      if ($cursor && $cursor.pos > 0) view.dispatch(view.state.tr["delete"]($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
// Make sure all handlers get registered
for (var prop in editHandlers) handlers[prop] = editHandlers[prop];
function compareObjs(a, b) {
  if (a == b) return true;
  for (var p in a) if (a[p] !== b[p]) return false;
  for (var _p in b) if (!(_p in a)) return false;
  return true;
}
var WidgetType = /*#__PURE__*/function () {
  function WidgetType(toDOM, spec) {
    _classCallCheck(this, WidgetType);
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  _createClass(WidgetType, [{
    key: "map",
    value: function map(mapping, span, offset, oldOffset) {
      var _mapping$mapResult = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1),
        pos = _mapping$mapResult.pos,
        deleted = _mapping$mapResult.deleted;
      return deleted ? null : new Decoration(pos - offset, pos - offset, this);
    }
  }, {
    key: "valid",
    value: function valid() {
      return true;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
    }
  }, {
    key: "destroy",
    value: function destroy(node) {
      if (this.spec.destroy) this.spec.destroy(node);
    }
  }]);
  return WidgetType;
}();
var InlineType = /*#__PURE__*/function () {
  function InlineType(attrs, spec) {
    _classCallCheck(this, InlineType);
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  _createClass(InlineType, [{
    key: "map",
    value: function map(mapping, span, offset, oldOffset) {
      var from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
      var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
      return from >= to ? null : new Decoration(from, to, this);
    }
  }, {
    key: "valid",
    value: function valid(_, span) {
      return span.from < span.to;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    }
  }, {
    key: "destroy",
    value: function destroy() {}
  }], [{
    key: "is",
    value: function is(span) {
      return span.type instanceof InlineType;
    }
  }]);
  return InlineType;
}();
var NodeType = /*#__PURE__*/function () {
  function NodeType(attrs, spec) {
    _classCallCheck(this, NodeType);
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  _createClass(NodeType, [{
    key: "map",
    value: function map(mapping, span, offset, oldOffset) {
      var from = mapping.mapResult(span.from + oldOffset, 1);
      if (from.deleted) return null;
      var to = mapping.mapResult(span.to + oldOffset, -1);
      if (to.deleted || to.pos <= from.pos) return null;
      return new Decoration(from.pos - offset, to.pos - offset, this);
    }
  }, {
    key: "valid",
    value: function valid(node, span) {
      var _node$content$findInd = node.content.findIndex(span.from),
        index = _node$content$findInd.index,
        offset = _node$content$findInd.offset,
        child;
      return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    }
  }, {
    key: "destroy",
    value: function destroy() {}
  }]);
  return NodeType;
}();
/**
Decoration objects can be provided to the view through the
[`decorations` prop](https://prosemirror.net/docs/ref/#view.EditorProps.decorations). They come in
several variantssee the static members of this class for details.
*/
var Decoration = /*#__PURE__*/function () {
  /**
  @internal
  */
  function Decoration(
  /**
  The start position of the decoration.
  */
  from,
  /**
  The end position. Will be the same as `from` for [widget
  decorations](https://prosemirror.net/docs/ref/#view.Decoration^widget).
  */
  to,
  /**
  @internal
  */
  type) {
    _classCallCheck(this, Decoration);
    this.from = from;
    this.to = to;
    this.type = type;
  }
  /**
  @internal
  */
  _createClass(Decoration, [{
    key: "copy",
    value: function copy(from, to) {
      return new Decoration(from, to, this.type);
    }
    /**
    @internal
    */
  }, {
    key: "eq",
    value: function eq(other) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;
    }
    /**
    @internal
    */
  }, {
    key: "map",
    value: function map(mapping, offset, oldOffset) {
      return this.type.map(mapping, this, offset, oldOffset);
    }
    /**
    Creates a widget decoration, which is a DOM node that's shown in
    the document at the given position. It is recommended that you
    delay rendering the widget by passing a function that will be
    called when the widget is actually drawn in a view, but you can
    also directly pass a DOM node. `getPos` can be used to find the
    widget's current document position.
    */
  }, {
    key: "spec",
    get:
    /**
    The spec provided when creating this decoration. Can be useful
    if you've stored extra information in that object.
    */
    function get() {
      return this.type.spec;
    }
    /**
    @internal
    */
  }, {
    key: "inline",
    get: function get() {
      return this.type instanceof InlineType;
    }
    /**
    @internal
    */
  }, {
    key: "widget",
    get: function get() {
      return this.type instanceof WidgetType;
    }
  }], [{
    key: "widget",
    value: function widget(pos, toDOM, spec) {
      return new Decoration(pos, pos, new WidgetType(toDOM, spec));
    }
    /**
    Creates an inline decoration, which adds the given attributes to
    each inline node between `from` and `to`.
    */
  }, {
    key: "inline",
    value: function inline(from, to, attrs, spec) {
      return new Decoration(from, to, new InlineType(attrs, spec));
    }
    /**
    Creates a node decoration. `from` and `to` should point precisely
    before and after a node in the document. That node, and only that
    node, will receive the given attributes.
    */
  }, {
    key: "node",
    value: function node(from, to, attrs, spec) {
      return new Decoration(from, to, new NodeType(attrs, spec));
    }
  }]);
  return Decoration;
}();
var none = [],
  noSpec = {};
/**
A collection of [decorations](https://prosemirror.net/docs/ref/#view.Decoration), organized in such
a way that the drawing algorithm can efficiently use and compare
them. This is a persistent data structureit is not modified,
updates create a new value.
*/
var DecorationSet = /*#__PURE__*/function () {
  /**
  @internal
  */
  function DecorationSet(local, children) {
    _classCallCheck(this, DecorationSet);
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  _createClass(DecorationSet, [{
    key: "find",
    value:
    /**
    Find all decorations in this set which touch the given range
    (including decorations that start or end directly at the
    boundaries) and match the given predicate on their spec. When
    `start` and `end` are omitted, all decorations in the set are
    considered. When `predicate` isn't given, all decorations are
    assumed to match.
    */
    function find(start, end, predicate) {
      var result = [];
      this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
      return result;
    }
  }, {
    key: "findInner",
    value: function findInner(start, end, result, offset, predicate) {
      for (var i = 0; i < this.local.length; i++) {
        var span = this.local[i];
        if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec))) result.push(span.copy(span.from + offset, span.to + offset));
      }
      for (var _i5 = 0; _i5 < this.children.length; _i5 += 3) {
        if (this.children[_i5] < end && this.children[_i5 + 1] > start) {
          var childOff = this.children[_i5] + 1;
          this.children[_i5 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
        }
      }
    }
    /**
    Map the set of decorations in response to a change in the
    document.
    */
  }, {
    key: "map",
    value: function map(mapping, doc, options) {
      if (this == empty || mapping.maps.length == 0) return this;
      return this.mapInner(mapping, doc, 0, 0, options || noSpec);
    }
    /**
    @internal
    */
  }, {
    key: "mapInner",
    value: function mapInner(mapping, node, offset, oldOffset, options) {
      var newLocal;
      for (var i = 0; i < this.local.length; i++) {
        var mapped = this.local[i].map(mapping, offset, oldOffset);
        if (mapped && mapped.type.valid(node, mapped)) (newLocal || (newLocal = [])).push(mapped);else if (options.onRemove) options.onRemove(this.local[i].spec);
      }
      if (this.children.length) return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);else return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;
    }
    /**
    Add the given array of decorations to the ones in the set,
    producing a new set. Consumes the `decorations` array. Needs
    access to the current document to create the appropriate tree
    structure.
    */
  }, {
    key: "add",
    value: function add(doc, decorations) {
      if (!decorations.length) return this;
      if (this == empty) return DecorationSet.create(doc, decorations);
      return this.addInner(doc, decorations, 0);
    }
  }, {
    key: "addInner",
    value: function addInner(doc, decorations, offset) {
      var _this10 = this;
      var children,
        childIndex = 0;
      doc.forEach(function (childNode, childOffset) {
        var baseOffset = childOffset + offset,
          found;
        if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) return;
        if (!children) children = _this10.children.slice();
        while (childIndex < children.length && children[childIndex] < childOffset) childIndex += 3;
        if (children[childIndex] == childOffset) children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);else children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));
        childIndex += 3;
      });
      var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
      for (var i = 0; i < local.length; i++) if (!local[i].type.valid(doc, local[i])) local.splice(i--, 1);
      return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
    }
    /**
    Create a new set that contains the decorations in this set, minus
    the ones in the given array.
    */
  }, {
    key: "remove",
    value: function remove(decorations) {
      if (decorations.length == 0 || this == empty) return this;
      return this.removeInner(decorations, 0);
    }
  }, {
    key: "removeInner",
    value: function removeInner(decorations, offset) {
      var children = this.children,
        local = this.local;
      for (var i = 0; i < children.length; i += 3) {
        var found = void 0;
        var from = children[i] + offset,
          to = children[i + 1] + offset;
        for (var j = 0, span; j < decorations.length; j++) if (span = decorations[j]) {
          if (span.from > from && span.to < to) {
            decorations[j] = null;
            (found || (found = [])).push(span);
          }
        }
        if (!found) continue;
        if (children == this.children) children = this.children.slice();
        var removed = children[i + 2].removeInner(found, from + 1);
        if (removed != empty) {
          children[i + 2] = removed;
        } else {
          children.splice(i, 3);
          i -= 3;
        }
      }
      if (local.length) for (var _i6 = 0, _span; _i6 < decorations.length; _i6++) if (_span = decorations[_i6]) {
        for (var _j2 = 0; _j2 < local.length; _j2++) if (local[_j2].eq(_span, offset)) {
          if (local == this.local) local = this.local.slice();
          local.splice(_j2--, 1);
        }
      }
      if (children == this.children && local == this.local) return this;
      return local.length || children.length ? new DecorationSet(local, children) : empty;
    }
    /**
    @internal
    */
  }, {
    key: "forChild",
    value: function forChild(offset, node) {
      if (this == empty) return this;
      if (node.isLeaf) return DecorationSet.empty;
      var child, local;
      for (var i = 0; i < this.children.length; i += 3) if (this.children[i] >= offset) {
        if (this.children[i] == offset) child = this.children[i + 2];
        break;
      }
      var start = offset + 1,
        end = start + node.content.size;
      for (var _i7 = 0; _i7 < this.local.length; _i7++) {
        var dec = this.local[_i7];
        if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
          var from = Math.max(start, dec.from) - start,
            to = Math.min(end, dec.to) - start;
          if (from < to) (local || (local = [])).push(dec.copy(from, to));
        }
      }
      if (local) {
        var localSet = new DecorationSet(local.sort(byPos), none);
        return child ? new DecorationGroup([localSet, child]) : localSet;
      }
      return child || empty;
    }
    /**
    @internal
    */
  }, {
    key: "eq",
    value: function eq(other) {
      if (this == other) return true;
      if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length) return false;
      for (var i = 0; i < this.local.length; i++) if (!this.local[i].eq(other.local[i])) return false;
      for (var _i8 = 0; _i8 < this.children.length; _i8 += 3) if (this.children[_i8] != other.children[_i8] || this.children[_i8 + 1] != other.children[_i8 + 1] || !this.children[_i8 + 2].eq(other.children[_i8 + 2])) return false;
      return true;
    }
    /**
    @internal
    */
  }, {
    key: "locals",
    value: function locals(node) {
      return removeOverlap(this.localsInner(node));
    }
    /**
    @internal
    */
  }, {
    key: "localsInner",
    value: function localsInner(node) {
      if (this == empty) return none;
      if (node.inlineContent || !this.local.some(InlineType.is)) return this.local;
      var result = [];
      for (var i = 0; i < this.local.length; i++) {
        if (!(this.local[i].type instanceof InlineType)) result.push(this.local[i]);
      }
      return result;
    }
  }], [{
    key: "create",
    value: function create(doc, decorations) {
      return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty;
    }
  }]);
  return DecorationSet;
}();
/**
The empty set of decorations.
*/
DecorationSet.empty = new DecorationSet([], []);
/**
@internal
*/
DecorationSet.removeOverlap = removeOverlap;
var empty = DecorationSet.empty;
// An abstraction that allows the code dealing with decorations to
// treat multiple DecorationSet objects as if it were a single object
// with (a subset of) the same interface.
var DecorationGroup = /*#__PURE__*/function () {
  function DecorationGroup(members) {
    _classCallCheck(this, DecorationGroup);
    this.members = members;
  }
  _createClass(DecorationGroup, [{
    key: "map",
    value: function map(mapping, doc) {
      var mappedDecos = this.members.map(function (member) {
        return member.map(mapping, doc, noSpec);
      });
      return DecorationGroup.from(mappedDecos);
    }
  }, {
    key: "forChild",
    value: function forChild(offset, child) {
      if (child.isLeaf) return DecorationSet.empty;
      var found = [];
      for (var i = 0; i < this.members.length; i++) {
        var result = this.members[i].forChild(offset, child);
        if (result == empty) continue;
        if (result instanceof DecorationGroup) found = found.concat(result.members);else found.push(result);
      }
      return DecorationGroup.from(found);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      if (!(other instanceof DecorationGroup) || other.members.length != this.members.length) return false;
      for (var i = 0; i < this.members.length; i++) if (!this.members[i].eq(other.members[i])) return false;
      return true;
    }
  }, {
    key: "locals",
    value: function locals(node) {
      var result,
        sorted = true;
      for (var i = 0; i < this.members.length; i++) {
        var locals = this.members[i].localsInner(node);
        if (!locals.length) continue;
        if (!result) {
          result = locals;
        } else {
          if (sorted) {
            result = result.slice();
            sorted = false;
          }
          for (var j = 0; j < locals.length; j++) result.push(locals[j]);
        }
      }
      return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
    }
    // Create a group for the given array of decoration sets, or return
    // a single set when possible.
  }], [{
    key: "from",
    value: function from(members) {
      switch (members.length) {
        case 0:
          return empty;
        case 1:
          return members[0];
        default:
          return new DecorationGroup(members.every(function (m) {
            return m instanceof DecorationSet;
          }) ? members : members.reduce(function (r, m) {
            return r.concat(m instanceof DecorationSet ? m : m.members);
          }, []));
      }
    }
  }]);
  return DecorationGroup;
}();
function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {
  var children = oldChildren.slice();
  // Mark the children that are directly touched by changes, and
  // move those that are after the changes.
  var _loop4 = function _loop4(_baseOffset) {
    var moved = 0;
    mapping.maps[i].forEach(function (oldStart, oldEnd, newStart, newEnd) {
      var dSize = newEnd - newStart - (oldEnd - oldStart);
      for (var _i12 = 0; _i12 < children.length; _i12 += 3) {
        var end = children[_i12 + 1];
        if (end < 0 || oldStart > end + _baseOffset - moved) continue;
        var start = children[_i12] + _baseOffset - moved;
        if (oldEnd >= start) {
          children[_i12 + 1] = oldStart <= start ? -2 : -1;
        } else if (oldStart >= _baseOffset && dSize) {
          children[_i12] += dSize;
          children[_i12 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    _baseOffset = mapping.maps[i].map(_baseOffset, -1);
    baseOffset = _baseOffset;
  };
  for (var i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
    _loop4(baseOffset);
  }
  // Find the child nodes that still correspond to a single node,
  // recursively call mapInner on them and update their positions.
  var mustRebuild = false;
  for (var _i9 = 0; _i9 < children.length; _i9 += 3) if (children[_i9 + 1] < 0) {
    // Touched nodes
    if (children[_i9 + 1] == -2) {
      mustRebuild = true;
      children[_i9 + 1] = -1;
      continue;
    }
    var from = mapping.map(oldChildren[_i9] + oldOffset),
      fromLocal = from - offset;
    if (fromLocal < 0 || fromLocal >= node.content.size) {
      mustRebuild = true;
      continue;
    }
    // Must read oldChildren because children was tagged with -1
    var to = mapping.map(oldChildren[_i9 + 1] + oldOffset, -1),
      toLocal = to - offset;
    var _node$content$findInd2 = node.content.findIndex(fromLocal),
      index = _node$content$findInd2.index,
      childOffset = _node$content$findInd2.offset;
    var childNode = node.maybeChild(index);
    if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
      var mapped = children[_i9 + 2].mapInner(mapping, childNode, from + 1, oldChildren[_i9] + oldOffset + 1, options);
      if (mapped != empty) {
        children[_i9] = fromLocal;
        children[_i9 + 1] = toLocal;
        children[_i9 + 2] = mapped;
      } else {
        children[_i9 + 1] = -2;
        mustRebuild = true;
      }
    } else {
      mustRebuild = true;
    }
  }
  // Remaining children must be collected and rebuilt into the appropriate structure
  if (mustRebuild) {
    var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);
    var built = buildTree(decorations, node, 0, options);
    newLocal = built.local;
    for (var _i10 = 0; _i10 < children.length; _i10 += 3) if (children[_i10 + 1] < 0) {
      children.splice(_i10, 3);
      _i10 -= 3;
    }
    for (var _i11 = 0, j = 0; _i11 < built.children.length; _i11 += 3) {
      var _from2 = built.children[_i11];
      while (j < children.length && children[j] < _from2) j += 3;
      children.splice(j, 0, built.children[_i11], built.children[_i11 + 1], built.children[_i11 + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset) {
  if (!offset || !spans.length) return spans;
  var result = [];
  for (var i = 0; i < spans.length; i++) {
    var span = spans[i];
    result.push(new Decoration(span.from + offset, span.to + offset, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
  // Gather all decorations from the remaining marked children
  function gather(set, oldOffset) {
    for (var i = 0; i < set.local.length; i++) {
      var mapped = set.local[i].map(mapping, offset, oldOffset);
      if (mapped) decorations.push(mapped);else if (options.onRemove) options.onRemove(set.local[i].spec);
    }
    for (var _i13 = 0; _i13 < set.children.length; _i13 += 3) gather(set.children[_i13 + 2], set.children[_i13] + oldOffset + 1);
  }
  for (var i = 0; i < children.length; i += 3) if (children[i + 1] == -1) gather(children[i + 2], oldChildren[i] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset) {
  if (node.isLeaf) return null;
  var end = offset + node.nodeSize,
    found = null;
  for (var i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset && span.to < end) {
      (found || (found = [])).push(span);
      spans[i] = null;
    }
  }
  return found;
}
function withoutNulls(array) {
  var result = [];
  for (var i = 0; i < array.length; i++) if (array[i] != null) result.push(array[i]);
  return result;
}
// Build up a tree that corresponds to a set of decorations. `offset`
// is a base offset that should be subtracted from the `from` and `to`
// positions in the spans (so that we don't have to allocate new spans
// for recursive calls).
function buildTree(spans, node, offset, options) {
  var children = [],
    hasNulls = false;
  node.forEach(function (childNode, localStart) {
    var found = takeSpansForNode(spans, childNode, localStart + offset);
    if (found) {
      hasNulls = true;
      var subtree = buildTree(found, childNode, offset + localStart + 1, options);
      if (subtree != empty) children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
  for (var i = 0; i < locals.length; i++) if (!locals[i].type.valid(node, locals[i])) {
    if (options.onRemove) options.onRemove(locals[i].spec);
    locals.splice(i--, 1);
  }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
// Used to sort decorations so that ones with a low start position
// come first, and within a set with the same start position, those
// with an smaller end position come first.
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
// Scan a sorted array of decorations for partially overlapping spans,
// and split those so that only fully overlapping spans are left (to
// make subsequent rendering easier). Will return the input array if
// no partially overlapping spans are found (the common case).
function removeOverlap(spans) {
  var working = spans;
  for (var i = 0; i < working.length - 1; i++) {
    var span = working[i];
    if (span.from != span.to) for (var j = i + 1; j < working.length; j++) {
      var next = working[j];
      if (next.from == span.from) {
        if (next.to != span.to) {
          if (working == spans) working = spans.slice();
          // Followed by a partially overlapping larger span. Split that
          // span.
          working[j] = next.copy(next.from, span.to);
          insertAhead(working, j + 1, next.copy(span.to, next.to));
        }
        continue;
      } else {
        if (next.from < span.to) {
          if (working == spans) working = spans.slice();
          // The end of this one overlaps with a subsequent span. Split
          // this one.
          working[i] = span.copy(span.from, next.from);
          insertAhead(working, j, span.copy(next.from, span.to));
        }
        break;
      }
    }
  }
  return working;
}
function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0) i++;
  array.splice(i, 0, deco);
}
// Get the decorations associated with the current props of a view.
function viewDecorations(view) {
  var found = [];
  view.someProp("decorations", function (f) {
    var result = f(view.state);
    if (result && result != empty) found.push(result);
  });
  if (view.cursorWrapper) found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found);
}
var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified
var useCharData = ie && ie_version <= 11;
var SelectionState = /*#__PURE__*/function () {
  function SelectionState() {
    _classCallCheck(this, SelectionState);
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  _createClass(SelectionState, [{
    key: "set",
    value: function set(sel) {
      this.anchorNode = sel.anchorNode;
      this.anchorOffset = sel.anchorOffset;
      this.focusNode = sel.focusNode;
      this.focusOffset = sel.focusOffset;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.anchorNode = this.focusNode = null;
    }
  }, {
    key: "eq",
    value: function eq(sel) {
      return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
    }
  }]);
  return SelectionState;
}();
var DOMObserver = /*#__PURE__*/function () {
  function DOMObserver(view, handleDOMChange) {
    var _this11 = this;
    _classCallCheck(this, DOMObserver);
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.observer = window.MutationObserver && new window.MutationObserver(function (mutations) {
      for (var i = 0; i < mutations.length; i++) _this11.queue.push(mutations[i]);
      // IE11 will sometimes (on backspacing out a single character
      // text node after a BR node) call the observer callback
      // before actually updating the DOM, which will cause
      // ProseMirror to miss the change (see #930)
      if (ie && ie_version <= 11 && mutations.some(function (m) {
        return m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length;
      })) _this11.flushSoon();else _this11.flush();
    });
    if (useCharData) {
      this.onCharData = function (e) {
        _this11.queue.push({
          target: e.target,
          type: "characterData",
          oldValue: e.prevValue
        });
        _this11.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  _createClass(DOMObserver, [{
    key: "flushSoon",
    value: function flushSoon() {
      var _this12 = this;
      if (this.flushingSoon < 0) this.flushingSoon = window.setTimeout(function () {
        _this12.flushingSoon = -1;
        _this12.flush();
      }, 20);
    }
  }, {
    key: "forceFlush",
    value: function forceFlush() {
      if (this.flushingSoon > -1) {
        window.clearTimeout(this.flushingSoon);
        this.flushingSoon = -1;
        this.flush();
      }
    }
  }, {
    key: "start",
    value: function start() {
      if (this.observer) {
        this.observer.takeRecords();
        this.observer.observe(this.view.dom, observeOptions);
      }
      if (this.onCharData) this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.connectSelection();
    }
  }, {
    key: "stop",
    value: function stop() {
      var _this13 = this;
      if (this.observer) {
        var take = this.observer.takeRecords();
        if (take.length) {
          for (var i = 0; i < take.length; i++) this.queue.push(take[i]);
          window.setTimeout(function () {
            return _this13.flush();
          }, 20);
        }
        this.observer.disconnect();
      }
      if (this.onCharData) this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
      this.disconnectSelection();
    }
  }, {
    key: "connectSelection",
    value: function connectSelection() {
      this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    }
  }, {
    key: "disconnectSelection",
    value: function disconnectSelection() {
      this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    }
  }, {
    key: "suppressSelectionUpdates",
    value: function suppressSelectionUpdates() {
      var _this14 = this;
      this.suppressingSelectionUpdates = true;
      setTimeout(function () {
        return _this14.suppressingSelectionUpdates = false;
      }, 50);
    }
  }, {
    key: "onSelectionChange",
    value: function onSelectionChange() {
      if (!hasFocusAndSelection(this.view)) return;
      if (this.suppressingSelectionUpdates) return selectionToDOM(this.view);
      // Deletions on IE11 fire their events in the wrong order, giving
      // us a selection change event before the DOM changes are
      // reported.
      if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
        var sel = this.view.domSelectionRange();
        // Selection.isCollapsed isn't reliable on IE
        if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) return this.flushSoon();
      }
      this.flush();
    }
  }, {
    key: "setCurSelection",
    value: function setCurSelection() {
      this.currentSelection.set(this.view.domSelectionRange());
    }
  }, {
    key: "ignoreSelectionChange",
    value: function ignoreSelectionChange(sel) {
      if (!sel.focusNode) return true;
      var ancestors = new Set(),
        container;
      for (var scan = sel.focusNode; scan; scan = parentNode(scan)) ancestors.add(scan);
      for (var _scan = sel.anchorNode; _scan; _scan = parentNode(_scan)) if (ancestors.has(_scan)) {
        container = _scan;
        break;
      }
      var desc = container && this.view.docView.nearestDesc(container);
      if (desc && desc.ignoreMutation({
        type: "selection",
        target: container.nodeType == 3 ? container.parentNode : container
      })) {
        this.setCurSelection();
        return true;
      }
    }
  }, {
    key: "pendingRecords",
    value: function pendingRecords() {
      if (this.observer) {
        var _iterator2 = _createForOfIteratorHelper(this.observer.takeRecords()),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var mut = _step2.value;
            this.queue.push(mut);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      return this.queue;
    }
  }, {
    key: "flush",
    value: function flush() {
      var view = this.view;
      if (!view.docView || this.flushingSoon > -1) return;
      var mutations = this.pendingRecords();
      if (mutations.length) this.queue = [];
      var sel = view.domSelectionRange();
      var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
      var from = -1,
        to = -1,
        typeOver = false,
        added = [];
      if (view.editable) {
        for (var i = 0; i < mutations.length; i++) {
          var result = this.registerMutation(mutations[i], added);
          if (result) {
            from = from < 0 ? result.from : Math.min(result.from, from);
            to = to < 0 ? result.to : Math.max(result.to, to);
            if (result.typeOver) typeOver = true;
          }
        }
      }
      if (gecko && added.length > 1) {
        var brs = added.filter(function (n) {
          return n.nodeName == "BR";
        });
        if (brs.length == 2) {
          var a = brs[0],
            b = brs[1];
          if (a.parentNode && a.parentNode.parentNode == b.parentNode) b.remove();else a.remove();
        }
      }
      var readSel = null;
      // If it looks like the browser has reset the selection to the
      // start of the document after focus, restore the selection from
      // the state
      if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(view.state.doc.resolve(0), 1))) {
        view.input.lastFocus = 0;
        selectionToDOM(view);
        this.currentSelection.set(sel);
        view.scrollToSelection();
      } else if (from > -1 || newSel) {
        if (from > -1) {
          view.docView.markDirty(from, to);
          checkCSS(view);
        }
        this.handleDOMChange(from, to, typeOver, added);
        if (view.docView && view.docView.dirty) view.updateState(view.state);else if (!this.currentSelection.eq(sel)) selectionToDOM(view);
        this.currentSelection.set(sel);
      }
    }
  }, {
    key: "registerMutation",
    value: function registerMutation(mut, added) {
      // Ignore mutations inside nodes that were already noted as inserted
      if (added.indexOf(mut.target) > -1) return null;
      var desc = this.view.docView.nearestDesc(mut.target);
      if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" ||
      // Firefox sometimes fires spurious events for null/empty styles
      mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))) return null;
      if (!desc || desc.ignoreMutation(mut)) return null;
      if (mut.type == "childList") {
        for (var i = 0; i < mut.addedNodes.length; i++) added.push(mut.addedNodes[i]);
        if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) return {
          from: desc.posBefore,
          to: desc.posAfter
        };
        var prev = mut.previousSibling,
          next = mut.nextSibling;
        if (ie && ie_version <= 11 && mut.addedNodes.length) {
          // IE11 gives us incorrect next/prev siblings for some
          // insertions, so if there are added nodes, recompute those
          for (var _i14 = 0; _i14 < mut.addedNodes.length; _i14++) {
            var _mut$addedNodes$_i = mut.addedNodes[_i14],
              previousSibling = _mut$addedNodes$_i.previousSibling,
              nextSibling = _mut$addedNodes$_i.nextSibling;
            if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) prev = previousSibling;
            if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) next = nextSibling;
          }
        }
        var fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
        var from = desc.localPosFromDOM(mut.target, fromOffset, -1);
        var toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
        var to = desc.localPosFromDOM(mut.target, toOffset, 1);
        return {
          from: from,
          to: to
        };
      } else if (mut.type == "attributes") {
        return {
          from: desc.posAtStart - desc.border,
          to: desc.posAtEnd + desc.border
        };
      } else {
        // "characterData"
        return {
          from: desc.posAtStart,
          to: desc.posAtEnd,
          // An event was generated for a text change that didn't change
          // any text. Mark the dom change to fall back to assuming the
          // selection was typed over with an identical value if it can't
          // find another change.
          typeOver: mut.target.nodeValue == mut.oldValue
        };
      }
    }
  }]);
  return DOMObserver;
}();
var cssChecked = new WeakMap();
var cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view)) return;
  cssChecked.set(view, null);
  if (['normal', 'nowrap', 'pre-line'].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned) return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
// Used to work around a Safari Selection/shadow DOM bug
// Based on https://github.com/codemirror/dev/issues/414 fix
function safariShadowSelectionRange(view) {
  var found;
  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found = event.getTargetRanges()[0];
  }
  // Because Safari (at least in 2018-2022) doesn't provide regular
  // access to the selection inside a shadowRoot, we have to perform a
  // ridiculous hack to get at itusing `execCommand` to trigger a
  // `beforeInput` event so that we can read the target range from the
  // event.
  view.dom.addEventListener("beforeinput", read, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read, true);
  var anchorNode = found.startContainer,
    anchorOffset = found.startOffset;
  var focusNode = found.endContainer,
    focusOffset = found.endOffset;
  var currentAnchor = view.domAtPos(view.state.selection.anchor);
  // Since such a range doesn't distinguish between anchor and head,
  // use a heuristic that flips it around if its end matches the
  // current anchor.
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset)) {
    var _ref3 = [focusNode, focusOffset, anchorNode, anchorOffset];
    anchorNode = _ref3[0];
    anchorOffset = _ref3[1];
    focusNode = _ref3[2];
    focusOffset = _ref3[3];
  }
  return {
    anchorNode: anchorNode,
    anchorOffset: anchorOffset,
    focusNode: focusNode,
    focusOffset: focusOffset
  };
}

// Note that all referencing and parsing is done with the
// start-of-operation selection and document, since that's the one
// that the DOM represents. If any changes came in in the meantime,
// the modification is mapped over those before it is applied, in
// readDOMChange.
function parseBetween(view, from_, to_) {
  var _view$docView$parseRa = view.docView.parseRange(from_, to_),
    parent = _view$docView$parseRa.node,
    fromOffset = _view$docView$parseRa.fromOffset,
    toOffset = _view$docView$parseRa.toOffset,
    from = _view$docView$parseRa.from,
    to = _view$docView$parseRa.to;
  var domSel = view.domSelectionRange();
  var find;
  var anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find = [{
      node: anchor,
      offset: domSel.anchorOffset
    }];
    if (!selectionCollapsed(domSel)) find.push({
      node: domSel.focusNode,
      offset: domSel.focusOffset
    });
  }
  // Work around issue in Chrome where backspacing sometimes replaces
  // the deleted content with a random BR node (issues #799, #831)
  if (chrome && view.input.lastKeyCode === 8) {
    for (var off = toOffset; off > fromOffset; off--) {
      var node = parent.childNodes[off - 1],
        desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size) break;
    }
  }
  var startDoc = view.state.doc;
  var parser = view.someProp("domParser") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);
  var $from = startDoc.resolve(from);
  var sel = null,
    doc = parser.parse(parent, {
      topNode: $from.parent,
      topMatch: $from.parent.contentMatchAt($from.index()),
      topOpen: true,
      from: fromOffset,
      to: toOffset,
      preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
      findPositions: find,
      ruleFromNode: ruleFromNode,
      context: $from
    });
  if (find && find[0].pos != null) {
    var _anchor = find[0].pos,
      head = find[1] && find[1].pos;
    if (head == null) head = _anchor;
    sel = {
      anchor: _anchor + from,
      head: head + from
    };
  }
  return {
    doc: doc,
    sel: sel,
    from: from,
    to: to
  };
}
function ruleFromNode(dom) {
  var desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    // Safari replaces the list item or table cell with a BR
    // directly in the list node (?!) if you delete the last
    // character in a list item or table cell (#708, #862)
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      var skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return {
        skip: skip
      };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return {
        ignore: true
      };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return {
      ignore: true
    };
  }
  return null;
}
var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from, to, typeOver, addedNodes) {
  var compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from < 0) {
    var origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    var newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", function (f) {
        return f(view, keyEvent(13, "Enter"));
      })) return;
      var _tr = view.state.tr.setSelection(newSel);
      if (origin == "pointer") _tr.setMeta("pointer", true);else if (origin == "key") _tr.scrollIntoView();
      if (compositionID) _tr.setMeta("composition", compositionID);
      view.dispatch(_tr);
    }
    return;
  }
  var $before = view.state.doc.resolve(from);
  var shared = $before.sharedDepth(to);
  from = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  var sel = view.state.selection;
  var parse = parseBetween(view, from, to);
  var doc = view.state.doc,
    compare = doc.slice(parse.from, parse.to);
  var preferredPos, preferredSide;
  // Prefer anchoring to end when Backspace is pressed
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  var change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some(function (n) {
    return n.nodeType == 1 && !isInline.test(n.nodeName);
  }) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", function (f) {
    return f(view, keyEvent(13, "Enter"));
  })) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = {
        start: sel.from,
        endA: sel.to,
        endB: sel.to
      };
    } else {
      if (parse.sel) {
        var _sel = resolveSelection(view, view.state.doc, parse.sel);
        if (_sel && !_sel.eq(view.state.selection)) {
          var _tr2 = view.state.tr.setSelection(_sel);
          if (compositionID) _tr2.setMeta("composition", compositionID);
          view.dispatch(_tr2);
        }
      }
      return;
    }
  }
  // Chrome sometimes leaves the cursor before the inserted text when
  // composing after a cursor wrapper. This moves it forward.
  if (chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from && parse.sel.head == parse.sel.anchor) {
    var size = change.endB - change.start;
    parse.sel = {
      anchor: parse.sel.anchor + size,
      head: parse.sel.anchor + size
    };
  }
  view.input.domChangeCount++;
  // Handle the case where overwriting a selection by typing matches
  // the start or end of the selected content, creating a change
  // that's smaller than what was actually overwritten.
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  // IE11 will insert a non-breaking space _ahead_ of the space after
  // the cursor space when adding a space before another space. When
  // that happened, adjust the change to cover the space instead.
  if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \xA0") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  var $from = parse.doc.resolveNoCache(change.start - parse.from);
  var $to = parse.doc.resolveNoCache(change.endB - parse.from);
  var $fromA = doc.resolve(change.start);
  var inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  var nextSel;
  // If this looks like the effect of pressing Enter (or was recorded
  // as being an iOS enter press), just dispatch an Enter key instead.
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some(function (n) {
    return n.nodeName == "DIV" || n.nodeName == "P";
  })) || !inlineChange && $from.pos < parse.doc.content.size && !$from.sameParent($to) && (nextSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", function (f) {
    return f(view, keyEvent(13, "Enter"));
  })) {
    view.input.lastIOSEnter = 0;
    return;
  }
  // Same for backspace
  if (view.state.selection.anchor > change.start && looksLikeJoin(doc, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", function (f) {
    return f(view, keyEvent(8, "Backspace"));
  })) {
    if (android && chrome) view.domObserver.suppressSelectionUpdates(); // #820
    return;
  }
  // Chrome Android will occasionally, during composition, delete the
  // entire composition and then immediately insert it again. This is
  // used to detect that situation.
  if (chrome && android && change.endB == change.start) view.input.lastAndroidDelete = Date.now();
  // This tries to detect Android virtual keyboard
  // enter-and-pick-suggestion action. That sometimes (see issue
  // #1059) first fires a DOM mutation, before moving the selection to
  // the newly created block. And then, because ProseMirror cleans up
  // the DOM selection, it gives up moving the selection entirely,
  // leaving the cursor in the wrong place. When that happens, we drop
  // the new paragraph from the initial change, and fire a simulated
  // enter key afterwards.
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(function () {
      view.someProp("handleKeyDown", function (f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  var chFrom = change.start,
    chTo = change.endA;
  var tr, storedMarks, markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      // Deletion
      // IE11 sometimes weirdly moves the DOM selection around after
      // backspacing out the first element in a textblock
      if (ie && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(function () {
          return selectionToDOM(view);
        }, 20);
      }
      tr = view.state.tr["delete"](chFrom, chTo);
      storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));
    } else if (
    // Adding or removing a mark
    change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {
      tr = view.state.tr;
      if (markChange.type == "add") tr.addMark(chFrom, chTo, markChange.mark);else tr.removeMark(chFrom, chTo, markChange.mark);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      // Both positions in the same text node -- simply insert text
      var text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", function (f) {
        return f(view, chFrom, chTo, text);
      })) return;
      tr = view.state.tr.insertText(text, chFrom, chTo);
    }
  }
  if (!tr) tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
  if (parse.sel) {
    var _sel2 = resolveSelection(view, tr.doc, parse.sel);
    // Chrome Android will sometimes, during composition, report the
    // selection in the wrong place. If it looks like that is
    // happening, don't update the selection.
    // Edge just doesn't move the cursor forward when you start typing
    // in an empty block or between br nodes.
    if (_sel2 && !(chrome && android && view.composing && _sel2.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (_sel2.head == chFrom || _sel2.head == tr.mapping.map(chTo) - 1) || ie && _sel2.empty && _sel2.head == chFrom)) tr.setSelection(_sel2);
  }
  if (storedMarks) tr.ensureMarks(storedMarks);
  if (compositionID) tr.setMeta("composition", compositionID);
  view.dispatch(tr.scrollIntoView());
}
function resolveSelection(view, doc, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) return null;
  return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head));
}
// Given two same-length, non-empty fragments of inline content,
// determine whether the first could be created from the second by
// removing or adding a single mark type.
function isMarkChange(cur, prev) {
  var curMarks = cur.firstChild.marks,
    prevMarks = prev.firstChild.marks;
  var added = curMarks,
    removed = prevMarks,
    type,
    mark,
    update;
  for (var i = 0; i < prevMarks.length; i++) added = prevMarks[i].removeFromSet(added);
  for (var _i15 = 0; _i15 < curMarks.length; _i15++) removed = curMarks[_i15].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update = function update(node) {
      return node.mark(mark.addToSet(node.marks));
    };
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update = function update(node) {
      return node.mark(mark.removeFromSet(node.marks));
    };
  } else {
    return null;
  }
  var updated = [];
  for (var _i16 = 0; _i16 < prev.childCount; _i16++) updated.push(update(prev.child(_i16)));
  if (prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated).eq(cur)) return {
    mark: mark,
    type: type
  };
}
function looksLikeJoin(old, start, end, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock ||
  // The content must have shrunk
  end - start <= $newEnd.pos - $newStart.pos ||
  // newEnd must point directly at or after the end of the block that newStart points into
  skipClosingAndOpening($newStart, true, false) < $newEnd.pos) return false;
  var $start = old.resolve(start);
  // Start must be at the end of a block
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) return false;
  var $next = old.resolve(skipClosingAndOpening($start, true, true));
  // The next textblock must start before end and end near it
  if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end) return false;
  // The fragments after the join point must match
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  var depth = $pos.depth,
    end = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end++;
    fromEnd = false;
  }
  if (mayOpen) {
    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end++;
    }
  }
  return end;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  var start = a.findDiffStart(b, pos);
  if (start == null) return null;
  var _a$findDiffEnd = a.findDiffEnd(b, pos + a.size, pos + b.size),
    endA = _a$findDiffEnd.a,
    endB = _a$findDiffEnd.b;
  if (preferredSide == "end") {
    var adjust = Math.max(0, start - Math.min(endA, endB));
    preferredPos -= endA + adjust - start;
  }
  if (endA < start && a.size < b.size) {
    var move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
    start -= move;
    if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1))) start += move ? 1 : -1;
    endB = start + (endB - endA);
    endA = start;
  } else if (endB < start) {
    var _move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
    start -= _move;
    if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1))) start += _move ? 1 : -1;
    endA = start + (endA - endB);
    endB = start;
  }
  return {
    start: start,
    endA: endA,
    endB: endB
  };
}
function isSurrogatePair(str) {
  if (str.length != 2) return false;
  var a = str.charCodeAt(0),
    b = str.charCodeAt(1);
  return a >= 0xDC00 && a <= 0xDFFF && b >= 0xD800 && b <= 0xDBFF;
}

/**
@internal
*/
var __serializeForClipboard = serializeForClipboard;
/**
@internal
*/
var __parseFromClipboard = parseFromClipboard;
/**
@internal
*/
var __endComposition = endComposition;
/**
An editor view manages the DOM structure that represents an
editable document. Its state and behavior are determined by its
[props](https://prosemirror.net/docs/ref/#view.DirectEditorProps).
*/
var EditorView = /*#__PURE__*/function () {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  function EditorView(place, props) {
    var _this15 = this;
    _classCallCheck(this, EditorView);
    this._root = null;
    /**
    @internal
    */
    this.focused = false;
    /**
    Kludge used to work around a Chrome bug @internal
    */
    this.trackWrites = null;
    this.mounted = false;
    /**
    @internal
    */
    this.markCursor = null;
    /**
    @internal
    */
    this.cursorWrapper = null;
    /**
    @internal
    */
    this.lastSelectedViewDesc = undefined;
    /**
    @internal
    */
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    /**
    Holds `true` when a hack node is needed in Firefox to prevent the
    [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)
    @internal
    */
    this.requiresGeckoHackNode = false;
    /**
    When editor content is being dragged, this object contains
    information about the dragged slice and whether it is being
    copied or moved. At any other time, it is null.
    */
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild) place.appendChild(this.dom);else if (typeof place == "function") place(this.dom);else if (place.mount) this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, function (from, to, typeOver, added) {
      return readDOMChange(_this15, from, to, typeOver, added);
    });
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  _createClass(EditorView, [{
    key: "composing",
    get: function get() {
      return this.input.composing;
    }
    /**
    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
    */
  }, {
    key: "props",
    get: function get() {
      if (this._props.state != this.state) {
        var prev = this._props;
        this._props = {};
        for (var name in prev) this._props[name] = prev[name];
        this._props.state = this.state;
      }
      return this._props;
    }
    /**
    Update the view's props. Will immediately cause an update to
    the DOM.
    */
  }, {
    key: "update",
    value: function update(props) {
      if (props.handleDOMEvents != this._props.handleDOMEvents) ensureListeners(this);
      var prevProps = this._props;
      this._props = props;
      if (props.plugins) {
        props.plugins.forEach(checkStateComponent);
        this.directPlugins = props.plugins;
      }
      this.updateStateInner(props.state, prevProps);
    }
    /**
    Update the view by updating existing props object with the object
    given as argument. Equivalent to `view.update(Object.assign({},
    view.props, props))`.
    */
  }, {
    key: "setProps",
    value: function setProps(props) {
      var updated = {};
      for (var name in this._props) updated[name] = this._props[name];
      updated.state = this.state;
      for (var _name2 in props) updated[_name2] = props[_name2];
      this.update(updated);
    }
    /**
    Update the editor's `state` prop, without touching any of the
    other props.
    */
  }, {
    key: "updateState",
    value: function updateState(state) {
      this.updateStateInner(state, this._props);
    }
  }, {
    key: "updateStateInner",
    value: function updateStateInner(state, prevProps) {
      var _a;
      var prev = this.state,
        redraw = false,
        updateSel = false;
      // When stored marks are added, stop composition, so that they can
      // be displayed.
      if (state.storedMarks && this.composing) {
        clearComposition(this);
        updateSel = true;
      }
      this.state = state;
      var pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
      if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
        var nodeViews = buildNodeViews(this);
        if (changedNodeViews(nodeViews, this.nodeViews)) {
          this.nodeViews = nodeViews;
          redraw = true;
        }
      }
      if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
        ensureListeners(this);
      }
      this.editable = getEditable(this);
      updateCursorWrapper(this);
      var innerDeco = viewDecorations(this),
        outerDeco = computeDocDeco(this);
      var scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
      var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
      if (updateDoc || !state.selection.eq(prev.selection)) updateSel = true;
      var oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
      if (updateSel) {
        this.domObserver.stop();
        // Work around an issue in Chrome, IE, and Edge where changing
        // the DOM around an active selection puts it into a broken
        // state where the thing the user sees differs from the
        // selection reported by the Selection object (#710, #973,
        // #1011, #1013, #1035).
        var forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
        if (updateDoc) {
          // If the node that the selection points into is written to,
          // Chrome sometimes starts misreporting the selection, so this
          // tracks that and forces a selection reset when our update
          // did write to the node.
          var chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
          if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
            this.docView.updateOuterDeco([]);
            this.docView.destroy();
            this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
          }
          if (chromeKludge && !this.trackWrites) forceSelUpdate = true;
        }
        // Work around for an issue where an update arriving right between
        // a DOM selection change and the "selectionchange" event for it
        // can cause a spurious DOM selection update, disrupting mouse
        // drag selection.
        if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
          selectionToDOM(this, forceSelUpdate);
        } else {
          syncNodeSelection(this, state.selection);
          this.domObserver.setCurSelection();
        }
        this.domObserver.start();
      }
      this.updatePluginViews(prev);
      if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc)) this.updateDraggedNode(this.dragging, prev);
      if (scroll == "reset") {
        this.dom.scrollTop = 0;
      } else if (scroll == "to selection") {
        this.scrollToSelection();
      } else if (oldScrollPos) {
        resetScrollPos(oldScrollPos);
      }
    }
    /**
    @internal
    */
  }, {
    key: "scrollToSelection",
    value: function scrollToSelection() {
      var _this16 = this;
      var startDOM = this.domSelectionRange().focusNode;
      if (this.someProp("handleScrollToSelection", function (f) {
        return f(_this16);
      })) ;else if (this.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {
        var target = this.docView.domAfterPos(this.state.selection.from);
        if (target.nodeType == 1) scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
      } else {
        scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
      }
    }
  }, {
    key: "destroyPluginViews",
    value: function destroyPluginViews() {
      var view;
      while (view = this.pluginViews.pop()) if (view.destroy) view.destroy();
    }
  }, {
    key: "updatePluginViews",
    value: function updatePluginViews(prevState) {
      if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
        this.prevDirectPlugins = this.directPlugins;
        this.destroyPluginViews();
        for (var i = 0; i < this.directPlugins.length; i++) {
          var plugin = this.directPlugins[i];
          if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this));
        }
        for (var _i17 = 0; _i17 < this.state.plugins.length; _i17++) {
          var _plugin = this.state.plugins[_i17];
          if (_plugin.spec.view) this.pluginViews.push(_plugin.spec.view(this));
        }
      } else {
        for (var _i18 = 0; _i18 < this.pluginViews.length; _i18++) {
          var pluginView = this.pluginViews[_i18];
          if (pluginView.update) pluginView.update(this, prevState);
        }
      }
    }
  }, {
    key: "updateDraggedNode",
    value: function updateDraggedNode(dragging, prev) {
      var sel = dragging.node,
        found = -1;
      if (this.state.doc.nodeAt(sel.from) == sel.node) {
        found = sel.from;
      } else {
        var movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
        var moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
        if (moved == sel.node) found = movedPos;
      }
      this.dragging = new Dragging(dragging.slice, dragging.move, found < 0 ? undefined : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(this.state.doc, found));
    }
  }, {
    key: "someProp",
    value: function someProp(propName, f) {
      var prop = this._props && this._props[propName],
        value;
      if (prop != null && (value = f ? f(prop) : prop)) return value;
      for (var i = 0; i < this.directPlugins.length; i++) {
        var _prop = this.directPlugins[i].props[propName];
        if (_prop != null && (value = f ? f(_prop) : _prop)) return value;
      }
      var plugins = this.state.plugins;
      if (plugins) for (var _i19 = 0; _i19 < plugins.length; _i19++) {
        var _prop2 = plugins[_i19].props[propName];
        if (_prop2 != null && (value = f ? f(_prop2) : _prop2)) return value;
      }
    }
    /**
    Query whether the view has focus.
    */
  }, {
    key: "hasFocus",
    value: function hasFocus() {
      // Work around IE not handling focus correctly if resize handles are shown.
      // If the cursor is inside an element with resize handles, activeElement
      // will be that element instead of this.dom.
      if (ie) {
        // If activeElement is within this.dom, and there are no other elements
        // setting `contenteditable` to false in between, treat it as focused.
        var node = this.root.activeElement;
        if (node == this.dom) return true;
        if (!node || !this.dom.contains(node)) return false;
        while (node && this.dom != node && this.dom.contains(node)) {
          if (node.contentEditable == 'false') return false;
          node = node.parentElement;
        }
        return true;
      }
      return this.root.activeElement == this.dom;
    }
    /**
    Focus the editor.
    */
  }, {
    key: "focus",
    value: function focus() {
      this.domObserver.stop();
      if (this.editable) focusPreventScroll(this.dom);
      selectionToDOM(this);
      this.domObserver.start();
    }
    /**
    Get the document root in which the editor exists. This will
    usually be the top-level `document`, but might be a [shadow
    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
    root if the editor is inside one.
    */
  }, {
    key: "root",
    get: function get() {
      var _this17 = this;
      var cached = this._root;
      if (cached == null) {
        var _loop5 = function _loop5(search) {
            if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
              if (!search.getSelection) Object.getPrototypeOf(search).getSelection = function () {
                return search.ownerDocument.getSelection();
              };
              return {
                v: _this17._root = search
              };
            }
          },
          _ret3;
        for (var search = this.dom.parentNode; search; search = search.parentNode) {
          _ret3 = _loop5(search);
          if (_ret3) return _ret3.v;
        }
      }
      return cached || document;
    }
    /**
    When an existing editor view is moved to a new document or
    shadow tree, call this to make it recompute its root.
    */
  }, {
    key: "updateRoot",
    value: function updateRoot() {
      this._root = null;
    }
    /**
    Given a pair of viewport coordinates, return the document
    position that corresponds to them. May return null if the given
    coordinates aren't inside of the editor. When an object is
    returned, its `pos` property is the position nearest to the
    coordinates, and its `inside` property holds the position of the
    inner node that the position falls inside of, or -1 if it is at
    the top level, not in any node.
    */
  }, {
    key: "posAtCoords",
    value: function posAtCoords(coords) {
      return _posAtCoords(this, coords);
    }
    /**
    Returns the viewport rectangle at a given document position.
    `left` and `right` will be the same number, as this returns a
    flat cursor-ish rectangle. If the position is between two things
    that aren't directly adjacent, `side` determines which element
    is used. When < 0, the element before the position is used,
    otherwise the element after.
    */
  }, {
    key: "coordsAtPos",
    value: function coordsAtPos(pos) {
      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return _coordsAtPos(this, pos, side);
    }
    /**
    Find the DOM position that corresponds to the given document
    position. When `side` is negative, find the position as close as
    possible to the content before the position. When positive,
    prefer positions close to the content after the position. When
    zero, prefer as shallow a position as possible.
    
    Note that you should **not** mutate the editor's internal DOM,
    only inspect it (and even that is usually not necessary).
    */
  }, {
    key: "domAtPos",
    value: function domAtPos(pos) {
      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.docView.domFromPos(pos, side);
    }
    /**
    Find the DOM node that represents the document node after the
    given position. May return `null` when the position doesn't point
    in front of a node or if the node is inside an opaque node view.
    
    This is intended to be able to call things like
    `getBoundingClientRect` on that DOM node. Do **not** mutate the
    editor DOM directly, or add styling this way, since that will be
    immediately overriden by the editor as it redraws the node.
    */
  }, {
    key: "nodeDOM",
    value: function nodeDOM(pos) {
      var desc = this.docView.descAt(pos);
      return desc ? desc.nodeDOM : null;
    }
    /**
    Find the document position that corresponds to a given DOM
    position. (Whenever possible, it is preferable to inspect the
    document structure directly, rather than poking around in the
    DOM, but sometimesfor example when interpreting an event
    targetyou don't have a choice.)
    
    The `bias` parameter can be used to influence which side of a DOM
    node to use when the position is inside a leaf node.
    */
  }, {
    key: "posAtDOM",
    value: function posAtDOM(node, offset) {
      var bias = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      var pos = this.docView.posFromDOM(node, offset, bias);
      if (pos == null) throw new RangeError("DOM position not inside the editor");
      return pos;
    }
    /**
    Find out whether the selection is at the end of a textblock when
    moving in a given direction. When, for example, given `"left"`,
    it will return true if moving left from the current cursor
    position would leave that position's parent textblock. Will apply
    to the view's current state by default, but it is possible to
    pass a different state.
    */
  }, {
    key: "endOfTextblock",
    value: function endOfTextblock(dir, state) {
      return _endOfTextblock(this, state || this.state, dir);
    }
    /**
    Run the editor's paste logic with the given HTML string. The
    `event`, if given, will be passed to the
    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
    */
  }, {
    key: "pasteHTML",
    value: function pasteHTML(html, event) {
      return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
    }
    /**
    Run the editor's paste logic with the given plain-text input.
    */
  }, {
    key: "pasteText",
    value: function pasteText(text, event) {
      return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
    }
    /**
    Removes the editor from the DOM and destroys all [node
    views](https://prosemirror.net/docs/ref/#view.NodeView).
    */
  }, {
    key: "destroy",
    value: function destroy() {
      if (!this.docView) return;
      destroyInput(this);
      this.destroyPluginViews();
      if (this.mounted) {
        this.docView.update(this.state.doc, [], viewDecorations(this), this);
        this.dom.textContent = "";
      } else if (this.dom.parentNode) {
        this.dom.parentNode.removeChild(this.dom);
      }
      this.docView.destroy();
      this.docView = null;
    }
    /**
    This is true when the view has been
    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
    used anymore).
    */
  }, {
    key: "isDestroyed",
    get: function get() {
      return this.docView == null;
    }
    /**
    Used for testing.
    */
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      return _dispatchEvent(this, event);
    }
    /**
    Dispatch a transaction. Will call
    [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
    when given, and otherwise defaults to applying the transaction to
    the current state and calling
    [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
    This method is bound to the view instance, so that it can be
    easily passed around.
    */
  }, {
    key: "dispatch",
    value: function dispatch(tr) {
      var dispatchTransaction = this._props.dispatchTransaction;
      if (dispatchTransaction) dispatchTransaction.call(this, tr);else this.updateState(this.state.apply(tr));
    }
    /**
    @internal
    */
  }, {
    key: "domSelectionRange",
    value: function domSelectionRange() {
      return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom ? safariShadowSelectionRange(this) : this.domSelection();
    }
    /**
    @internal
    */
  }, {
    key: "domSelection",
    value: function domSelection() {
      return this.root.getSelection();
    }
  }]);
  return EditorView;
}();
function computeDocDeco(view) {
  var attrs = Object.create(null);
  attrs["class"] = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", function (value) {
    if (typeof value == "function") value = value(view.state);
    if (value) for (var attr in value) {
      if (attr == "class") attrs["class"] += " " + value[attr];else if (attr == "style") attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName") attrs[attr] = String(value[attr]);
    }
  });
  if (!attrs.translate) attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    var dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = {
      dom: dom,
      deco: Decoration.widget(view.state.selection.head, dom, {
        raw: true,
        marks: view.markCursor
      })
    };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", function (value) {
    return value(view.state) === false;
  });
}
function selectionContextChanged(sel1, sel2) {
  var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  var result = Object.create(null);
  function add(obj) {
    for (var _prop3 in obj) if (!Object.prototype.hasOwnProperty.call(result, _prop3)) result[_prop3] = obj[_prop3];
  }
  view.someProp("nodeViews", add);
  view.someProp("markViews", add);
  return result;
}
function changedNodeViews(a, b) {
  var nA = 0,
    nB = 0;
  for (var _prop4 in a) {
    if (a[_prop4] != b[_prop4]) return true;
    nA++;
  }
  for (var _ in b) nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction) throw new RangeError("Plugins passed directly to the view must not have a state component");
}


/***/ }),

/***/ "./node_modules/rope-sequence/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/rope-sequence/dist/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var GOOD_LEAF_SIZE = 200;

// :: class<T> A rope sequence is a persistent sequence data structure
// that supports appending, prepending, and slicing without doing a
// full copy. It is represented as a mostly-balanced tree.
var RopeSequence = function RopeSequence() {};
RopeSequence.prototype.append = function append(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};

// :: (union<[T], RopeSequence<T>>)  RopeSequence<T>
// Prepend an array or other rope to this one, returning a new rope.
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};

// :: (?number, ?number)  RopeSequence<T>
// Create a rope repesenting a sub-sequence of this rope.
RopeSequence.prototype.slice = function slice(from, to) {
  if (from === void 0) from = 0;
  if (to === void 0) to = this.length;
  if (from >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from), Math.min(this.length, to));
};

// :: (number)  T
// Retrieve the element at the given position from this rope.
RopeSequence.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) {
    return undefined;
  }
  return this.getInner(i);
};

// :: ((element: T, index: number)  ?bool, ?number, ?number)
// Call the given function for each element between the given
// indices. This tends to be more efficient than looping over the
// indices and calling `get`, because it doesn't have to descend the
// tree for every element.
RopeSequence.prototype.forEach = function forEach(f, from, to) {
  if (from === void 0) from = 0;
  if (to === void 0) to = this.length;
  if (from <= to) {
    this.forEachInner(f, from, to, 0);
  } else {
    this.forEachInvertedInner(f, from, to, 0);
  }
};

// :: ((element: T, index: number)  U, ?number, ?number)  [U]
// Map the given functions over the elements of the rope, producing
// a flat array.
RopeSequence.prototype.map = function map(f, from, to) {
  if (from === void 0) from = 0;
  if (to === void 0) to = this.length;
  var result = [];
  this.forEach(function (elt, i) {
    return result.push(f(elt, i));
  }, from, to);
  return result;
};

// :: (?union<[T], RopeSequence<T>>)  RopeSequence<T>
// Create a rope representing the given array, or return the rope
// itself if a rope was given.
RopeSequence.from = function from(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = /*@__PURE__*/function (RopeSequence) {
  function Leaf(values) {
    RopeSequence.call(this);
    this.values = values;
  }
  if (RopeSequence) Leaf.__proto__ = RopeSequence;
  Leaf.prototype = Object.create(RopeSequence && RopeSequence.prototype);
  Leaf.prototype.constructor = Leaf;
  var prototypeAccessors = {
    length: {
      configurable: true
    },
    depth: {
      configurable: true
    }
  };
  Leaf.prototype.flatten = function flatten() {
    return this.values;
  };
  Leaf.prototype.sliceInner = function sliceInner(from, to) {
    if (from == 0 && to == this.length) {
      return this;
    }
    return new Leaf(this.values.slice(from, to));
  };
  Leaf.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf.prototype.forEachInner = function forEachInner(f, from, to, start) {
    for (var i = from; i < to; i++) {
      if (f(this.values[i], start + i) === false) {
        return false;
      }
    }
  };
  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner(f, from, to, start) {
    for (var i = from - 1; i >= to; i--) {
      if (f(this.values[i], start + i) === false) {
        return false;
      }
    }
  };
  Leaf.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf(this.values.concat(other.flatten()));
    }
  };
  Leaf.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function () {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function () {
    return 0;
  };
  Object.defineProperties(Leaf.prototype, prototypeAccessors);
  return Leaf;
}(RopeSequence);

// :: RopeSequence
// The empty rope sequence.
RopeSequence.empty = new Leaf([]);
var Append = /*@__PURE__*/function (RopeSequence) {
  function Append(left, right) {
    RopeSequence.call(this);
    this.left = left;
    this.right = right;
    this.length = left.length + right.length;
    this.depth = Math.max(left.depth, right.depth) + 1;
  }
  if (RopeSequence) Append.__proto__ = RopeSequence;
  Append.prototype = Object.create(RopeSequence && RopeSequence.prototype);
  Append.prototype.constructor = Append;
  Append.prototype.flatten = function flatten() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append.prototype.forEachInner = function forEachInner(f, from, to, start) {
    var leftLen = this.left.length;
    if (from < leftLen && this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false) {
      return false;
    }
  };
  Append.prototype.forEachInvertedInner = function forEachInvertedInner(f, from, to, start) {
    var leftLen = this.left.length;
    if (from > leftLen && this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false) {
      return false;
    }
  };
  Append.prototype.sliceInner = function sliceInner(from, to) {
    if (from == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from, to);
    }
    if (from >= leftLen) {
      return this.right.slice(from - leftLen, to - leftLen);
    }
    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append(this.left, inner);
    }
  };
  Append.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append(inner, this.right);
    }
  };
  Append.prototype.appendInner = function appendInner(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append(this.left, new Append(this.right, other));
    }
    return new Append(this, other);
  };
  return Append;
}(RopeSequence);
/* harmony default export */ __webpack_exports__["default"] = (RopeSequence);

/***/ }),

/***/ "./node_modules/w3c-keyname/index.js":
/*!*******************************************!*\
  !*** ./node_modules/w3c-keyname/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base: function() { return /* binding */ base; },
/* harmony export */   keyName: function() { return /* binding */ keyName; },
/* harmony export */   shift: function() { return /* binding */ shift; }
/* harmony export */ });
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: "\""
};
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);

// Fill in the digit keys
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);

// The function keys
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;

// And the alphabetic keys
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}

// For each code that doesn't have a shift-equivalent, copy the base name
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
function keyName(event) {
  // On macOS, keys held with Shift and Cmd don't reflect the effect of Shift in `.key`.
  // On IE, shift effect is never included in `.key`.
  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  // Edge sometimes produces wrong names (Issue #3)
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name;
}

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "/decidim-packs/";
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
/*!**************************************************************************!*\
  !*** ./gems/decidim-module-core/app/packs/entrypoints/decidim_editor.js ***!
  \**************************************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var src_decidim_editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! src/decidim/editor */ "./gems/decidim-module-core/app/packs/src/decidim/editor/index.js");
/* harmony import */ var stylesheets_decidim_editor_scss__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! stylesheets/decidim/editor.scss */ "./gems/decidim-module-core/app/packs/stylesheets/decidim/editor.scss");


// CSS


// Global exports
window.createEditor = src_decidim_editor__WEBPACK_IMPORTED_MODULE_0__["default"];
}();
/******/ })()
;
//# sourceMappingURL=decidim_editor.js.map